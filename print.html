<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unofficial Bevy Cheat Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <script async defer src="https://buttons.github.io/buttons.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="nagbar.css">
        <link rel="stylesheet" href="sidebar.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="overview.html">Chapter Overview</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="builtins.html">List of Bevy Builtins</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">1.</strong> Bevy Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/guide.html"><strong aria-hidden="true">1.1.</strong> Guided Tour</a></li></ol></li><li class="chapter-item expanded "><a href="cookbook.html"><strong aria-hidden="true">2.</strong> Bevy Cookbook</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cookbook/print-framerate.html"><strong aria-hidden="true">2.1.</strong> Show Framerate</a></li><li class="chapter-item expanded "><a href="cookbook/cursor2world.html"><strong aria-hidden="true">2.2.</strong> Convert cursor to world coordinates</a></li><li class="chapter-item expanded "><a href="cookbook/custom-projection.html"><strong aria-hidden="true">2.3.</strong> Custom Camera Projection</a></li><li class="chapter-item expanded "><a href="cookbook/pan-orbit-camera.html"><strong aria-hidden="true">2.4.</strong> 3D Pan+Orbit Camera</a></li><li class="chapter-item expanded "><a href="cookbook/print-resources.html"><strong aria-hidden="true">2.5.</strong> List All Resource Types</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">3.</strong> Bevy Setup Tips</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup/getting-started.html"><strong aria-hidden="true">3.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="setup/editor.html"><strong aria-hidden="true">3.2.</strong> Text Editor / IDE</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup/editor/vscode.html"><strong aria-hidden="true">3.2.1.</strong> Visual Studio Code</a></li><li class="chapter-item expanded "><a href="setup/editor/jetbrains.html"><strong aria-hidden="true">3.2.2.</strong> JetBrains (RustRover, IntelliJ, CLion)</a></li><li class="chapter-item expanded "><a href="setup/editor/kak.html"><strong aria-hidden="true">3.2.3.</strong> Kakoune</a></li><li class="chapter-item expanded "><a href="setup/editor/vim.html"><strong aria-hidden="true">3.2.4.</strong> Vim</a></li><li class="chapter-item expanded "><a href="setup/editor/emacs.html"><strong aria-hidden="true">3.2.5.</strong> Emacs</a></li></ol></li><li class="chapter-item expanded "><a href="setup/bevy-config.html"><strong aria-hidden="true">3.3.</strong> Customizing Bevy (features, modularity)</a></li><li class="chapter-item expanded "><a href="setup/unofficial-plugins.html"><strong aria-hidden="true">3.4.</strong> Community Plugin Ecosystem</a></li><li class="chapter-item expanded "><a href="setup/bevy-tools.html"><strong aria-hidden="true">3.5.</strong> Dev Tools and Editors for Bevy</a></li><li class="chapter-item expanded "><a href="setup/perf.html"><strong aria-hidden="true">3.6.</strong> Performance Tunables</a></li><li class="chapter-item expanded "><a href="setup/bevy-git.html"><strong aria-hidden="true">3.7.</strong> Using bleeding-edge Bevy (main)</a></li></ol></li><li class="chapter-item expanded "><a href="pitfalls.html"><strong aria-hidden="true">4.</strong> Common Pitfalls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pitfalls/build-errors.html"><strong aria-hidden="true">4.1.</strong> Strange compile errors from Bevy or dependencies</a></li><li class="chapter-item expanded "><a href="pitfalls/performance.html"><strong aria-hidden="true">4.2.</strong> Slow Performance</a></li><li class="chapter-item expanded "><a href="pitfalls/into-system.html"><strong aria-hidden="true">4.3.</strong> Error adding function as system</a></li><li class="chapter-item expanded "><a href="pitfalls/3d-not-rendering.html"><strong aria-hidden="true">4.4.</strong> 3D objects not displaying</a></li><li class="chapter-item expanded "><a href="pitfalls/split-borrows.html"><strong aria-hidden="true">4.5.</strong> Borrow multiple fields from struct</a></li><li class="chapter-item expanded "><a href="pitfalls/time.html"><strong aria-hidden="true">4.6.</strong> Jittering Time (choppy movement/animation)</a></li><li class="chapter-item expanded "><a href="pitfalls/uv-coordinates.html"><strong aria-hidden="true">4.7.</strong> Textures/Images are flipped</a></li></ol></li><li class="chapter-item expanded "><a href="fundamentals.html"><strong aria-hidden="true">5.</strong> Game Engine Fundamentals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fundamentals/coords.html"><strong aria-hidden="true">5.1.</strong> Coordinate System</a></li><li class="chapter-item expanded "><a href="fundamentals/transforms.html"><strong aria-hidden="true">5.2.</strong> Transforms</a></li><li class="chapter-item expanded "><a href="fundamentals/visibility.html"><strong aria-hidden="true">5.3.</strong> Visibility</a></li><li class="chapter-item expanded "><a href="fundamentals/time.html"><strong aria-hidden="true">5.4.</strong> Time and Timers</a></li><li class="chapter-item expanded "><a href="fundamentals/log.html"><strong aria-hidden="true">5.5.</strong> Logging, Console Messages</a></li><li class="chapter-item expanded "><a href="fundamentals/hierarchy.html"><strong aria-hidden="true">5.6.</strong> Parent/Child Hierarchies</a></li><li class="chapter-item expanded "><a href="fundamentals/fixed-timestep.html"><strong aria-hidden="true">5.7.</strong> Fixed Timestep</a></li></ol></li><li class="chapter-item expanded "><a href="graphics.html"><strong aria-hidden="true">6.</strong> General Graphics Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graphics/camera.html"><strong aria-hidden="true">6.1.</strong> Cameras</a></li><li class="chapter-item expanded "><a href="graphics/hdr-tonemap.html"><strong aria-hidden="true">6.2.</strong> HDR and Tonemapping</a></li><li class="chapter-item expanded "><a href="graphics/bloom.html"><strong aria-hidden="true">6.3.</strong> Bloom</a></li></ol></li><li class="chapter-item expanded "><a href="2d.html"><strong aria-hidden="true">7.</strong> Working with 2D</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2d/camera.html"><strong aria-hidden="true">7.1.</strong> 2D Camera Setup</a></li><li class="chapter-item expanded "><a href="2d/sprites.html"><strong aria-hidden="true">7.2.</strong> Sprites and Atlases</a></li></ol></li><li class="chapter-item expanded "><a href="3d.html"><strong aria-hidden="true">8.</strong> Working with 3D</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3d/camera.html"><strong aria-hidden="true">8.1.</strong> 3D Camera Setup</a></li><li class="chapter-item expanded "><a href="3d/gltf.html"><strong aria-hidden="true">8.2.</strong> 3D Models and Scenes (GLTF)</a></li></ol></li><li class="chapter-item expanded "><a href="input.html"><strong aria-hidden="true">9.</strong> Input Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="input/keyboard.html"><strong aria-hidden="true">9.1.</strong> Keyboard</a></li><li class="chapter-item expanded "><a href="input/mouse.html"><strong aria-hidden="true">9.2.</strong> Mouse</a></li><li class="chapter-item expanded "><a href="input/char.html"><strong aria-hidden="true">9.3.</strong> Text / Character</a></li><li class="chapter-item expanded "><a href="input/gamepad.html"><strong aria-hidden="true">9.4.</strong> Gamepad (Controller, Joystick)</a></li><li class="chapter-item expanded "><a href="input/touch.html"><strong aria-hidden="true">9.5.</strong> Touchscreen</a></li><li class="chapter-item expanded "><a href="input/dnd.html"><strong aria-hidden="true">9.6.</strong> Drag-and-Drop (Files)</a></li></ol></li><li class="chapter-item expanded "><a href="window.html"><strong aria-hidden="true">10.</strong> Window Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="window/props.html"><strong aria-hidden="true">10.1.</strong> Window Properties</a></li><li class="chapter-item expanded "><a href="window/clear-color.html"><strong aria-hidden="true">10.2.</strong> Change the Background Color</a></li><li class="chapter-item expanded "><a href="window/mouse-grab.html"><strong aria-hidden="true">10.3.</strong> Grab/Capture the Mouse Cursor</a></li><li class="chapter-item expanded "><a href="window/icon.html"><strong aria-hidden="true">10.4.</strong> Set the Window Icon</a></li></ol></li><li class="chapter-item expanded "><a href="assets.html"><strong aria-hidden="true">11.</strong> Asset Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="assets/handles.html"><strong aria-hidden="true">11.1.</strong> Handles</a></li><li class="chapter-item expanded "><a href="assets/assetserver.html"><strong aria-hidden="true">11.2.</strong> Load Assets from Files</a></li><li class="chapter-item expanded "><a href="assets/data.html"><strong aria-hidden="true">11.3.</strong> Access the Asset Data</a></li><li class="chapter-item expanded "><a href="assets/assetevent.html"><strong aria-hidden="true">11.4.</strong> React to Changes with Asset Events</a></li><li class="chapter-item expanded "><a href="assets/ready.html"><strong aria-hidden="true">11.5.</strong> Track Loading Progress</a></li><li class="chapter-item expanded "><a href="assets/hot-reload.html"><strong aria-hidden="true">11.6.</strong> Hot-Reloading Assets</a></li><li class="chapter-item expanded "><a href="assets/processing.html"><strong aria-hidden="true">11.7.</strong> Processing Assets</a></li></ol></li><li class="chapter-item expanded "><a href="audio.html"><strong aria-hidden="true">12.</strong> Audio</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="audio/basic.html"><strong aria-hidden="true">12.1.</strong> Playing Sounds</a></li><li class="chapter-item expanded "><a href="audio/spatial.html"><strong aria-hidden="true">12.2.</strong> Spatial Audio</a></li><li class="chapter-item expanded "><a href="audio/custom.html"><strong aria-hidden="true">12.3.</strong> Custom Audio Streams</a></li></ol></li><li class="chapter-item expanded "><a href="ui.html"><strong aria-hidden="true">13.</strong> Bevy UI Framework</a></li><li class="chapter-item expanded "><a href="programming.html"><strong aria-hidden="true">14.</strong> Bevy Core Programming Framework</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="programming/ecs-intro.html"><strong aria-hidden="true">14.1.</strong> Intro to ECS</a></li><li class="chapter-item expanded "><a href="programming/intro-data.html"><strong aria-hidden="true">14.2.</strong> Intro: Your Data</a></li><li class="chapter-item expanded "><a href="programming/intro-code.html"><strong aria-hidden="true">14.3.</strong> Intro: Your Code</a></li><li class="chapter-item expanded "><a href="programming/app-builder.html"><strong aria-hidden="true">14.4.</strong> The App</a></li><li class="chapter-item expanded "><a href="programming/systems.html"><strong aria-hidden="true">14.5.</strong> Systems</a></li><li class="chapter-item expanded "><a href="programming/res.html"><strong aria-hidden="true">14.6.</strong> Resources</a></li><li class="chapter-item expanded "><a href="programming/ec.html"><strong aria-hidden="true">14.7.</strong> Entities, Components</a></li><li class="chapter-item expanded "><a href="programming/bundle.html"><strong aria-hidden="true">14.8.</strong> Bundles</a></li><li class="chapter-item expanded "><a href="programming/queries.html"><strong aria-hidden="true">14.9.</strong> Queries</a></li><li class="chapter-item expanded "><a href="programming/commands.html"><strong aria-hidden="true">14.10.</strong> Commands</a></li><li class="chapter-item expanded "><a href="programming/events.html"><strong aria-hidden="true">14.11.</strong> Events</a></li><li class="chapter-item expanded "><a href="programming/local.html"><strong aria-hidden="true">14.12.</strong> Local Resources</a></li><li class="chapter-item expanded "><a href="programming/exclusive.html"><strong aria-hidden="true">14.13.</strong> Exclusive Systems</a></li><li class="chapter-item expanded "><a href="programming/world.html"><strong aria-hidden="true">14.14.</strong> Direct ECS World Access</a></li><li class="chapter-item expanded "><a href="programming/schedules.html"><strong aria-hidden="true">14.15.</strong> Schedules</a></li><li class="chapter-item expanded "><a href="programming/system-order.html"><strong aria-hidden="true">14.16.</strong> System Order of Execution</a></li><li class="chapter-item expanded "><a href="programming/run-criteria.html"><strong aria-hidden="true">14.17.</strong> Run Criteria</a></li><li class="chapter-item expanded "><a href="programming/system-sets.html"><strong aria-hidden="true">14.18.</strong> System Sets</a></li><li class="chapter-item expanded "><a href="programming/states.html"><strong aria-hidden="true">14.19.</strong> States</a></li><li class="chapter-item expanded "><a href="programming/plugins.html"><strong aria-hidden="true">14.20.</strong> Plugins</a></li><li class="chapter-item expanded "><a href="programming/change-detection.html"><strong aria-hidden="true">14.21.</strong> Change Detection</a></li><li class="chapter-item expanded "><a href="programming/system-piping.html"><strong aria-hidden="true">14.22.</strong> System Piping</a></li><li class="chapter-item expanded "><a href="programming/paramset.html"><strong aria-hidden="true">14.23.</strong> ParamSet</a></li><li class="chapter-item expanded "><a href="programming/non-send.html"><strong aria-hidden="true">14.24.</strong> Non-Send</a></li></ol></li><li class="chapter-item expanded "><a href="gpu.html"><strong aria-hidden="true">15.</strong> Bevy Render (GPU) Framework</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gpu/intro.html"><strong aria-hidden="true">15.1.</strong> Render Architecture Overview</a></li><li class="chapter-item expanded "><a href="gpu/stages.html"><strong aria-hidden="true">15.2.</strong> Render Stages</a></li></ol></li><li class="chapter-item expanded "><a href="patterns.html"><strong aria-hidden="true">16.</strong> Programming Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/generic-systems.html"><strong aria-hidden="true">16.1.</strong> Generic Systems</a></li><li class="chapter-item expanded "><a href="patterns/component-storage.html"><strong aria-hidden="true">16.2.</strong> Component Storage (Table/Sparse-Set)</a></li><li class="chapter-item expanded "><a href="patterns/manual-event-clear.html"><strong aria-hidden="true">16.3.</strong> Manual Event Clearing</a></li><li class="chapter-item expanded "><a href="patterns/system-tests.html"><strong aria-hidden="true">16.4.</strong> Writing Tests for Systems</a></li></ol></li><li class="chapter-item expanded "><a href="platforms.html"><strong aria-hidden="true">17.</strong> Bevy on Different Platforms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="platforms/linux.html"><strong aria-hidden="true">17.1.</strong> Linux Desktop</a></li><li class="chapter-item expanded "><a href="platforms/macos.html"><strong aria-hidden="true">17.2.</strong> macOS Desktop</a></li><li class="chapter-item expanded "><a href="platforms/windows.html"><strong aria-hidden="true">17.3.</strong> Windows Desktop</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="platforms/windows/wsl2.html"><strong aria-hidden="true">17.3.1.</strong> Working in WSL2</a></li></ol></li><li class="chapter-item expanded "><a href="platforms/wasm.html"><strong aria-hidden="true">17.4.</strong> Browser (WebAssembly)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="platforms/wasm/size-opt.html"><strong aria-hidden="true">17.4.1.</strong> Optimize for Size</a></li><li class="chapter-item expanded "><a href="platforms/wasm/webpage.html"><strong aria-hidden="true">17.4.2.</strong> Create a Custom Web Page</a></li><li class="chapter-item expanded "><a href="platforms/wasm/gh-pages.html"><strong aria-hidden="true">17.4.3.</strong> Hosting on GitHub Pages</a></li></ol></li><li class="chapter-item expanded "><a href="setup/cross.html"><strong aria-hidden="true">17.5.</strong> Cross-Compilation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup/cross/linux-windows.html"><strong aria-hidden="true">17.5.1.</strong> From Linux to Windows</a></li><li class="chapter-item expanded "><a href="setup/cross/macos-windows.html"><strong aria-hidden="true">17.5.2.</strong> From macOS to Windows</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item expanded "><a href="credits.html">Credits</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="contact.html">Contact Me</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="contributing-bevy.html">Contribute to Bevy</a></li><li class="chapter-item expanded affix "><a href="contributing.html">Contribute to this Book</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Unofficial Bevy Cheat Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="unofficial-bevy-cheat-book"><a class="header" href="#unofficial-bevy-cheat-book">Unofficial Bevy Cheat Book</a></h1>
<p>This is a reference-style book for the <a href="https://bevyengine.org">Bevy game engine</a>
(<a href="https://github.com/bevyengine/bevy">GitHub</a>).</p>
<p>It aims to teach Bevy concepts in a concise way, help you be productive,
and discover the knowledge you need.</p>
<p>This book aggregates a lot of community wisdom that is often not covered
by official documentation, saving you the need to struggle with issues that
others have figured out already!</p>
<p>While it aims to be exhaustive, documenting an entire game engine is
a monumental task. I focus my time on whatever I believe the community
needs most.</p>
<p>Therefore, there are still a lot of omissions, both for basics and advanced
topics. Nevertheless, I am confident this book will prove to be a valuable
resource to you!</p>
<p><em><strong>Welcome! May this book serve you well!</strong></em></p>
<p>(don't forget to
<a class="github-button" href="https://github.com/bevy-cheatbook/bevy-cheatbook" data-icon="octicon-star" aria-label="Star bevy-cheatbook/bevy-cheatbook on GitHub">Star</a>
the book's <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub repository</a>,
and consider <a href="https://github.com/sponsors/inodentry">donating</a> üôÇ)</p>
<h2 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to use this book</a></h2>
<p>The pages in this book are not designed to be read in order. Each page covers
a standalone topic. Feel free to jump to whatever interests you.</p>
<p>If you have a specific topic in mind that you would like to learn about, you
can find it from the table-of-contents (sidebar) or using the search function
(in the top bar).</p>
<p>The <a href="/overview.html">Chapter Overview</a> page will give you a general idea
of how the book is structured.</p>
<p>The text on each page will link to other pages, where you can learn about other
things mentioned in the text. This helps you jump around the book.</p>
<p>If you are new to Bevy, or would like a more guided experience, try the
<a href="/tutorial/guide.html">Guided Tour tutorial</a>. It will help you navigate the book in
an order that makes sense for learning, from beginner to advanced topics.</p>
<p>The <a href="/builtins.html">Bevy Builtins</a> page is a concise cheatsheet of useful
information about types and features provided by Bevy.</p>
<h2 id="recommended-additional-resources"><a class="header" href="#recommended-additional-resources">Recommended Additional Resources</a></h2>
<p>Bevy has a rich collection of <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">official code
examples</a>.</p>
<p>Check out <a href="https://bevyengine.org/assets">bevy-assets</a>, for community-made resources.</p>
<p>Our community is very friendly and helpful. Feel welcome to join the <a href="https://discord.gg/bevy">Bevy
Discord</a> to chat, ask questions, or get involved in the project!</p>
<p>If you want to see some games made with Bevy, see <a href="https://itch.io/games/tag-bevy">itch.io</a>
or <a href="https://bevyengine.org/assets/#input">Bevy Assets</a>.</p>
<h2 id="is-this-book-up-to-date"><a class="header" href="#is-this-book-up-to-date">Is this book up to date?</a></h2>
<p>Bevy has a very rapid pace of development, with new major releases roughly every
three months. Every version brings a lot of changes, so keeping this book
updated can be a major challenge.</p>
<p>To ease the maintenance burden, the policy of the project is that the book may
contain content for different versions of Bevy. However, mixing Bevy versions
on the same page is not allowed.</p>
<p>At the top of every page, you will see the version it was last updated for.
All content on that page must be relevant for the stated Bevy version.</p>
<h2 id="support-me"><a class="header" href="#support-me">Support Me</a></h2>
<p><a href="https://github.com/sponsors/inodentry"><button class="ghsponsors-button">GitHub Sponsors</button></a>
<a href="https://patreon.com/iyesgames"><button class="patreon-button">Patreon</button></a>
<a href="bitcoin:bc1qaf32uqsg6mngw9g4aqc3l2jvuv46qx0zw2438p"><button class="bitcoin-button">Bitcoin</button></a></p>
<p>If you like this book, please consider sponsoring me. Thank you! ‚ù§Ô∏è</p>
<p>I'd like to keep improving and maintaining this book, to provide a high-quality
independent learning resource for the Bevy community.</p>
<h2 id="support-bevy"><a class="header" href="#support-bevy">Support Bevy</a></h2>
<p><a href="https://github.com/sponsors/cart"><button class="ghsponsors-button">GitHub Sponsors</button></a></p>
<p>If you like the Bevy Game Engine, you should consider donating to the project.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>Copyright ¬© 2021-2023 Ida (IyesGames)</p>
<p>All code in the book is provided under the
<a href="https://github.com/bevy-cheatbook/mit-0">MIT-0 License</a>.
At your option, you may also use it under the regular MIT License.</p>
<p>The text of the book is provided under the
<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>.</p>
<p>Exception: If used for the purpose of contribution to the &quot;Official Bevy
Project&quot;, the entire content of the book may be used under the <a href="https://github.com/bevy-cheatbook/mit-0">MIT-0
License</a>.</p>
<p>&quot;Official Bevy Project&quot; is defined as:</p>
<ul>
<li>Contents of the Git repository hosted at <a href="https://github.com/bevyengine/bevy">https://github.com/bevyengine/bevy</a></li>
<li>Contents of the Git repository hosted at <a href="https://github.com/bevyengine/bevy-website">https://github.com/bevyengine/bevy-website</a></li>
<li>Anything publicly visible on the <a href="https://bevyengine.org">bevyengine.org</a> website</li>
</ul>
<p>The MIT-0 license applies as soon as your contribution has been accepted upstream.</p>
<p>GitHub Forks and Pull Requests created for the purposes of contributing to
the Official Bevy Project are given the following license exception: the
Attribution requirements of CC BY-NC-SA 4.0 are waived for as long as the
work is pending upstream review (Pull Request Open). If upstream rejects
your contribution, you are given a period of 1 month to comply with the
full terms of the CC BY-NC-SA 4.0 license or delete your work. If upstream
accepts your contribution, the MIT-0 license applies.</p>
<h2 id="contributions"><a class="header" href="#contributions">Contributions</a></h2>
<p>Development of this book is hosted on <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<p>Please file GitHub Issues for any wrong/confusing/misleading information,
as well as suggestions for new content you'd like to be added to the book.</p>
<p>Contributions are accepted, with some limitations.</p>
<p>See the <a href="/contributing.html">Contributing</a> section for all the details.</p>
<h2 id="stability-warning"><a class="header" href="#stability-warning">Stability Warning</a></h2>
<p>Bevy is still a new and experimental game engine! It has only been public
since August 2020!</p>
<p>While improvements have been happening at an incredible pace, and development
is active, Bevy simply hasn't yet had the time to mature.</p>
<p><em>There are no stability guarantees and breaking changes happen often!</em></p>
<p>Usually, it not hard to adapt to changes with new releases, but you have been
warned!</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="chapter-overview"><a class="header" href="#chapter-overview">Chapter Overview</a></h1>
<p>The <a href="/builtins.html">Bevy Builtins</a> page is a concise cheatsheet of useful
information about types and features provided by Bevy.</p>
<p>The <a href="/tutorial.html">Bevy Tutorials</a> chapter is for tutorials/guides
that you can follow from start to finish.</p>
<p>The <a href="/cookbook.html">Bevy Cookbook</a> is for more self-contained /
narrow-scoped examples that teach you how to solve specific problems.</p>
<p>The rest of the book is designed as a reference, covering different aspects of
working with Bevy. Feel free to jump around the book, to learn about any topic
that interests you. On every page of the book, any time other topics are
mentioned, the relevant pages or official API documentation is linked.</p>
<p>If you would like a guided experience, or to browse the book by relative
difficulty (from beginner to advanced), try the <a href="/tutorial.html">guided tutorial
page</a>. It recommends topics in a logical order for learning.</p>
<p>The book has the following general chapters:</p>
<ul>
<li><a href="/setup.html">Bevy Setup Tips</a>: project setup advice, recommendations for tools and plugins</li>
<li><a href="/pitfalls.html">Common Pitfalls</a>: solutions for common issues encountered by the community</li>
<li><a href="/platforms.html">Bevy on Different Platforms</a>: information about working with specific plaforms / OSs</li>
</ul>
<!-- - [Appendix: General Concepts][chapter::concepts]: various general gamedev knowledge, not specific to Bevy -->
<p>To learn how to program in Bevy, see these chapters:</p>
<ul>
<li><a href="/programming.html">Bevy Core Programming Framework</a>: the ECS+App frameworks, the foundation of everything</li>
<li><a href="/patterns.html">Programming Patterns</a>: opinionated advice, patterns, idioms</li>
<li><a href="/gpu.html">Bevy Render (GPU) Framework</a>: working with the GPU and Bevy's rendering</li>
</ul>
<p>The following chapters cover various Bevy feature areas:</p>
<ul>
<li><a href="/fundamentals.html">Game Engine Fundamentals</a></li>
<li><a href="/graphics.html">General Graphics Features</a></li>
<li><a href="/2d.html">Working with 2D</a></li>
<li><a href="/3d.html">Working with 3D</a></li>
<li><a href="/input.html">Input Handling</a></li>
<li><a href="/window.html">Window Management</a></li>
<li><a href="/assets.html">Asset Management</a></li>
<li><a href="/audio.html">Audio</a></li>
<li><a href="/ui.html">Bevy UI Framework</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-11">0.11</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="list-of-bevy-builtins"><a class="header" href="#list-of-bevy-builtins">List of Bevy Builtins</a></h1>
<p>This page is a quick condensed listing of all the important things provided
by Bevy.</p>
<ul>
<li><a href="builtins.html#systemparams">SystemParams</a></li>
<li><a href="builtins.html#assets">Assets</a></li>
<li><a href="builtins.html#file-formats">File Formats</a></li>
<li><a href="builtins.html#gltf-asset-labels">GLTF Asset Labels</a></li>
<li><a href="builtins.html#shader-imports">Shader Imports</a></li>
<li><a href="builtins.html#wgpu-backends"><code>wgpu</code> Backends</a></li>
<li><a href="builtins.html#schedules">Schedules</a></li>
<li><a href="builtins.html#run-conditions">Run Conditions</a></li>
<li><a href="builtins.html#plugins">Plugins</a></li>
<li><a href="builtins.html#bundles">Bundles</a></li>
<li><a href="builtins.html#configuration-resources">Resources (Configuration)</a></li>
<li><a href="builtins.html#engine-resources">Resources (Engine User)</a>
<ul>
<li><a href="builtins.html#engine-resources">Main World</a></li>
<li><a href="builtins.html#render-world-resources">Render World</a></li>
<li><a href="builtins.html#low-level-wgpu-resources">Low-Level <code>wgpu</code> access</a></li>
</ul>
</li>
<li><a href="builtins.html#input-handling-resources">Resources (Input)</a></li>
<li><a href="builtins.html#input-events">Events (Input)</a></li>
<li><a href="builtins.html#engine-events">Events (Engine)</a></li>
<li><a href="builtins.html#system-and-control-events">Events (System/Control)</a></li>
<li><a href="builtins.html#components">Components</a></li>
</ul>
<h2 id="systemparams"><a class="header" href="#systemparams">SystemParams</a></h2>
<p>These are all the special types that can be used as <a href="/programming/systems.html">system</a> parameters.</p>
<p><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/trait.SystemParam.html#implementors">(List in API Docs)</a></p>
<p>In regular <a href="/programming/systems.html">systems</a>:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>:
Manipulate the ECS using <a href="/programming/commands.html">commands</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.Query.html"><code>Query&lt;T, F = ()&gt;</code></a> (can contain tuples of up to 15 types):
Access to <a href="/programming/intro-data.html#entities--components">entities and components</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.Res.html"><code>Res&lt;T&gt;</code></a>:
Shared access to a <a href="/programming/res.html">resource</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a>:
Exclusive (mutable) access to a <a href="/programming/res.html">resource</a></li>
<li><code>Option&lt;Res&lt;T&gt;&gt;</code>:
Shared access to a resource that may not exist</li>
<li><code>Option&lt;ResMut&lt;T&gt;&gt;</code>:
Exclusive (mutable) access to a resource that may not exist</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a>:
Data <a href="/programming/local.html">local</a> to the system</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/event/struct.EventReader.html"><code>EventReader&lt;T&gt;</code></a>:
Receive <a href="/programming/events.html">events</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/event/struct.EventWriter.html"><code>EventWriter&lt;T&gt;</code></a>:
Send <a href="/programming/events.html">events</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/world/struct.World.html"><code>&amp;World</code></a>:
Read-only <a href="/programming/world.html">direct access to the ECS World</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.ParamSet.html"><code>ParamSet&lt;...&gt;</code></a> (with up to 8 params):
Resolve <a href="/programming/paramset.html">conflicts between incompatible system parameters</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.Deferred.html"><code>Deferred&lt;T&gt;</code></a>:
Custom <a href="/programming/deferred.html">&quot;deferred mutation&quot;</a>, similar to <code>Commands</code>, but for your own things</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/removal_detection/struct.RemovedComponents.html"><code>RemovedComponents&lt;T&gt;</code></a>:
<a href="/programming/change-detection.html#removal-detection">Removal detection</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/gizmos/gizmos/struct.Gizmos.html"><code>Gizmos</code></a>:
A way to <a href="/fundamentals/gizmos.html">draw lines and shapes</a> on the screen for debugging and dev purposes</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/diagnostic/struct.Diagnostics.html"><code>Diagnostics</code></a>:
A way to <a href="/fundamentals/diagnostics.html">report measurements/debug data</a> to Bevy for tracking and visualization</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.SystemName.html"><code>SystemName</code></a>:
The name (string) of the system, may be useful for debugging</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.ParallelCommands.html"><code>ParallelCommands</code></a>:
Abstraction to help use <code>Commands</code> when you will do your own parallelism</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/world/struct.WorldId.html"><code>WorldId</code></a>:
The World ID of the <a href="/programming/world.html">world</a> the system is running on</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/component/struct.ComponentIdFor.html"><code>ComponentIdFor&lt;T&gt;</code></a>:
Get the <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/component/struct.ComponentId.html"><code>ComponentId</code></a> of a given <a href="/programming/ec.html#components">component</a> type</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/entity/struct.Entities.html"><code>Entities</code></a>:
Low-level ECS metadata: All entities</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/component/struct.Components.html"><code>Components</code></a>:
Low-level ECS metadata: All components</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/bundle/struct.Bundles.html"><code>Bundles</code></a>:
Low-level ECS metadata: All bundles</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/archetype/struct.Archetypes.html"><code>Archetypes</code></a>:
Low-level ECS metadata: All archetypes</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.SystemChangeTick.html"><code>SystemChangeTick</code></a>:
Low-level ECS metadata: Tick used for change detection</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.NonSend.html"><code>NonSend&lt;T&gt;</code></a>:
Shared access to <a href="/programming/non-send.html">Non-<code>Send</code></a> (main thread only) data</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.NonSendMut.html"><code>NonSendMut&lt;T&gt;</code></a>:
Exclusive access to <a href="/programming/non-send.html">Non-<code>Send</code></a> (main thread only) data</li>
<li><code>Option&lt;NonSend&lt;T&gt;&gt;</code>:
Shared access to <a href="/programming/non-send.html">Non-<code>Send</code></a> (main thread only) data that may not exist</li>
<li><code>Option&lt;NonSendMut&lt;T&gt;&gt;</code>:
Exclusive access to <a href="/programming/non-send.html">Non-<code>Send</code></a> (main thread only) data that may not exist</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.StaticSystemParam.html"><code>StaticSystemParam</code></a>:
Helper for generic system abstractions, to avoid lifetime annotations</li>
<li>tuples containing any of these types, with up to 16 members</li>
</ul>
<p>In <a href="/programming/exclusive.html">exclusive systems</a>:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/world/struct.World.html"><code>&amp;mut World</code></a>:
Full <a href="/programming/world.html">direct access to the ECS World</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a>:
Data <a href="/programming/local.html">local</a> to the system</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.SystemState.html"><code>SystemState&lt;P&gt;</code></a>:
Emulates a regular system, allowing you to easily access data from the World.
<code>P</code> are the system parameters.</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/query/struct.QueryState.html"><code>QueryState&lt;Q, F = ()&gt;</code></a>:
Allows you to perform queries on the World, similar to a <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.Query.html"><code>Query</code></a>
in regular systems.</li>
</ul>
<p>Your function can have a maximum of 16 total parameters. If you need more,
group them into tuples to work around the limit. Tuples can contain up to
16 members, but can be nested indefinitely.</p>
<p>Systems running during the <a href="/TODO.html">Extract schedule</a> can also use
<a href="https://docs.rs/bevy/0.11.0/bevy/render/struct.Extract.html"><code>Extract&lt;T&gt;</code></a>, to access data from the Main World instead of the
Render World. <code>T</code> can be any read-only system parameter type.</p>
<h2 id="assets"><a class="header" href="#assets">Assets</a></h2>
<p><a href="/assets.html">(more info about working with assets)</a></p>
<p>These are the Asset types registered by Bevy by default.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.Image.html"><code>Image</code></a>:
Pixel data, used as a texture for 2D and 3D rendering;
also contains the <a href="https://docs.rs/bevy/0.11.0/bevy/render/render_resource/struct.SamplerDescriptor.html"><code>SamplerDescriptor</code></a> for texture filtering settings</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.TextureAtlas.html"><code>TextureAtlas</code></a>:
2D &quot;Sprite Sheet&quot; defining sub-images within a single larger image</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a>:
3D Mesh (geometry data), contains vertex attributes (like position, UVs, normals)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/render_resource/struct.Shader.html"><code>Shader</code></a>:
GPU shader code, in one of the supported languages (WGSL/SPIR-V/GLSL)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.ColorMaterial.html"><code>ColorMaterial</code></a>:
Basic &quot;2D material&quot;: contains color, optionally an image</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a>:
&quot;3D material&quot; with support for Physically-Based Rendering</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/animation/struct.AnimationClip.html"><code>AnimationClip</code></a>:
Data for a single animation sequence, can be used with <a href="https://docs.rs/bevy/0.11.0/bevy/animation/struct.AnimationPlayer.html"><code>AnimationPlayer</code></a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/text/struct.Font.html"><code>Font</code></a>:
Font data used for text rendering</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/scene/struct.Scene.html"><code>Scene</code></a>:
Scene composed of literal ECS entities to instantiate</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/scene/struct.DynamicScene.html"><code>DynamicScene</code></a>:
Scene composed with dynamic typing and reflection</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.Gltf.html"><code>Gltf</code></a>:
<a href="/3d/gltf.html#gltf-master-asset">GLTF Master Asset</a>: index of the entire contents of a GLTF file</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.GltfNode.html"><code>GltfNode</code></a>:
Logical GLTF object in a scene</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.GltfMesh.html"><code>GltfMesh</code></a>:
Logical GLTF 3D model, consisting of multiple <code>GltfPrimitive</code>s</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.GltfPrimitive.html"><code>GltfPrimitive</code></a>:
Single unit to be rendered, contains the Mesh and Material to use</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.AudioSource.html"><code>AudioSource</code></a>:
Audio data for <code>bevy_audio</code></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/text/struct.FontAtlasSet.html"><code>FontAtlasSet</code></a>:
(internal use for text rendering)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/skinning/struct.SkinnedMeshInverseBindposes.html"><code>SkinnedMeshInverseBindposes</code></a>:
(internal use for skeletal animation)</li>
</ul>
<h2 id="file-formats"><a class="header" href="#file-formats">File Formats</a></h2>
<p>These are the asset file formats (asset loaders) supported by Bevy. Support
for each one can be enabled/disabled using <a href="/setup/bevy-config.html">cargo features</a>. Some
are enabled by default, many are not.</p>
<p>Image formats (loaded as <a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.Image.html"><code>Image</code></a> assets):</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Cargo feature</th><th>Default?</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>PNG</td><td><code>&quot;png&quot;</code></td><td>Yes</td><td><code>.png</code></td></tr>
<tr><td>HDR</td><td><code>&quot;hdr&quot;</code></td><td>Yes</td><td><code>.hdr</code></td></tr>
<tr><td>KTX2</td><td><code>&quot;ktx2&quot;</code></td><td>Yes</td><td><code>.ktx2</code></td></tr>
<tr><td>KTX2+zstd</td><td><code>&quot;ktx2&quot;, &quot;zstd&quot;</code></td><td>Yes</td><td><code>.ktx2</code></td></tr>
<tr><td>JPEG</td><td><code>&quot;jpeg&quot;</code></td><td>No</td><td><code>.jpg</code>, <code>.jpeg</code></td></tr>
<tr><td>WebP</td><td><code>&quot;webp&quot;</code></td><td>No</td><td><code>.webp</code></td></tr>
<tr><td>OpenEXR</td><td><code>&quot;exr&quot;</code></td><td>No</td><td><code>.exr</code></td></tr>
<tr><td>TGA</td><td><code>&quot;tga&quot;</code></td><td>No</td><td><code>.tga</code></td></tr>
<tr><td>PNM</td><td><code>&quot;pnm&quot;</code></td><td>No</td><td><code>.pam</code>, <code>.pbm</code>, <code>.pgm</code>, <code>.ppm</code></td></tr>
<tr><td>BMP</td><td><code>&quot;bmp&quot;</code></td><td>No</td><td><code>.bmp</code></td></tr>
<tr><td>DDS</td><td><code>&quot;dds&quot;</code></td><td>No</td><td><code>.dds</code></td></tr>
<tr><td>KTX2+zlib</td><td><code>&quot;ktx2&quot;, &quot;zlib&quot;</code></td><td>No</td><td><code>.ktx2</code></td></tr>
<tr><td>Basis</td><td><code>&quot;basis-universal&quot;</code></td><td>No</td><td><code>.basis</code></td></tr>
</tbody></table>
</div>
<p>Audio formats (loaded as <a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.AudioSource.html"><code>AudioSource</code></a> assets):</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Cargo feature</th><th>Default?</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>OGG Vorbis</td><td><code>&quot;vorbis&quot;</code></td><td>Yes</td><td><code>.ogg</code>, <code>.oga</code>, <code>.spx</code></td></tr>
<tr><td>FLAC</td><td><code>&quot;flac&quot;</code></td><td>No</td><td><code>.flac</code></td></tr>
<tr><td>WAV</td><td><code>&quot;wav&quot;</code></td><td>No</td><td><code>.wav</code></td></tr>
<tr><td>MP3</td><td><code>&quot;mp3&quot;</code></td><td>No</td><td><code>.mp3</code></td></tr>
</tbody></table>
</div>
<p>3D asset (model or scene) formats:</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Cargo feature</th><th>Default?</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>GLTF</td><td><code>&quot;bevy_gltf&quot;</code></td><td>Yes</td><td><code>.gltf</code>, <code>.glb</code></td></tr>
</tbody></table>
</div>
<p>Shader formats (loaded as <a href="https://docs.rs/bevy/0.11.0/bevy/render/render_resource/struct.Shader.html"><code>Shader</code></a> assets):</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Cargo feature</th><th>Default?</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>WGSL</td><td>n/a</td><td>Yes</td><td><code>.wgsl</code></td></tr>
<tr><td>GLSL</td><td><code>&quot;shader_format_glsl&quot;</code></td><td>No</td><td><code>.vert</code>, <code>.frag</code>, <code>.comp</code></td></tr>
<tr><td>SPIR-V</td><td><code>&quot;shader_format_spirv&quot;</code></td><td>No</td><td><code>.spv</code></td></tr>
</tbody></table>
</div>
<p>Font formats (loaded as <a href="https://docs.rs/bevy/0.11.0/bevy/text/struct.Font.html"><code>Font</code></a> assets):</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Cargo feature</th><th>Default?</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>TrueType</td><td>n/a</td><td>Yes</td><td><code>.ttf</code></td></tr>
<tr><td>OpenType</td><td>n/a</td><td>Yes</td><td><code>.otf</code></td></tr>
</tbody></table>
</div>
<p>Bevy Scenes:</p>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Filename extensions</th></tr></thead><tbody>
<tr><td>RON-serialized scene</td><td><code>.scn</code>,<code>.scn.ron</code></td></tr>
</tbody></table>
</div>
<p>There are unofficial plugins available for adding support for even more file formats.</p>
<h2 id="gltf-asset-labels"><a class="header" href="#gltf-asset-labels">GLTF Asset Labels</a></h2>
<p><a href="/3d/gltf.html#assetpath-with-labels">Asset path labels to refer to GLTF sub-assets.</a></p>
<p>The following asset labels are supported (<code>{}</code> is the numerical index):</p>
<ul>
<li><code>Scene{}</code>: GLTF Scene as Bevy <a href="https://docs.rs/bevy/0.11.0/bevy/scene/struct.Scene.html"><code>Scene</code></a></li>
<li><code>Node{}</code>: GLTF Node as <a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.GltfNode.html"><code>GltfNode</code></a></li>
<li><code>Mesh{}</code>: GLTF Mesh as <a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.GltfMesh.html"><code>GltfMesh</code></a></li>
<li><code>Mesh{}/Primitive{}</code>: GLTF Primitive as Bevy <a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a></li>
<li><code>Mesh{}/Primitive{}/MorphTargets</code>: Morph target animation data for a GLTF Primitive</li>
<li><code>Texture{}</code>: GLTF Texture as Bevy <a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.Image.html"><code>Image</code></a></li>
<li><code>Material{}</code>: GLTF Material as Bevy <a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a></li>
<li><code>DefaultMaterial</code>: as above, if the GLTF file contains a default material with no index</li>
<li><code>Animation{}</code>: GLTF Animation as Bevy <a href="https://docs.rs/bevy/0.11.0/bevy/animation/struct.AnimationClip.html"><code>AnimationClip</code></a></li>
<li><code>Skin{}</code>: GLTF mesh skin as Bevy <a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/skinning/struct.SkinnedMeshInverseBindposes.html"><code>SkinnedMeshInverseBindposes</code></a></li>
</ul>
<h2 id="shader-imports"><a class="header" href="#shader-imports">Shader Imports</a></h2>
<p>TODO</p>
<h2 id="wgpu-backends"><a class="header" href="#wgpu-backends"><code>wgpu</code> Backends</a></h2>
<p><a href="https://github.com/gfx-rs/wgpu"><code>wgpu</code></a> (and hence Bevy) supports the following backends:</p>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Backends (in order of priority)</th></tr></thead><tbody>
<tr><td>Linux</td><td>Vulkan, GLES3</td></tr>
<tr><td>Windows</td><td>DirectX 12, Vulkan, GLES3</td></tr>
<tr><td>macOS</td><td>Metal</td></tr>
<tr><td>iOS</td><td>Metal</td></tr>
<tr><td>Android</td><td>Vulkan, GLES3</td></tr>
<tr><td>Web</td><td>WebGPU, WebGL2</td></tr>
</tbody></table>
</div>
<p>On GLES3 and WebGL2, some renderer features are unsupported and performance is worse.</p>
<p>WebGPU is experimental and few browsers support it.</p>
<h2 id="schedules"><a class="header" href="#schedules">Schedules</a></h2>
<p>Internally, Bevy has these built-in <a href="/programming/schedules.html">schedules</a>:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.Main.html"><code>Main</code></a>:
runs every frame update cycle, to perform general app logic</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/struct.ExtractSchedule.html"><code>ExtractSchedule</code></a>:
runs after <code>Main</code>, to copy data from the Main World into the Render World</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/struct.Render.html"><code>Render</code></a>:
runs after <code>ExtractSchedule</code>, to perform all rendering/graphics, in parallel with the next <code>Main</code> run</li>
</ul>
<p>The <code>Main</code> schedule simply runs a sequence of other schedules:</p>
<p>On the first run (first frame update of the app):</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.PreStartup.html"><code>PreStartup</code></a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.Startup.html"><code>Startup</code></a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.PostStartup.html"><code>PostStartup</code></a></li>
</ul>
<p>On every run (controlled via the <a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.MainScheduleOrder.html"><code>MainScheduleOrder</code></a> <a href="/programming/res.html">resource</a>):</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.First.html"><code>First</code></a>: any initialization that must be done at the start of every frame</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.PreUpdate.html"><code>PreUpdate</code></a>: for engine-internal systems intended to run before user logic</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.StateTransition.html"><code>StateTransition</code></a>: perform any pending <a href="/programming/states.html">state</a> transitions</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.RunFixedUpdateLoop.html"><code>RunFixedUpdateLoop</code></a>: runs the <a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.FixedUpdate.html"><code>FixedUpdate</code></a> schedule as many times as needed</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.Update.html"><code>Update</code></a>: for all user logic (your systems) that should run every frame</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a>: for engine-internal systems intended to run after user logic</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.Last.html"><code>Last</code></a>: any final cleanup that must be done at the end of every frame</li>
</ul>
<p><code>FixedUpdate</code> is for all user logic (your systems) that should run at a <a href="/fundamentals/fixed-timestep.html">fixed timestep</a>.</p>
<p><code>StateTransition</code> runs the
<a href="https://docs.rs/bevy/0.11.0/bevy/ecs/schedule/struct.OnEnter.html"><code>OnEnter(...)</code></a>/<a href="https://docs.rs/bevy/0.11.0/bevy/ecs/schedule/struct.OnTransition.html"><code>OnTransition(...)</code></a>/<a href="https://docs.rs/bevy/0.11.0/bevy/ecs/schedule/struct.OnExit.html"><code>OnExit(...)</code></a>
schedules for your <a href="/programming/states.html">states</a>, when you want to change state.</p>
<p>The <a href="https://docs.rs/bevy/0.11.0/bevy/render/struct.Render.html"><code>Render</code></a> schedule is organized using <a href="/programming/system-sets.html">sets</a> (<a href="https://docs.rs/bevy/0.11.0/bevy/render/enum.RenderSet.html"><code>RenderSet</code></a>):</p>
<ul>
<li><code>ExtractCommands</code>: apply <a href="/programming/deferred.html">deferred</a> buffers from systems that ran in <code>ExtractSchedule</code></li>
<li><code>Prepare</code>/<code>PrepareFlush</code>: set up data on the GPU (buffers, textures, etc.)</li>
<li><code>Queue</code>/<code>QueueFlush</code>: generate the render jobs to be run (usually <a href="/TODO.html">phase items</a>)</li>
<li><code>PhaseSort</code>/<code>PhaseSortFlush</code>: sort and batch <a href="/TODO.html">phase items</a> for efficient rendering</li>
<li><code>Render</code>/<code>RenderFlush</code>: execute the <a href="/TODO.html">render graph</a> to actually trigger the GPU to do work</li>
<li><code>Cleanup</code>/<code>CleanupFlush</code>: clear any data from the render World that should not persist to the next frame</li>
</ul>
<p>The <code>*Flush</code> variants are just to apply any <a href="/programming/deferred.html">deferred</a> buffers after every step, if needed.</p>
<h2 id="run-conditions"><a class="header" href="#run-conditions">Run Conditions</a></h2>
<p>TODO</p>
<h2 id="plugins"><a class="header" href="#plugins">Plugins</a></h2>
<p>TODO</p>
<h2 id="bundles"><a class="header" href="#bundles">Bundles</a></h2>
<p>Bevy's built-in <a href="/programming/bundle.html">bundle</a> types, for spawning different common
kinds of entities.</p>
<p><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/bundle/trait.Bundle.html#implementors">(List in API Docs)</a></p>
<p>Any tuples of up to 15 <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/component/trait.Component.html"><code>Component</code></a> types are valid bundles.</p>
<p>General:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/prelude/struct.SpatialBundle.html"><code>SpatialBundle</code></a>:
Contains the required <a href="/fundamentals/transforms.html">transform</a> and <a href="/fundamentals/visibility.html">visibility</a>
components that must be included on <em>all</em> entities that need rendering or <a href="/fundamentals/hierarchy.html">hierarchy</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/transform/struct.TransformBundle.html"><code>TransformBundle</code></a>:
Contains only the transform types, subset of <code>SpatialBundle</code></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/view/visibility/struct.VisibilityBundle.html"><code>VisibilityBundle</code></a>:
Contains only the visibility types, subset of <code>SpatialBundle</code></li>
</ul>
<p>Scenes:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/scene/struct.SceneBundle.html"><code>SceneBundle</code></a>:
Used for spawning scenes</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/scene/struct.DynamicSceneBundle.html"><code>DynamicSceneBundle</code></a>:
Used for spawning dynamic scenes</li>
</ul>
<p>Audio:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/audio/type.AudioBundle.html"><code>AudioBundle</code></a>:
Play [audio][cb::audio] from an <a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.AudioSource.html"><code>AudioSource</code></a> asset</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/audio/type.SpatialAudioBundle.html"><code>SpatialAudioBundle</code></a>:
Play <a href="/audio/spatial.html">positional audio</a> from an <a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.AudioSource.html"><code>AudioSource</code></a> asset</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.AudioSourceBundle.html"><code>AudioSourceBundle</code></a>:
Play audio from a <a href="/audio/custom.html">custom data source/stream</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.SpatialAudioSourceBundle.html"><code>SpatialAudioSourceBundle</code></a>:
Play positional audio from a <a href="/audio/custom.html">custom data source/stream</a></li>
</ul>
<p>Bevy 3D:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/core_pipeline/core_3d/struct.Camera3dBundle.html"><code>Camera3dBundle</code></a>:
3D camera, can use perspective (default) or orthographic projection</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/core_pipeline/experimental/taa/struct.TemporalAntiAliasBundle.html"><code>TemporalAntiAliasBundle</code></a>:
Add this to a 3D camera to enable TAA</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.ScreenSpaceAmbientOcclusionBundle.html"><code>ScreenSpaceAmbientOcclusionBundle</code></a>:
Add this to a 3D camera to enable SSAO</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.MaterialMeshBundle.html"><code>MaterialMeshBundle</code></a>:
3D Object/Primitive: a Mesh and a custom Material to draw it with</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/type.PbrBundle.html"><code>PbrBundle</code></a>:
<code>MaterialMeshBundle</code> with the default Physically-Based Material (<a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a>)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.DirectionalLightBundle.html"><code>DirectionalLightBundle</code></a>: 
3D directional light (like the sun)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.PointLightBundle.html"><code>PointLightBundle</code></a>: 
3D point light (like a lamp or candle)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.SpotLightBundle.html"><code>SpotLightBundle</code></a>: 
3D spot light (like a projector or flashlight)</li>
</ul>
<p>Bevy 2D:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/core_pipeline/core_2d/struct.Camera2dBundle.html"><code>Camera2dBundle</code></a>:
2D camera, uses orthographic projection + other special configuration for 2D</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.SpriteBundle.html"><code>SpriteBundle</code></a>: 
2D sprite (<a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.Image.html"><code>Image</code></a> asset type)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.SpriteSheetBundle.html"><code>SpriteSheetBundle</code></a>:
2D sprite (<a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.TextureAtlas.html"><code>TextureAtlas</code></a> asset type)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.MaterialMesh2dBundle.html"><code>MaterialMesh2dBundle</code></a>:
2D shape, with custom Mesh and Material (similar to 3D objects)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/text/struct.Text2dBundle.html"><code>Text2dBundle</code></a>:
Text to be drawn in the 2D world (not the UI)</li>
</ul>
<p>Bevy UI:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ui/node_bundles/struct.NodeBundle.html"><code>NodeBundle</code></a>:
Empty node element (like HTML <code>&lt;div&gt;</code>)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ui/node_bundles/struct.ButtonBundle.html"><code>ButtonBundle</code></a>:
Button element</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ui/node_bundles/struct.ImageBundle.html"><code>ImageBundle</code></a>:
Image element (<a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.Image.html"><code>Image</code></a> asset type)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ui/node_bundles/struct.AtlasImageBundle.html"><code>AtlasImageBundle</code></a>:
Image element (<a href="https://docs.rs/bevy/0.11.0/bevy/sprite/struct.TextureAtlas.html"><code>TextureAtlas</code></a> asset type)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ui/node_bundles/struct.TextBundle.html"><code>TextBundle</code></a>:
Text element</li>
</ul>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<p><a href="/programming/res.html">(more info about working with resources)</a></p>
<h3 id="configuration-resources"><a class="header" href="#configuration-resources">Configuration Resources</a></h3>
<p>These resources allow you to change the settings for how various parts of Bevy work.</p>
<p>These may be inserted at the start, but should also be fine to change at runtime (from a
<a href="/programming/systems.html">system</a>):</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/core_pipeline/clear_color/struct.ClearColor.html"><code>ClearColor</code></a>:
Global renderer background color to clear the window at the start of each frame</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/audio/struct.GlobalVolume.html"><code>GlobalVolume</code></a>:
The overall volume for playing audio</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.AmbientLight.html"><code>AmbientLight</code></a>:
Global renderer &quot;fake lighting&quot;, so that shadows don't look too dark / black</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/view/enum.Msaa.html"><code>Msaa</code></a>:
Global renderer setting for Multi-Sample Anti-Aliasing (some platforms might only support the values 1 and 4)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ui/struct.UiScale.html"><code>UiScale</code></a>:
Global scale value to make all UIs bigger/smaller</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/gizmos/struct.GizmoConfig.html"><code>GizmoConfig</code></a>:
Controls how <a href="/fundamentals/gizmos.html">gizmos</a> are rendered</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/pbr/wireframe/struct.WireframeConfig.html"><code>WireframeConfig</code></a>:
Global toggle to make everything be rendered as wireframe</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.GamepadSettings.html"><code>GamepadSettings</code></a>:
Gamepad input device settings, like joystick deadzones and button sensitivities</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/winit/struct.WinitSettings.html"><code>WinitSettings</code></a>:
Settings for the OS Windowing backend, including update loop / power-management settings</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/time/enum.TimeUpdateStrategy.html"><code>TimeUpdateStrategy</code></a>:
Used to control how the <a href="https://docs.rs/bevy/0.11.0/bevy/time/struct.Time.html"><code>Time</code></a> is updated</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/schedule/struct.Schedules.html"><code>Schedules</code></a>:
Stores all <a href="/programming/schedules.html">schedules</a>, letting you register additional functionality at runtime</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.MainScheduleOrder.html"><code>MainScheduleOrder</code></a>:
The sequence of <a href="/programming/schedules.html">schedules</a> that will run every frame update</li>
</ul>
<p>Settings that are not modifiable at runtime are not represented using resources. Instead,
they are configured via the respective <a href="builtins.html#plugins">plugins</a>.</p>
<h3 id="engine-resources"><a class="header" href="#engine-resources">Engine Resources</a></h3>
<p>These resources provide access to different features of the game engine at runtime.</p>
<p>Access them from your <a href="/programming/systems.html">systems</a>, if you need their state, or to control the respective
parts of Bevy. These resources are in the <a href="/gpu/intro.html">Main World</a>. <a href="builtins.html#render-world">See here for the
resources in the Render World</a>.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/time/struct.Time.html"><code>Time</code></a>:
Global time-related information (current frame delta time, time since startup, etc.)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/time/fixed_timestep/struct.FixedTime.html"><code>FixedTime</code></a>:
Tracks remaining time until the next <a href="/fundamentals/fixed-timestep.html">fixed update</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a>:
Control the asset system: Load assets, check load status, etc.</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/asset/struct.Assets.html"><code>Assets&lt;T&gt;</code></a>:
Contains the actual data of the loaded assets of a given type</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/schedule/struct.State.html"><code>State&lt;T&gt;</code></a>:
The current value of a <a href="/programming/states.html">states type</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/schedule/struct.NextState.html"><code>NextState&lt;T&gt;</code></a>:
Used to queue a transition to another <a href="/programming/states.html">state</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.Gamepads.html"><code>Gamepads</code></a>:
Tracks the IDs for all currently-detected (connected) gamepad devices</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/scene/struct.SceneSpawner.html"><code>SceneSpawner</code></a>:
Direct control over spawning Scenes into the main app World</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/core/struct.FrameCount.html"><code>FrameCount</code></a>:
The total number of frames</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/view/window/screenshot/struct.ScreenshotManager.html"><code>ScreenshotManager</code></a>:
Used to request a screenshot of a window to be taken/saved</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/ecs/reflect/struct.AppTypeRegistry.html"><code>AppTypeRegistry</code></a>:
Access to the Reflection Type Registry</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/tasks/struct.AsyncComputeTaskPool.html"><code>AsyncComputeTaskPool</code></a>:
Task pool for running background CPU tasks</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/tasks/struct.ComputeTaskPool.html"><code>ComputeTaskPool</code></a>:
Task pool where the main app schedule (all the systems) runs</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/tasks/struct.IoTaskPool.html"><code>IoTaskPool</code></a>:
Task pool where background i/o tasks run (like asset loading)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/winit/struct.WinitWindows.html"><code>WinitWindows</code></a> (<a href="/programming/non-send.html">non-send</a>):
Raw state of the <code>winit</code> backend for each window</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/view/struct.NonSendMarker.html"><code>NonSendMarker</code></a>:
Dummy resource to ensure a system always runs on the main thread</li>
</ul>
<h4 id="render-world-resources"><a class="header" href="#render-world-resources">Render World Resources</a></h4>
<p>These resources are present in the <a href="/gpu/intro.html">Render World</a>. They can be accessed
from rendering systems (that run during <a href="/gpu/stages.html">render stages</a>).</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/struct.MainWorld.html"><code>MainWorld</code></a>:
(extract schedule only!) access data from the Main World</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/render_graph/struct.RenderGraph.html"><code>RenderGraph</code></a>:
<a href="/TODO.html">The Bevy Render Graph</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/render_resource/struct.PipelineCache.html"><code>PipelineCache</code></a>:
Bevy's manager of render pipelines. Used to store render pipelines used by the app, to avoid
recreating them more than once.</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.TextureCache.html"><code>TextureCache</code></a>:
Bevy's manager of temporary textures. Useful when you need textures to use internally
during rendering.</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/render_phase/struct.DrawFunctions.html"><code>DrawFunctions&lt;P&gt;</code></a>:
Stores draw functions for a given phase item type</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/render_asset/struct.RenderAssets.html"><code>RenderAssets&lt;T&gt;</code></a>:
Contains handles to the GPU representations of currently loaded asset data</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.DefaultImageSampler.html"><code>DefaultImageSampler</code></a>:
The default sampler for <a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.Image.html"><code>Image</code></a> asset textures</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/texture/struct.FallbackImage.html"><code>FallbackImage</code></a>:
Dummy 1x1 pixel white texture. Useful for shaders that normally need a texture, when
you don't have one available.</li>
</ul>
<p>There are many other resources in the Render World, which are not mentioned
here, either because they are internal to Bevy's rendering algorithms, or
because they are just extracted copies of the equivalent resources in the Main
World.</p>
<h4 id="low-level-wgpu-resources"><a class="header" href="#low-level-wgpu-resources">Low-Level <code>wgpu</code> Resources</a></h4>
<p>Using these resources, you can have direct access to the <code>wgpu</code> APIs for controlling the GPU.
These are available in both the Main World and the Render World.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/renderer/struct.RenderDevice.html"><code>RenderDevice</code></a>:
The GPU device, used for creating hardware resources for rendering/compute</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/renderer/struct.RenderDevice.html"><code>RenderQueue</code></a>:
The GPU queue for submitting work to the hardware</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/renderer/struct.RenderAdapter.html"><code>RenderAdapter</code></a>:
Handle to the physical GPU hardware</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/render/renderer/struct.RenderAdapterInfo.html"><code>RenderAdapterInfo</code></a>:
Information about the GPU hardware that Bevy is running on</li>
</ul>
<h3 id="input-handling-resources"><a class="header" href="#input-handling-resources">Input Handling Resources</a></h3>
<p>These resources represent the current state of different input devices. Read them from your
<a href="/programming/systems.html">systems</a> to <a href="/input.html">handle user input</a>.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/keyboard/enum.KeyCode.html"><code>Input&lt;KeyCode&gt;</code></a>:
Keyboard key state, as a binary <a href="https://docs.rs/bevy/0.11.0/bevy/input/struct.Input.html">Input</a> value</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/mouse/enum.MouseButton.html"><code>Input&lt;MouseButton&gt;</code></a>:
Mouse button state, as a binary <a href="https://docs.rs/bevy/0.11.0/bevy/input/struct.Input.html">Input</a> value</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.GamepadButton.html"><code>Input&lt;GamepadButton&gt;</code></a>:
Gamepad buttons, as a binary <a href="https://docs.rs/bevy/0.11.0/bevy/input/struct.Input.html">Input</a> value</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.GamepadAxis.html"><code>Axis&lt;GamepadAxis&gt;</code></a>:
Analog <a href="https://docs.rs/bevy/0.11.0/bevy/input/struct.Axis.html">Axis</a> gamepad inputs (joysticks and triggers)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.GamepadButton.html"><code>Axis&lt;GamepadButton&gt;</code></a>:
Gamepad buttons, represented as an analog <a href="https://docs.rs/bevy/0.11.0/bevy/input/struct.Axis.html">Axis</a> value</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/touch/struct.Touches.html"><code>Touches</code></a>:
The state of all fingers currently touching the touchscreen</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.Gamepads.html"><code>Gamepads</code></a>:
Registry of all the connected <a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/struct.Gamepad.html"><code>Gamepad</code></a> IDs</li>
</ul>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p><a href="/programming/events.html">(more info about working with events)</a></p>
<h3 id="input-events"><a class="header" href="#input-events">Input Events</a></h3>
<p>These <a href="/programming/events.html">events</a> fire on activity with input devices. Read them to [handle user input][cb::input].</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/mouse/struct.MouseButtonInput.html"><code>MouseButtonInput</code></a>:
Changes in the state of mouse buttons</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/mouse/struct.MouseWheel.html"><code>MouseWheel</code></a>:
Scrolling by a number of pixels or lines (<a href="https://docs.rs/bevy/0.11.0/bevy/input/mouse/enum.MouseScrollUnit.html"><code>MouseScrollUnit</code></a>)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/mouse/struct.MouseMotion.html"><code>MouseMotion</code></a>:
Relative movement of the mouse (pixels from previous frame), regardless of the OS pointer/cursor</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.CursorMoved.html"><code>CursorMoved</code></a>:
New position of the OS mouse pointer/cursor</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/keyboard/struct.KeyboardInput.html"><code>KeyboardInput</code></a>:
Changes in the state of keyboard keys (keypresses, not text)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.ReceivedCharacter.html"><code>ReceivedCharacter</code></a>:
Unicode text input from the OS (correct handling of the user's language and layout)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/enum.Ime.html"><code>Ime</code></a>:
Unicode text input from IME (support for advanced text input in different scripts)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/touch/struct.TouchInput.html"><code>TouchInput</code></a>:
Change in the state of a finger touching the touchscreen</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/enum.GamepadEvent.html"><code>GamepadEvent</code></a>:
Changes in the state of a gamepad or any of its buttons or axes</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/gamepad/enum.GamepadRumbleRequest.html"><code>GamepadRumbleRequest</code></a>:
Send these events to control gamepad rumble</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/touchpad/struct.TouchpadMagnify.html"><code>TouchpadMagnify</code></a>:
Pinch-to-zoom gesture on laptop touchpad (macOS)</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/input/touchpad/struct.TouchpadRotate.html"><code>TouchpadRotate</code></a>:
Two-finger rotate gesture on laptop touchpad (macOS)</li>
</ul>
<h3 id="engine-events"><a class="header" href="#engine-events">Engine Events</a></h3>
<p><a href="/programming/events.html">Events</a> related to various internal things happening during the
normal runtime of a Bevy app.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/asset/enum.AssetEvent.html"><code>AssetEvent&lt;T&gt;</code></a>:
Sent by Bevy when <a href="/assets.html">asset data</a> has been added/modified/removed; <a href="/assets/assetevent.html">can be used to detect changes to assets</a></li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/hierarchy/enum.HierarchyEvent.html"><code>HierarchyEvent</code></a>:
Sent by Bevy when entity <a href="/fundamentals/hierarchy.html">parents/children</a> change</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/app/struct.AppExit.html"><code>AppExit</code></a>:
Tell Bevy to shut down</li>
</ul>
<h3 id="system-and-control-events"><a class="header" href="#system-and-control-events">System and Control Events</a></h3>
<p>Events from the OS / windowing system, or to control Bevy.</p>
<ul>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.RequestRedraw.html"><code>RequestRedraw</code></a>:
In an app that does not refresh continuously, request one more update before going to sleep</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/enum.FileDragAndDrop.html"><code>FileDragAndDrop</code></a>:
The user drag-and-dropped a file into our app</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.CursorEntered.html"><code>CursorEntered</code></a>:
OS mouse pointer/cursor entered one of our windows</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.CursorLeft.html"><code>CursorLeft</code></a>:
OS mouse pointer/cursor exited one of our windows</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowCloseRequested.html"><code>WindowCloseRequested</code></a>:
OS wants to close one of our windows</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowCreated.html"><code>WindowCreated</code></a>:
New application window opened</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowClosed.html"><code>WindowClosed</code></a>:
Bevy window closed</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowDestroyed.html"><code>WindowDestroyed</code></a>:
OS window freed/dropped after window close</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowFocused.html"><code>WindowFocused</code></a>:
One of our windows is now focused</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowMoved.html"><code>WindowMoved</code></a>:
OS/user moved one of our windows</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowResized.html"><code>WindowResized</code></a>:
OS/user resized one of our windows</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowScaleFactorChanged.html"><code>WindowScaleFactorChanged</code></a>:
One of our windows has changed its DPI scaling factor</li>
<li><a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.WindowBackendScaleFactorChanged.html"><code>WindowBackendScaleFactorChanged</code></a>:
OS reports change in DPI scaling factor for a window</li>
</ul>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p>The complete list of individual component types is too specific to be useful to list here.</p>
<p>See: <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/component/trait.Component.html#implementors">(List in API Docs)</a></p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="bevy-tutorials"><a class="header" href="#bevy-tutorials">Bevy Tutorials</a></h1>
<p>This chapter of the book contains tutorials. Tutorials teach you things in a
logical order from start to finish. If you are looking for something to guide
you through learning Bevy, maybe some of them will be useful to you.</p>
<p>The rest of this book is designed to be used as a reference, so you can jump
around to specific topics you want to learn about.</p>
<p>The first tutorial in this chapter, <a href="/tutorial/guide.html">Guided Tour</a>, simply
organizes all the topics in this book in an order suggested for learning, from
the basics to advanced concepts. You can use it as an alternative to the main
table of contents (the left side bar), if you are just learning Bevy and don't
know how to progress. If you are new to Bevy, you can start here to find your
way around.</p>
<p>If you would like more narrow-scoped examples that teach you how to solve
specific problems, those can be found in the <a href="/cookbook.html">Bevy Cookbook</a>
chapter.</p>
<p>You should also look at Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">official collection of
examples</a>. There is something for almost every area of the
engine, though they usually only show simple usage of the APIs without much
explanation.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="tutorial//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="new-to-bevy-guided-tutorial"><a class="header" href="#new-to-bevy-guided-tutorial">New to Bevy? Guided Tutorial!</a></h1>
<p>Welcome to Bevy! :) We are glad to have you in our community!</p>
<p>This page will guide you through this book, to help you gain comprehensive
knowledge of how to work with Bevy. The topics are structured in an order
that makes sense for learning: from basics to advanced.</p>
<p>It is just a suggestion to help you navigate. Feel free to jump around the book
and read whatever interests you. The main table-of-contents (the left sidebar)
was designed to be a reference for Bevy users of any skill level.</p>
<hr />
<p>Make sure to also look at <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">the official Bevy examples</a>. If
you need help, use <a href="https://github.com/bevyengine/bevy/discussions">GitHub Discussions</a>, or feel welcome
to join us to chat and ask for help in <a href="https://discord.gg/bevy">Discord</a>.</p>
<p>If you run into issues, be sure to check the
<a href="tutorial//pitfalls.html">Common Pitfalls</a> chapter, to see if this book has something
to help you. Solutions to some of the most common issues that Bevy community
members have encountered are documented there.</p>
<h2 id="basics"><a class="header" href="#basics">Basics</a></h2>
<p>These are the absolute essentials of using Bevy. Every Bevy project, even a
simple one, would require you to be familiar with these concepts.</p>
<p>You could conceivably make something like a simple game-jam game or prototype,
using just this knowledge. Though, as your project grows, you will likely
quickly need to learn more.</p>
<ul>
<li><a href="tutorial//setup.html">Bevy Setup Tips</a>
<ul>
<li><a href="tutorial//setup/getting-started.html">Getting Started</a></li>
</ul>
</li>
<li><a href="tutorial//programming.html">Bevy Programming Framework</a>
<ul>
<li><a href="tutorial//programming/ecs-intro.html">Intro to ECS</a></li>
<li><a href="tutorial//programming/intro-data.html#entities--components">Entities, Components</a></li>
<li><a href="tutorial//programming/bundle.html">Bundles</a></li>
<li><a href="tutorial//programming/res.html">Resources</a></li>
<li><a href="tutorial//programming/systems.html">Systems</a></li>
<li><a href="tutorial//programming/app-builder.html">App Builder</a></li>
<li><a href="tutorial//programming/queries.html">Queries</a></li>
<li><a href="tutorial//programming/commands.html">Commands</a></li>
</ul>
</li>
<li><a href="tutorial//fundamentals.html">Game Engine Fundamentals</a>
<ul>
<li><a href="tutorial//fundamentals/coords.html">Coordinate System</a></li>
<li><a href="tutorial//fundamentals/transforms.html">Transforms</a></li>
<li><a href="tutorial//fundamentals/time.html">Time and Timers</a></li>
</ul>
</li>
<li><a href="tutorial//graphics.html">General Graphics Features</a>
<ul>
<li><a href="tutorial//graphics/camera.html">Cameras</a></li>
</ul>
</li>
<li><a href="tutorial//assets.html">Bevy Asset Management</a>
<ul>
<li><a href="tutorial//assets/assetserver.html">Load Assets with AssetServer</a></li>
<li><a href="tutorial//assets/handles.html">Handles</a></li>
</ul>
</li>
<li><a href="tutorial//input.html">Input Handling</a>
<ul>
<li><a href="tutorial//input/keyboard.html">Keyboard</a></li>
<li><a href="tutorial//input/mouse.html">Mouse</a></li>
<li><a href="tutorial//input/gamepad.html">Gamepad (Controller)</a></li>
<li><a href="tutorial//input/touch.html">Touchscreen</a></li>
</ul>
</li>
<li><a href="tutorial//window.html">Window Management</a>
<ul>
<li><a href="tutorial//window/props.html">Window Properties</a></li>
<li><a href="tutorial//window/clear-color.html">Change the Background Color</a></li>
</ul>
</li>
<li><a href="tutorial//audio.html">Audio</a>
<ul>
<li><a href="tutorial//audio/basic.html">Playing Sounds</a></li>
</ul>
</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>You will likely need to learn most of these topics to make a non-trivial Bevy
project. After you are confident with the basics, you should learn these.</p>
<ul>
<li><a href="tutorial//programming.html">Bevy Programming Framework</a>
<ul>
<li><a href="tutorial//programming/events.html">Events</a></li>
<li><a href="tutorial//programming/system-order.html">System Order of Execution</a></li>
<li><a href="tutorial//programming/run-criteria.html">Run Conditions</a></li>
<li><a href="tutorial//programming/system-sets.html">System Sets</a></li>
<li><a href="tutorial//programming/local.html">Local Resources</a></li>
<li><a href="tutorial//programming/schedules.html">Schedules</a></li>
<li><a href="tutorial//programming/states.html">States</a></li>
<li><a href="tutorial//programming/plugins.html">Plugins</a></li>
<li><a href="tutorial//programming/change-detection.html">Change Detection</a></li>
</ul>
</li>
<li><a href="tutorial//fundamentals.html">Game Engine Fundamentals</a>
<ul>
<li><a href="tutorial//fundamentals/hierarchy.html">Parent/Child Hierarchies</a></li>
<li><a href="tutorial//fundamentals/visibility.html">Visibility</a></li>
<li><a href="tutorial//fundamentals/log.html">Logging / Console Messages</a></li>
</ul>
</li>
<li><a href="tutorial//input.html">Input Handling</a>
<ul>
<li><a href="tutorial//cookbook/cursor2world.html">Convert cursor to world coordinates</a></li>
</ul>
</li>
<li><a href="tutorial//assets.html">Bevy Asset Management</a>
<ul>
<li><a href="tutorial//assets/data.html">Access the Asset Data</a></li>
<li><a href="tutorial//assets/hot-reload.html">Hot-Reloading Assets</a></li>
</ul>
</li>
<li><a href="tutorial//setup.html">Bevy Setup Tips</a>
<ul>
<li><a href="tutorial//setup/bevy-tools.html">Bevy Dev Tools and Editors</a></li>
<li><a href="tutorial//setup/unofficial-plugins.html">Community Plugin Ecosystem</a></li>
</ul>
</li>
<li><a href="tutorial//audio.html">Audio</a>:
<ul>
<li><a href="tutorial//audio/spatial.html">Spatial Audio</a></li>
</ul>
</li>
</ul>
<h2 id="intermediate"><a class="header" href="#intermediate">Intermediate</a></h2>
<p>These are more specialized topics. You may need some of them, depending on your
project.</p>
<ul>
<li><a href="tutorial//programming.html">Bevy Programming Framework</a>
<ul>
<li><a href="tutorial//programming/world.html">Direct World Access</a></li>
<li><a href="tutorial//programming/exclusive.html">Exclusive Systems</a></li>
<li><a href="tutorial//programming/paramset.html">Param Sets</a></li>
<li><a href="tutorial//programming/system-piping.html">System Piping</a></li>
</ul>
</li>
<li><a href="tutorial//fundamentals.html">Game Engine Fundamentals</a>
<ul>
<li><a href="tutorial//fundamentals/fixed-timestep.html">Fixed Timestep</a></li>
</ul>
</li>
<li><a href="tutorial//graphics.html">General Graphics Features</a>
<ul>
<li><a href="tutorial//graphics/hdr-tonemap.html">HDR, Tonemapping</a></li>
<li><a href="tutorial//graphics/bloom.html">Bloom</a></li>
</ul>
</li>
<li><a href="tutorial//input.html">Input Handling</a>
<ul>
<li><a href="tutorial//input/char.html">Input Text</a></li>
<li><a href="tutorial//input/dnd.html">Drag-and-Drop files</a></li>
</ul>
</li>
<li><a href="tutorial//assets.html">Bevy Asset Management</a>
<ul>
<li><a href="tutorial//assets/assetevent.html">React to Changes with Asset Events</a></li>
<li><a href="tutorial//assets/ready.html">Track asset loading progress</a></li>
</ul>
</li>
<li><a href="tutorial//patterns.html">Programming Patterns</a>
<ul>
<li><a href="tutorial//patterns/system-tests.html">Write tests for systems</a></li>
<li><a href="tutorial//patterns/generic-systems.html">Generic Systems</a></li>
<li><a href="tutorial//patterns/manual-event-clear.html">Manual Event Clearing</a></li>
</ul>
</li>
<li><a href="tutorial//window.html">Window Management</a>
<ul>
<li><a href="tutorial//window/mouse-grab.html">Grab/Capture the Mouse Cursor</a></li>
<li><a href="tutorial//window/icon.html">Set the Window Icon</a></li>
</ul>
</li>
<li><a href="tutorial//audio.html">Audio</a>
<ul>
<li><a href="tutorial//audio/custom.html">Custom Audio Streams</a></li>
</ul>
</li>
</ul>
<h2 id="advanced"><a class="header" href="#advanced">Advanced</a></h2>
<p>These topics are for niche technical situations. You can learn them, if you want
to know more about how Bevy works internally, extend the engine with custom
functionality, or do other advanced things with Bevy.</p>
<ul>
<li><a href="tutorial//programming.html">Bevy Programming Framework</a>
<ul>
<li><a href="tutorial//programming/non-send.html">Non-Send</a></li>
</ul>
</li>
<li><a href="tutorial//patterns.html">Programming Patterns</a>
<ul>
<li><a href="tutorial//patterns/component-storage.html">Component Storage</a></li>
</ul>
</li>
<li><a href="tutorial//setup.html">Bevy Setup Tips</a>
<ul>
<li><a href="tutorial//setup/bevy-config.html">Customizing Bevy (cargo crates and features)</a></li>
<li><a href="tutorial//setup/bevy-git.html">Using bleeding-edge Bevy (main)</a></li>
</ul>
</li>
<li><a href="tutorial//gpu.html">Bevy Render (GPU) Framework</a>
<ul>
<li><a href="tutorial//gpu/intro.html">Render Architecture Overview</a></li>
<li><a href="tutorial//gpu/stages.html">Render Stages</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="bevy-cookbook"><a class="header" href="#bevy-cookbook">Bevy Cookbook</a></h1>
<p>This chapter shows you how to do various practical things using Bevy.</p>
<p>Every page is focused on a specific problem and provides explanations and
example code to teach you how to solve it.</p>
<p>It is assumed that you are already familiar with
<a href="/programming.html">Bevy Programming</a>.</p>
<p>You should also look at Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">official collection of
examples</a>. There is something for almost every area of the
engine, though they usually only show simple usage of the APIs without much
explanation.</p>
<p>If you would like step-by-step tutorials that you can follow from start to
finish, those are in the <a href="/tutorial.html">Bevy Tutorials</a> chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="cookbook//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="show-framerate"><a class="header" href="#show-framerate">Show Framerate</a></h1>
<p>You can use Bevy's builtin diagnostics to measure framerate (FPS), for
monitoring performance.</p>
<p>To enable it, add Bevy's diagnostic plugin to your <a href="cookbook//programming/app-builder.html">app</a>:</p>
<pre><code class="language-rust no_run noplayground">use bevy::diagnostic::FrameTimeDiagnosticsPlugin;
app.add_plugins(FrameTimeDiagnosticsPlugin::default());</code></pre>
<h2 id="print-to-console--log"><a class="header" href="#print-to-console--log">Print to Console / Log</a></h2>
<p>The simplest way to use it is to print the diagnostics to the console
(<a href="cookbook//fundamentals/log.html">log</a>). If you want to only do it in dev builds, you can add
a conditional-compilation attribute.</p>
<pre><code class="language-rust no_run noplayground">#[cfg(debug_assertions)] // debug/dev builds only
{
    use bevy::diagnostic::LogDiagnosticsPlugin;
    app.add_plugins(LogDiagnosticsPlugin::default());
}</code></pre>
<h2 id="in-game--on-screen-fps-counter"><a class="header" href="#in-game--on-screen-fps-counter">In-Game / On-Screen FPS counter</a></h2>
<p>You can use Bevy UI to create an in-game FPS counter.</p>
<p>It is recommended that you create a new UI root (entity without
a parent) with absolute positioning, so that you can control the
exact position where the FPS counter appears, and so it doesn't
affect the rest of your UI.</p>
<p>Here is some example code showing you how to make a very nice-looking and
readable FPS counter:</p>
<details>
  <summary>
  <code>Code Example (Long):</code>
  </summary>
<pre><code class="language-rust no_run noplayground">use bevy::diagnostic::DiagnosticsStore;
use bevy::diagnostic::FrameTimeDiagnosticsPlugin;

/// Marker to find the container entity so we can show/hide the FPS counter
#[derive(Component)]
struct FpsRoot;

/// Marker to find the text entity so we can update it
#[derive(Component)]
struct FpsText;

fn setup_fps_counter(
    mut commands: Commands,
) {
    // create our UI root node
    // this is the wrapper/container for the text
    let root = commands.spawn((
        FpsRoot,
        NodeBundle {
            // give it a dark background for readability
            background_color: BackgroundColor(Color::BLACK.with_a(0.5)),
            // make it &quot;always on top&quot; by setting the Z index to maximum
            // we want it to be displayed over all other UI
            z_index: ZIndex::Global(i32::MAX),
            style: Style {
                position_type: PositionType::Absolute,
                // position it at the top-right corner
                // 1% away from the top window edge
                right: Val::Percent(1.),
                top: Val::Percent(1.),
                // set bottom/left to Auto, so it can be
                // automatically sized depending on the text
                bottom: Val::Auto,
                left: Val::Auto,
                // give it some padding for readability
                padding: UiRect::all(Val::Px(4.0)),
                ..Default::default()
            },
            ..Default::default()
        },
    )).id();
    // create our text
    let text_fps = commands.spawn((
        FpsText,
        TextBundle {
            // use two sections, so it is easy to update just the number
            text: Text::from_sections([
                TextSection {
                    value: &quot;FPS: &quot;.into(),
                    style: TextStyle {
                        font_size: 16.0,
                        color: Color::WHITE,
                        // if you want to use your game's font asset,
                        // uncomment this and provide the handle:
                        // font: my_font_handle
                        ..default()
                    }
                },
                TextSection {
                    value: &quot; N/A&quot;.into(),
                    style: TextStyle {
                        font_size: 16.0,
                        color: Color::WHITE,
                        // if you want to use your game's font asset,
                        // uncomment this and provide the handle:
                        // font: my_font_handle
                        ..default()
                    }
                },
            ]),
            ..Default::default()
        },
    )).id();
    commands.entity(root).push_children(&amp;[text_fps]);
}

fn fps_text_update_system(
    diagnostics: Res&lt;DiagnosticsStore&gt;,
    mut query: Query&lt;&amp;mut Text, With&lt;FpsText&gt;&gt;,
) {
    for mut text in &amp;mut query {
        // try to get a &quot;smoothed&quot; FPS value from Bevy
        if let Some(value) = diagnostics
            .get(FrameTimeDiagnosticsPlugin::FPS)
            .and_then(|fps| fps.smoothed())
        {
            // Format the number as to leave space for 4 digits, just in case,
            // right-aligned and rounded. This helps readability when the
            // number changes rapidly.
            text.sections[1].value = format!(&quot;{value:&gt;4.0}&quot;);

            // Let's make it extra fancy by changing the color of the
            // text according to the FPS value:
            text.sections[1].style.color = if value &gt;= 120.0 {
                // Above 120 FPS, use green color
                Color::rgb(0.0, 1.0, 0.0)
            } else if value &gt;= 60.0 {
                // Between 60-120 FPS, gradually transition from yellow to green
                Color::rgb(
                    (1.0 - (value - 60.0) / (120.0 - 60.0)) as f32,
                    1.0,
                    0.0,
                )
            } else if value &gt;= 30.0 {
                // Between 30-60 FPS, gradually transition from red to yellow
                Color::rgb(
                    1.0,
                    ((value - 30.0) / (60.0 - 30.0)) as f32,
                    0.0,
                )
            } else {
                // Below 30 FPS, use red color
                Color::rgb(1.0, 0.0, 0.0)
            }
        } else {
            // display &quot;N/A&quot; if we can't get a FPS measurement
            // add an extra space to preserve alignment
            text.sections[1].value = &quot; N/A&quot;.into();
            text.sections[1].style.color = Color::WHITE;
        }
    }
}

/// Toggle the FPS counter when pressing F12
fn fps_counter_showhide(
    mut q: Query&lt;&amp;mut Visibility, With&lt;FpsRoot&gt;&gt;,
    kbd: Res&lt;Input&lt;KeyCode&gt;&gt;,
) {
    if kbd.just_pressed(KeyCode::F12) {
        let mut vis = q.single_mut();
        *vis = match *vis {
            Visibility::Hidden =&gt; Visibility::Visible,
            _ =&gt; Visibility::Hidden,
        };
    }
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.add_systems(Startup, setup_fps_counter);
app.add_systems(Update, (
    fps_text_update_system,
    fps_counter_showhide,
));</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="cookbook//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="convert-cursor-to-world-coordinates"><a class="header" href="#convert-cursor-to-world-coordinates">Convert cursor to world coordinates</a></h1>
<h2 id="2d-games"><a class="header" href="#2d-games">2D games</a></h2>
<p>If you only have one window (the primary window), as is the case for most apps
and games, you can do this:</p>
<details>
  <summary>
  <code>Code (simple version):</code>
  </summary>
<pre><code class="language-rust no_run noplayground">use bevy::window::PrimaryWindow;

/// We will store the world position of the mouse cursor here.
#[derive(Resource, Default)]
struct MyWorldCoords(Vec2);

/// Used to help identify our main camera
#[derive(Component)]
struct MainCamera;

fn setup(mut commands: Commands) {
    // Make sure to add the marker component when you set up your camera
    commands.spawn((Camera2dBundle::default(), MainCamera));
}

fn my_cursor_system(
    mut mycoords: ResMut&lt;MyWorldCoords&gt;,
    // query to get the window (so we can read the current cursor position)
    q_window: Query&lt;&amp;Window, With&lt;PrimaryWindow&gt;&gt;,
    // query to get camera transform
    q_camera: Query&lt;(&amp;Camera, &amp;GlobalTransform), With&lt;MainCamera&gt;&gt;,
) {
    // get the camera info and transform
    // assuming there is exactly one main camera entity, so Query::single() is OK
    let (camera, camera_transform) = q_camera.single();

    // There is only one primary window, so we can similarly get it from the query:
    let window = q_window.single();

    // check if the cursor is inside the window and get its position
    // then, ask bevy to convert into world coordinates, and truncate to discard Z
    if let Some(world_position) = window.cursor_position()
        .and_then(|cursor| camera.viewport_to_world(camera_transform, cursor))
        .map(|ray| ray.origin.truncate())
    {
        mycoords.0 = world_position;
        eprintln!(&quot;World coords: {}/{}&quot;, world_position.x, world_position.y);
    }
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.init_resource::&lt;MyWorldCoords&gt;();
app.add_systems(Startup, setup);
app.add_systems(Update, my_cursor_system);</code></pre>
</details>
<p>If you have a more complex application with multiple windows, here is a more
complex version of the code that can handle that:</p>
<details>
  <summary>
  <code>Code (multi-window version):</code>
  </summary>
<pre><code class="language-rust no_run noplayground">use bevy::render::camera::RenderTarget;
use bevy::window::WindowRef;

/// We will add this to each camera we want to compute cursor position for.
/// Add the component to the camera that renders to each window.
#[derive(Component, Default)]
struct WorldCursorCoords(Vec2);

fn setup_multiwindow(mut commands: Commands) {
    // TODO: set up multiple cameras for multiple windows.
    // See bevy's example code for how to do that.

    // Make sure we add our component to each camera
    commands.spawn((Camera2dBundle::default(), WorldCursorCoords::default()));
}

fn my_cursor_system_multiwindow(
    // query to get the primary window
    q_window_primary: Query&lt;&amp;Window, With&lt;PrimaryWindow&gt;&gt;,
    // query to get other windows
    q_window: Query&lt;&amp;Window&gt;,
    // query to get camera transform
    mut q_camera: Query&lt;(&amp;Camera, &amp;GlobalTransform, &amp;mut WorldCursorCoords)&gt;,
) {
    for (camera, camera_transform, mut worldcursor) in &amp;mut q_camera {
        // get the window the camera is rendering to
        let window = match camera.target {
            // the camera is rendering to the primary window
            RenderTarget::Window(WindowRef::Primary) =&gt; {
                q_window_primary.single()
            },
            // the camera is rendering to some other window
            RenderTarget::Window(WindowRef::Entity(e_window)) =&gt; {
                q_window.get(e_window).unwrap()
            },
            // the camera is rendering to something else (like a texture), not a window
            _ =&gt; {
                // skip this camera
                continue;
            }
        };

        // check if the cursor is inside the window and get its position
        // then, ask bevy to convert into world coordinates, and truncate to discard Z
        if let Some(world_position) = window.cursor_position()
            .and_then(|cursor| camera.viewport_to_world(camera_transform, cursor))
            .map(|ray| ray.origin.truncate())
        {
            worldcursor.0 = world_position;
        }
    }
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.add_systems(Startup, setup_multiwindow);
app.add_systems(Update, my_cursor_system_multiwindow);</code></pre>
</details>
<h2 id="3d-games"><a class="header" href="#3d-games">3D games</a></h2>
<p>If you'd like to be able to detect what 3D object the cursor is pointing at, select
objects, etc., there is a good (unofficial) plugin:
<a href="https://github.com/aevyrie/bevy_mod_picking"><code>bevy_mod_picking</code></a>.</p>
<p>For a simple top-down camera view game with a flat ground plane, it might be
sufficient to just compute the coordinates on the ground under the cursor.</p>
<p><button class="button_wasm_cbexample" id="button_cursor_3d_ground_plane">Load Interactive Example</button></p>
<p>In the interactive example, there is a ground plane with a non-default position
and rotation. There is a red cube, which is positioned using the global
coordinates, and a blue cube, which is a <a href="cookbook//fundamentals/hierarchy.html">child entity</a> of the
ground plane and positioned using local coordinates. They should both follow the
cursor.</p>
<details>
  <summary>
  <code>Code and explanation:</code>
  </summary>
<pre><code class="language-rust no_run noplayground">/// Here we will store the position of the mouse cursor on the 3D ground plane.
#[derive(Resource, Default)]
struct MyGroundCoords {
    // Global (world-space) coordinates
    global: Vec3,
    // Local (relative to the ground plane) coordinates
    local: Vec2,
}

/// Used to help identify our main camera
#[derive(Component)]
struct MyGameCamera;

/// Used to help identify our ground plane
#[derive(Component)]
struct MyGroundPlane;

fn setup_3d_scene(mut commands: Commands) {
    // Make sure to add the marker component when you set up your camera
    commands.spawn((
        MyGameCamera,
        Camera3dBundle {
            // ... your camera configuration ...
            ..default()
        },
    ));
    // Spawn the ground
    commands.spawn((
        MyGroundPlane,
        PbrBundle {
            // feel free to change this to rotate/tilt or reposition the ground
            transform: Transform::default(),
            // TODO: set up your mesh / visuals for rendering:
            // mesh: ...
            // material: ...
            ..default()
        },
    ));
}

fn cursor_to_ground_plane(
    mut mycoords: ResMut&lt;MyGroundCoords&gt;,
    // query to get the window (so we can read the current cursor position)
    // (we will only work with the primary window)
    q_window: Query&lt;&amp;Window, With&lt;PrimaryWindow&gt;&gt;,
    // query to get camera transform
    q_camera: Query&lt;(&amp;Camera, &amp;GlobalTransform), With&lt;MyGameCamera&gt;&gt;,
    // query to get ground plane's transform
    q_plane: Query&lt;&amp;GlobalTransform, With&lt;MyGroundPlane&gt;&gt;,
) {
    // get the camera info and transform
    // assuming there is exactly one main camera entity, so Query::single() is OK
    let (camera, camera_transform) = q_camera.single();

    // Ditto for the ground plane's transform
    let ground_transform = q_plane.single();

    // There is only one primary window, so we can similarly get it from the query:
    let window = q_window.single();

    // check if the cursor is inside the window and get its position
    let Some(cursor_position) = window.cursor_position() else {
        // if the cursor is not inside the window, we can't do anything
        return;
    };

    // Mathematically, we can represent the ground as an infinite flat plane.
    // To do that, we need a point (to position the plane) and a normal vector
    // (the &quot;up&quot; direction, perpendicular to the ground plane).

    // We can get the correct values from the ground entity's GlobalTransform
    let plane_origin = ground_transform.translation();
    let plane_normal = ground_transform.up();

    // Ask Bevy to give us a ray pointing from the viewport (screen) into the world
    let Some(ray) = camera.viewport_to_world(camera_transform, cursor_position) else {
        // if it was impossible to compute for whatever reason; we can't do anything
        return;
    };

    // do a ray-plane intersection test, giving us the distance to the ground
    let Some(distance) = ray.intersect_plane(plane_origin, plane_normal) else {
        // If the ray does not intersect the ground
        // (the camera is not looking towards the ground), we can't do anything
        return;
    };

    // use the distance to compute the actual point on the ground in world-space
    let global_cursor = ray.get_point(distance);

    mycoords.global = global_cursor;
    eprintln!(&quot;Global cursor coords: {}/{}/{}&quot;,
        global_cursor.x, global_cursor.y, global_cursor.z
    );

    // to compute the local coordinates, we need the inverse of the plane's transform
    let inverse_transform_matrix = ground_transform.compute_matrix().inverse();
    let local_cursor = inverse_transform_matrix.transform_point3(global_cursor);

    // we can discard the Y coordinate, because it should always be zero
    // (our point is supposed to be on the plane)
    mycoords.local = local_cursor.xz();
    eprintln!(&quot;Local cursor coords: {}/{}&quot;, local_cursor.x, local_cursor.z);
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.init_resource::&lt;MyGroundCoords&gt;();
app.add_systems(Startup, setup_3d_scene);
app.add_systems(Update, cursor_to_ground_plane);</code></pre>
<p>If the ground is tilted/rotated or moved, the global and local coordinates
will differ, and may be useful for different use cases, so we compute both.</p>
<p>For some examples:</p>
<ul>
<li>if you want to spawn a <a href="cookbook//fundamentals/hierarchy.html">child</a> entity, or to quantize
the coordinates to a grid (for a tile-based game, to detect the grid tile under the cursor),
the local coordinates will be more useful</li>
<li>if you want to spawn some overlays, particle effects, other independent game entities,
at the position of the cursor, the global coordinates will be more useful</li>
</ul>
</details>
<script type="module" src="/loadwasm.js"/>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="cookbook//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="custom-camera-projection"><a class="header" href="#custom-camera-projection">Custom Camera Projection</a></h1>
<p><strong>Note</strong>: this example is showing you how to do something not officially
supported/endorsed by Bevy. Do at your own risk.</p>
<p>Camera with a custom projection (not using one of Bevy's standard perspective
or orthographic projections).</p>
<p>You could also use this to change the coordinate system, if you insist on
using something other than <a href="cookbook//fundamentals/coords.html">Bevy's default coordinate system</a>,
for whatever reason.</p>
<p>Here we implement a simple orthographic projection that maps <code>-1.0</code> to <code>1.0</code>
to the vertical axis of the window, and respects the window's aspect ratio
for the horizontal axis:</p>
<p>See how Bevy constructs its camera bundles, for reference:</p>
<ul>
<li><a href="https://github.com/bevyengine/bevy/blob/v0.9.0/crates/bevy_core_pipeline/src/core_2d/camera_2d.rs#L46">2d</a></li>
<li><a href="https://github.com/bevyengine/bevy/blob/v0.9.0/crates/bevy_core_pipeline/src/core_3d/camera_3d.rs#L72">3d</a></li>
</ul>
<p>This example is based on the setup for a 2D camera:</p>
<pre><code class="language-rust no_run noplayground">use bevy::core_pipeline::tonemapping::Tonemapping;
use bevy::render::primitives::Frustum;
use bevy::render::camera::{Camera, CameraProjection};
use bevy::render::view::VisibleEntities;

#[derive(Component, Debug, Clone, Reflect)]
#[reflect(Component, Default)]
struct SimpleOrthoProjection {
    near: f32,
    far: f32,
    aspect: f32,
}

impl CameraProjection for SimpleOrthoProjection {
    fn get_projection_matrix(&amp;self) -&gt; Mat4 {
        Mat4::orthographic_rh(
            -self.aspect, self.aspect, -1.0, 1.0, self.near, self.far
        )
    }

    // what to do on window resize
    fn update(&amp;mut self, width: f32, height: f32) {
        self.aspect = width / height;
    }

    fn far(&amp;self) -&gt; f32 {
        self.far
    }
}

impl Default for SimpleOrthoProjection {
    fn default() -&gt; Self {
        Self { near: 0.0, far: 1000.0, aspect: 1.0 }
    }
}

fn setup(mut commands: Commands) {
    // We need all the components that Bevy's built-in camera bundles would add
    // Refer to the Bevy source code to make sure you do it correctly:

    // here we show a 2d example

    let projection = SimpleOrthoProjection::default();

    // position the camera like bevy would do by default for 2D:
    let transform = Transform::from_xyz(0.0, 0.0, projection.far - 0.1);

    // frustum construction code copied from Bevy
    let view_projection =
        projection.get_projection_matrix() * transform.compute_matrix().inverse();
    let frustum = Frustum::from_view_projection(
        &amp;view_projection,
        &amp;transform.translation,
        &amp;transform.back(),
        projection.far,
    );

    commands.spawn((
        bevy::render::camera::CameraRenderGraph::new(bevy::core_pipeline::core_2d::graph::NAME),
        projection,
        frustum,
        transform,
        GlobalTransform::default(),
        VisibleEntities::default(),
        Camera::default(),
        Camera2d::default(),
        Tonemapping::Disabled,
    ));
}

fn main() {
    // need to add bevy-internal camera projection management functionality
    // for our custom projection type
    use bevy::render::camera::CameraProjectionPlugin;

    App::new()
        .add_plugins(DefaultPlugins)
        .add_startup_system(setup)
        .add_plugin(CameraProjectionPlugin::&lt;SimpleOrthoProjection&gt;::default())
        .run();
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="cookbook//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="pan--orbit-camera"><a class="header" href="#pan--orbit-camera">Pan + Orbit Camera</a></h1>
<p>This code is a community contribution.</p>
<p>Current version developed by <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/pull/1"><strong>@mirenbharta</strong></a>.
Initial work by <a href="https://github.com/bevy-cheatbook/bevy-cookbook/pull/2"><strong>@skairunner</strong></a>.</p>
<hr />
<p>This is a camera controller similar to the ones in 3D editors like Blender.</p>
<p>Use the right mouse button to rotate, middle button to pan, scroll wheel to
move inwards/outwards.</p>
<p>This is largely shown for illustrative purposes, as an example
to learn from. In your projects, you may want to try the
[<code>bevy_config_cam</code>][project::bevy_config_cam] plugin.</p>
<pre><code class="language-rust no_run noplayground">/// Tags an entity as capable of panning and orbiting.
#[derive(Component)]
struct PanOrbitCamera {
    /// The &quot;focus point&quot; to orbit around. It is automatically updated when panning the camera
    pub focus: Vec3,
    pub radius: f32,
    pub upside_down: bool,
}

impl Default for PanOrbitCamera {
    fn default() -&gt; Self {
        PanOrbitCamera {
            focus: Vec3::ZERO,
            radius: 5.0,
            upside_down: false,
        }
    }
}

/// Pan the camera with middle mouse click, zoom with scroll wheel, orbit with right mouse click.
fn pan_orbit_camera(
    windows: Res&lt;Windows&gt;,
    mut ev_motion: EventReader&lt;MouseMotion&gt;,
    mut ev_scroll: EventReader&lt;MouseWheel&gt;,
    input_mouse: Res&lt;Input&lt;MouseButton&gt;&gt;,
    mut query: Query&lt;(&amp;mut PanOrbitCamera, &amp;mut Transform, &amp;Projection)&gt;,
) {
    // change input mapping for orbit and panning here
    let orbit_button = MouseButton::Right;
    let pan_button = MouseButton::Middle;

    let mut pan = Vec2::ZERO;
    let mut rotation_move = Vec2::ZERO;
    let mut scroll = 0.0;
    let mut orbit_button_changed = false;

    if input_mouse.pressed(orbit_button) {
        for ev in ev_motion.iter() {
            rotation_move += ev.delta;
        }
    } else if input_mouse.pressed(pan_button) {
        // Pan only if we're not rotating at the moment
        for ev in ev_motion.iter() {
            pan += ev.delta;
        }
    }
    for ev in ev_scroll.iter() {
        scroll += ev.y;
    }
    if input_mouse.just_released(orbit_button) || input_mouse.just_pressed(orbit_button) {
        orbit_button_changed = true;
    }

    for (mut pan_orbit, mut transform, projection) in query.iter_mut() {
        if orbit_button_changed {
            // only check for upside down when orbiting started or ended this frame
            // if the camera is &quot;upside&quot; down, panning horizontally would be inverted, so invert the input to make it correct
            let up = transform.rotation * Vec3::Y;
            pan_orbit.upside_down = up.y &lt;= 0.0;
        }

        let mut any = false;
        if rotation_move.length_squared() &gt; 0.0 {
            any = true;
            let window = get_primary_window_size(&amp;windows);
            let delta_x = {
                let delta = rotation_move.x / window.x * std::f32::consts::PI * 2.0;
                if pan_orbit.upside_down { -delta } else { delta }
            };
            let delta_y = rotation_move.y / window.y * std::f32::consts::PI;
            let yaw = Quat::from_rotation_y(-delta_x);
            let pitch = Quat::from_rotation_x(-delta_y);
            transform.rotation = yaw * transform.rotation; // rotate around global y axis
            transform.rotation = transform.rotation * pitch; // rotate around local x axis
        } else if pan.length_squared() &gt; 0.0 {
            any = true;
            // make panning distance independent of resolution and FOV,
            let window = get_primary_window_size(&amp;windows);
            if let Projection::Perspective(projection) = projection {
                pan *= Vec2::new(projection.fov * projection.aspect_ratio, projection.fov) / window;
            }
            // translate by local axes
            let right = transform.rotation * Vec3::X * -pan.x;
            let up = transform.rotation * Vec3::Y * pan.y;
            // make panning proportional to distance away from focus point
            let translation = (right + up) * pan_orbit.radius;
            pan_orbit.focus += translation;
        } else if scroll.abs() &gt; 0.0 {
            any = true;
            pan_orbit.radius -= scroll * pan_orbit.radius * 0.2;
            // dont allow zoom to reach zero or you get stuck
            pan_orbit.radius = f32::max(pan_orbit.radius, 0.05);
        }

        if any {
            // emulating parent/child to make the yaw/y-axis rotation behave like a turntable
            // parent = x and y rotation
            // child = z-offset
            let rot_matrix = Mat3::from_quat(transform.rotation);
            transform.translation = pan_orbit.focus + rot_matrix.mul_vec3(Vec3::new(0.0, 0.0, pan_orbit.radius));
        }
    }

    // consume any remaining events, so they don't pile up if we don't need them
    // (and also to avoid Bevy warning us about not checking events every frame update)
    ev_motion.clear();
}

fn get_primary_window_size(windows: &amp;Res&lt;Windows&gt;) -&gt; Vec2 {
    let window = windows.get_primary().unwrap();
    let window = Vec2::new(window.width() as f32, window.height() as f32);
    window
}

/// Spawn a camera like this
fn spawn_camera(mut commands: Commands) {
    let translation = Vec3::new(-2.0, 2.5, 5.0);
    let radius = translation.length();

    commands.spawn((
        Camera3dBundle {
            transform: Transform::from_translation(translation)
                .looking_at(Vec3::ZERO, Vec3::Y),
            ..Default::default()
        },
        PanOrbitCamera {
            radius,
            ..Default::default()
        },
    ));
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="cookbook//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="list-all-resource-types"><a class="header" href="#list-all-resource-types">List All Resource Types</a></h1>
<p>This example shows how to print a list of all types that have been added as
<a href="cookbook//programming/res.html">resources</a>.</p>
<pre><code class="language-rust no_run noplayground">fn print_resources(world: &amp;World) {
    let components = world.components();

    let mut r: Vec&lt;_&gt; = world
        .storages()
        .resources
        .iter()
        .map(|(id, _)| components.get_info(id).unwrap())
        .map(|info| info.name())
        .collect();

    // sort list alphebetically
    r.sort();
    r.iter().for_each(|name| println!(&quot;{}&quot;, name));
}</code></pre>
<pre><code class="language-rust no_run noplayground">// print main world resources
app.add_systems(Last, print_resources);

// print render world resources
app.sub_app_mut(RenderApp)
    .add_systems(Render, print_resources.in_set(RenderSet::Render));</code></pre>
<p>It lists the types of all the resources <em>that currently exist</em> in your <a href="cookbook//programming/intro-data.html">ECS
World</a> (by all registered plugins, your own, etc.).</p>
<p>Note that this does <em>not</em> give you a list of every type that is
useful as a resource. For that, you should consult API documentation,
looking for implementers of the <a href="https://docs.rs/bevy/0.12.0/bevy/ecs/system/trait.Resource.html"><code>Resource</code></a> trait.</p>
<p><a href="cookbook//builtins.html">See here for a summary of types provided in Bevy.</a></p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="bevy-setup-tips"><a class="header" href="#bevy-setup-tips">Bevy Setup Tips</a></h1>
<p>This chapter is a collection of additional tips for configuring
your project or development tools, collected from the Bevy
community, beyond what is covered in Bevy's <a href="https://bevyengine.org/learn/book/getting-started/setup/">official setup
documentation</a>.</p>
<p>Feel free to suggest things to add under this chapter.</p>
<hr />
<p>Also see the following other relevant content from this book:</p>
<ul>
<li><a href="/platforms.html">Platform-specific information</a></li>
<li><a href="/pitfalls/performance.html">Configuration to fix slow performance</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This page covers the basic setup needed for Bevy development.</p>
<hr />
<p>For the most part, Bevy is just like any other Rust library. You need to
install Rust and setup your dev environment just like for any other Rust
project. You can install Rust using <a href="https://rustup.rs">Rustup</a>. See
<a href="https://www.rust-lang.org/learn/get-started">Rust's official setup page</a>.</p>
<p>On Linux, you need the development files for some system libraries. See the
<a href="https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md">official Bevy Linux dependencies page</a>.</p>
<p>Also see the <a href="https://bevyengine.org/learn/book/getting-started/setup/">Setup page in the official Bevy Book</a>
and the <a href="https://github.com/bevyengine/bevy/blob/main/README.md">official Bevy Readme</a>.</p>
<h2 id="creating-a-new-project"><a class="header" href="#creating-a-new-project">Creating a New Project</a></h2>
<p>You can simply create a new Rust project, either from your IDE/editor, or the commandline:</p>
<pre><code class="language-sh">cargo new --bin my_game
</code></pre>
<p>(creates a project called <code>my_game</code>)</p>
<p>The <code>Cargo.toml</code> file contains all the configuration of your project.
Add the latest version of <code>bevy</code> as a dependency. Your file should now
look something like this:</p>
<pre><code class="language-toml">[package]
name = &quot;my_game&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
bevy = &quot;0.12&quot;
</code></pre>
<p>The <code>src/main.rs</code> file is your main source code file. This is where you
start writing your Rust code. For a minimal Bevy <a href="setup//programming/app-builder.html">app</a>, you need
at least the following:</p>
<pre><code class="language-rust no_run noplayground">use bevy::prelude::*;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .run();
}</code></pre>
<p>You can now compile and run your project. The first time, this will take a
while, as it needs to build the whole Bevy engine and dependencies. Subsequent
runs should be fast. You can do this from your IDE/editor, or the commandline:</p>
<pre><code class="language-sh">cargo run
</code></pre>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>You can generate your own docs (like what is on <a href="https://docs.rs">docs.rs</a>), for
offline use, including everything from your own project and all dependencies, in
one place.</p>
<pre><code class="language-sh">cargo doc --open
</code></pre>
<p>This will build all the HTML docs and open them in your web browser.</p>
<p>It does not require an internet connection, and gives you an easy way to search
the API docs for all crates in your dependency tree all at once. It is more
useful than the online version of the docs.</p>
<h2 id="optional-extra-setup"><a class="header" href="#optional-extra-setup">Optional Extra Setup</a></h2>
<p>You will likely quickly run into unusably slow performance with the default
Rust unoptimized dev builds. <a href="setup//pitfalls/performance.html">See here how to fix.</a></p>
<p>Iterative recompilation speed is important to keep you productive, so you don't
have to wait long for the Rust compiler to rebuild your project every time you
want to test your game. <a href="https://bevyengine.org/learn/book/getting-started/setup/">Bevy's getting started page</a>
has advice about how to speed up compile times.</p>
<p>Also have a look in the <a href="setup//setup/bevy-tools.html">Dev Tools and Editors</a> page for suggestions
about additional external dev tools that may be helpful.</p>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h2>
<p>Have a look at the <a href="setup//tutorial.html">guided tutorial</a> page of this book,
and Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">official examples</a>.</p>
<p>Check out the <a href="https://docs.rs/bevy/0.12.0/bevy/asset/struct.Assets.html">Bevy Assets Website</a> to find other tutorials
and learning resources from the community, and <a href="setup//setup/unofficial-plugins.html">plugins</a>
to use in your project.</p>
<p>Join the community on <a href="https://discord.gg/bevy">Discord</a> to chat with us!</p>
<h2 id="running-into-issues"><a class="header" href="#running-into-issues">Running into Issues?</a></h2>
<p>If something is not working, be sure to check the <a href="setup//pitfalls.html">Common
Pitfalls</a> chapter, to see if this book has something to
help you. Solutions to some of the most common issues that Bevy community
members have encountered are documented there.</p>
<p>If you need help, use <a href="https://github.com/bevyengine/bevy/discussions">GitHub Discussions</a>, or feel
welcome to come chat and ask for help in <a href="https://discord.gg/bevy">Discord</a>.</p>
<h2 id="gpu-drivers"><a class="header" href="#gpu-drivers">GPU Drivers</a></h2>
<p>To work at its best, Bevy needs DirectX 12 (Windows) or Vulkan (Linux, Android,
Windows). macOS/iOS should just work, without any special driver setup, using
Metal.</p>
<p>OpenGL (GLES3) can be used as a fallback, but will likely have issues (some
bugs, unsupported features, worse performance).</p>
<p>Make sure you have compatible hardware and drivers installed on your system.
Your users will also need to satisfy this requirement.</p>
<p>If Bevy is not working, install the latest drivers for your OS, or check with
your Linux distribution whether Vulkan needs additional packages to be
installed.</p>
<p>Web games are supported and should work in any modern browser, using WebGL2.
Performance is limited and some Bevy features will not work. The new
experimental high-performance WebGPU API is also supported, but browser adoption
is still limited.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="text-editor--ide"><a class="header" href="#text-editor--ide">Text Editor / IDE</a></h1>
<p>This sub-chapter contains tips for different text editors and IDEs.</p>
<p>Bevy is, for the most part, like any other Rust project. If your editor/IDE
is set up for Rust, that might be all you need. This sub-chapter contains
additional information that may be useful for Bevy specifically.</p>
<p>If you have any tips/advice/configurations for your editor of choice,
that you'd like to share with the community, please create a
<a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub Issue</a>, so we can add it to the book.
If your editor is not in the list, I will add it.</p>
<ul>
<li><a href="setup//setup/editor/vscode.html">Visual Studio Code</a></li>
<li><a href="setup//setup/editor/jetbrains.html">JetBrains (RustRover, IntelliJ, CLion)</a></li>
<li><a href="setup//setup/editor/kak.html">Kakoune</a></li>
<li><a href="setup//setup/editor/vim.html">Vim</a></li>
<li><a href="setup//setup/editor/emacs.html">Emacs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/editor//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h1>
<p>If you are a VSCode user and you'd like something to be added to this page,
please file a <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub Issue</a>.</p>
<h2 id="rust-language-support"><a class="header" href="#rust-language-support">Rust Language Support</a></h2>
<p>For good Rust support, install the Rust Analyzer plugin.</p>
<h3 id="speed-up-rust-analyzer"><a class="header" href="#speed-up-rust-analyzer">Speed Up Rust Analyzer</a></h3>
<p>If you have used <code>.cargo/config.toml</code> to set a non-default linker for fast
compiles, Rust Analyzer will ignore it unfortunately. You need to also
configure RA to use it, with the following setting (in VSCode <code>settings.json</code>):</p>
<p>Windows:</p>
<pre><code class="language-json">&quot;rust-analyzer.cargo.extraEnv&quot;: {
    &quot;RUSTFLAGS&quot;: &quot;-Clinker=rust-lld.exe&quot;
}
</code></pre>
<p>Linux (mold):</p>
<pre><code class="language-json">&quot;rust-analyzer.cargo.extraEnv&quot;: {
    &quot;RUSTFLAGS&quot;: &quot;-Clinker=clang -Clink-arg=-fuse-ld=mold&quot;
}
</code></pre>
<p>Linux (lld):</p>
<pre><code class="language-json">&quot;rust-analyzer.cargo.extraEnv&quot;: {
    &quot;RUSTFLAGS&quot;: &quot;-Clinker=clang -Clink-arg=-fuse-ld=lld&quot;
}
</code></pre>
<h2 id="cargo_manifest_dir"><a class="header" href="#cargo_manifest_dir"><code>CARGO_MANIFEST_DIR</code></a></h2>
<p>When running your app/game, Bevy will search for the <code>assets</code> folder in the path
specified in the <code>BEVY_ASSET_ROOT</code> or <code>CARGO_MANIFEST_DIR</code> environment variable.
This allows <code>cargo run</code> to work correctly from the terminal.</p>
<p>If you want to run your project from VSCode in a non-standard way (say, inside a
debugger), you have to be sure to set that correctly.</p>
<p>If this is not set, Bevy will search for <code>assets</code> alongside the executable
binary, in the same folder where it is located. This makes things easy for
distribution. However, during development, since your executable is located
in the <code>target</code> directory where <code>cargo</code> placed it, Bevy will be unable to
find the <code>assets</code>.</p>
<p>Here is a snippet showing how to create a run configuration for debugging Bevy
(with <code>lldb</code>):</p>
<p>(this is for development on Bevy itself, and testing with the <code>breakout</code> example)</p>
<p>(adapt to your needs if using for your project)</p>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;lldb&quot;,
    &quot;request&quot;: &quot;launch&quot;,
    &quot;name&quot;: &quot;Debug example 'breakout'&quot;,
    &quot;cargo&quot;: {
        &quot;args&quot;: [
            &quot;build&quot;,
            &quot;--example=breakout&quot;,
            &quot;--package=bevy&quot;
        ],
        &quot;filter&quot;: {
            &quot;name&quot;: &quot;breakout&quot;,
            &quot;kind&quot;: &quot;example&quot;
        }
    },
    &quot;args&quot;: [],
    &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
    &quot;env&quot;: {
        &quot;CARGO_MANIFEST_DIR&quot;: &quot;${workspaceFolder}&quot;,
    }
}
</code></pre>
<p>To support dynamic linking, you should also add the following, inside the <code>&quot;env&quot;</code> section:</p>
<p>Linux:</p>
<pre><code class="language-json">&quot;LD_LIBRARY_PATH&quot;: &quot;${workspaceFolder}/target/debug/deps:${env:HOME}/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib&quot;,
</code></pre>
<p>(replace <code>stable-x86_64-unknown-linux-gnu</code> if you use a different toolchain/architecture)</p>
<p>Windows: I don't know. If you do, please <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">file an issue</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/editor//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="jetbrains-rustrover-intellij-clion"><a class="header" href="#jetbrains-rustrover-intellij-clion">JetBrains (RustRover, IntelliJ, CLion)</a></h1>
<p>If you are a JetBrains user and you'd like something to be added to this page,
please file a <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub Issue</a>.</p>
<h2 id="rust-language-support-1"><a class="header" href="#rust-language-support-1">Rust Language Support</a></h2>
<p>When using <a href="setup/editor//programming/queries.html">queries</a>, type information gets lost due to Bevy relying
on procedural macros. You can fix this by enabling <a href="https://github.com/intellij-rust/intellij-rust/issues/6908">procedural macro
support</a> in the IDE.</p>
<ol>
<li>type <code>Experimental feature</code> in the dialog of the <code>Help | Find Action</code> action</li>
<li>enable the features <code>org.rust.cargo.evaluate.build.scripts</code> and <code>org.rust.macros.proc</code></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/editor//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="kakoune"><a class="header" href="#kakoune">Kakoune</a></h1>
<p>If you are a Kakoune user and you'd like something to be added to this page,
please file a <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub Issue</a>.</p>
<h2 id="rust-language-support-2"><a class="header" href="#rust-language-support-2">Rust Language Support</a></h2>
<p>You can use <code>kak-lsp</code> with <code>rust-analyzer</code>.</p>
<p>You want to install just the RA server, without the official VSCode plugin.</p>
<p>You can manage it via <code>rustup</code>:</p>
<pre><code class="language-sh">rustup component add rust-analyzer
</code></pre>
<p>Or you can build/install it yourself from git:</p>
<pre><code class="language-sh">git clone https://github.com/rust-lang/rust-analyzer
cd rust-analyzer
git checkout release # use the `release` branch instead of `main`
cargo xtask install --server
</code></pre>
<p>The easiest way to set up <code>kak-lsp</code> is using <code>plug.kak</code>.</p>
<p>If you don't have <code>plug.kak</code>, put the following in <code>~/.config/kak/kakrc</code>:</p>
<pre><code class="language-kak">evaluate-commands %sh{
    plugins=&quot;$kak_config/plugins&quot;
    mkdir -p &quot;$plugins&quot;
    [ ! -e &quot;$plugins/plug.kak&quot; ] &amp;&amp; \
        git clone -q https://github.com/andreyorst/plug.kak.git &quot;$plugins/plug.kak&quot;
    printf &quot;%s\n&quot; &quot;source '$plugins/plug.kak/rc/plug.kak'&quot;
}
plug &quot;andreyorst/plug.kak&quot; noload
</code></pre>
<p>And then to set up <code>kak-lsp</code> with Rust support:</p>
<pre><code class="language-kak">plug &quot;kak-lsp/kak-lsp&quot; do %{
    cargo install --force --path .
} config %{
    set global lsp_cmd &quot;kak-lsp -s %val{session}&quot;

    # create a command to let you restart LSP if anything goes wrong / gets glitched
    define-command lsp-restart -docstring 'restart lsp server' %{ lsp-stop; lsp-start }

    # helper command to enable LSP
    define-command -hidden lsp-init %{
        lsp-enable-window
        # preferences:
        set window lsp_auto_highlight_references true
        lsp-auto-signature-help-enable
        # keybind: use &quot;,&quot; to get a menu of available LSP commands
        map global normal &quot;,&quot; &quot;: enter-user-mode lsp&lt;ret&gt;&quot; -docstring &quot;LSP mode&quot;
    }

    hook global KakEnd .* lsp-exit

    # autoenable LSP when opening Rust files
    hook global WinSetOption filetype=rust %{
        lsp-init
    }
}
# formatting settings for Rust files
hook global BufSetOption filetype=rust %{
    set buffer tabstop 4
    set buffer indentwidth 4
    set buffer formatcmd 'rustfmt'
    set buffer autowrap_column 100
    expandtab
}
</code></pre>
<p>Put the following in <code>~/.config/kak-lsp/kak-lsp.toml</code> to use <code>rust-analyzer</code>:</p>
<pre><code class="language-toml">[server]
# Shut down the `rust-analyzer` process after a period of inactivity
timeout = 900

[language.rust]
filetypes = [&quot;rust&quot;]
roots = [&quot;Cargo.toml&quot;]
command = &quot;rust-analyzer&quot;
settings_section = &quot;rust-analyzer&quot;

[language.rust.settings.rust-analyzer]
# Proc Macro support is important for Bevy projects
procMacro.enable = true
# disable hover actions, can be laggy on complex projects like Bevy
hoverActions.enable = false
# use the data generated by `cargo check`; disable if it is too slow for you
cargo.loadOutDirsFromCheck = true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/editor//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="vim"><a class="header" href="#vim">Vim</a></h1>
<p>If you are a Vim user and you'd like something to be added to this page,
please file a <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub Issue</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/editor//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="emacs"><a class="header" href="#emacs">Emacs</a></h1>
<p>If you are an Emacs user and you'd like something to be added to this page,
please file a <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub Issue</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="configuring-bevy"><a class="header" href="#configuring-bevy">Configuring Bevy</a></h1>
<p>Bevy is very modular and configurable. It is implemented as many separate
cargo crates, allowing you to remove the parts you don't need. Higher-level
functionality is built on top of lower-level foundational crates, and can
be disabled or replaced with alternatives.</p>
<p>The lower-level core crates (like the Bevy ECS) can also be used completely
standalone, or integrated into otherwise non-Bevy projects.</p>
<h2 id="bevy-cargo-features"><a class="header" href="#bevy-cargo-features">Bevy Cargo Features</a></h2>
<p>In Bevy projects, you can enable/disable various parts of Bevy using cargo features.</p>
<p>Many common features are enabled by default. If you want to disable some of
them, you need to disable all of them and re-enable the ones you need.
Unfortunately, Cargo does not let you just disable individual default features.</p>
<p>Here is how you might configure your Bevy:</p>
<pre><code class="language-toml">[dependencies.bevy]
version = &quot;0.12&quot;
# Disable the default features if there are any that you do not want
default-features = false
features = [
  # These are the default features:
  # (re-enable whichever you like)

  # Bevy functionality:
  &quot;multi-threaded&quot;,     # Run with multithreading
  &quot;bevy_asset&quot;,         # Assets management
  &quot;bevy_audio&quot;,         # Builtin audio
  &quot;bevy_gilrs&quot;,         # Gamepad input support
  &quot;bevy_scene&quot;,         # Scenes management
  &quot;bevy_winit&quot;,         # Window management (cross-platform Winit backend)
  &quot;bevy_render&quot;,        # Rendering framework core
  &quot;bevy_core_pipeline&quot;, # Common rendering abstractions
  &quot;bevy_gizmos&quot;,        # Support drawing debug lines and shapes
  &quot;bevy_sprite&quot;,        # 2D (sprites) rendering
  &quot;bevy_pbr&quot;,           # 3D (physically-based) rendering
  &quot;bevy_gltf&quot;,          # GLTF 3D assets format support
  &quot;bevy_text&quot;,          # Text/font rendering
  &quot;bevy_ui&quot;,            # UI toolkit
  &quot;animation&quot;,          # Animation support
  &quot;tonemapping_luts&quot;,   # Support different camera Tonemapping modes (enables KTX2+zstd)
  &quot;default_font&quot;,       # Embed a minimal default font for text/UI

  # File formats:
  &quot;png&quot;,    # PNG image format for simple 2D images
  &quot;hdr&quot;,    # HDR images
  &quot;ktx2&quot;,   # Preferred format for GPU textures
  &quot;zstd&quot;,   # ZSTD compression support in KTX2 files
  &quot;vorbis&quot;, # Audio: OGG Vorbis

  # Platform-specific:
  &quot;x11&quot;,                   # Linux: Support X11 windowing system
  &quot;android_shared_stdcxx&quot;, # Android: use shared C++ library
  &quot;webgl2&quot;,                # Web: use WebGL2 instead of WebGPU

  # These are other (non-default) features that may be of interest:
  # (add any of these that you need)

  # Bevy functionality:
  &quot;asset_processor&quot;,      # Asset processing
  &quot;file_watcher&quot;,         # Asset hot-reloading
  &quot;subpixel_glyph_atlas&quot;, # Subpixel antialiasing for text/fonts
  &quot;serialize&quot;,            # Support for `serde` Serialize/Deserialize
  &quot;async-io&quot;,             # Make bevy use `async-io` instead of `futures-lite`
  &quot;pbr_transmission_textures&quot;, # Enable Transmission textures in PBR materials
                               # (may cause issues on old/lowend GPUs)

  # File formats:
  &quot;dds&quot;,  # Alternative DirectX format for GPU textures, instead of KTX2
  &quot;jpeg&quot;, # JPEG lossy format for 2D photos
  &quot;webp&quot;, # WebP image format
  &quot;bmp&quot;,  # Uncompressed BMP image format
  &quot;tga&quot;,  # Truevision Targa image format
  &quot;exr&quot;,  # OpenEXR advanced image format
  &quot;pnm&quot;,  # PNM (pam, pbm, pgm, ppm) image format
  &quot;basis-universal&quot;, # Basis Universal GPU texture compression format
  &quot;zlib&quot;, # zlib compression support in KTX2 files
  &quot;flac&quot;, # Audio: FLAC lossless format
  &quot;mp3&quot;,  # Audio: MP3 format (not recommended)
  &quot;wav&quot;,  # Audio: Uncompressed WAV
  &quot;symphonia-all&quot;, # All Audio formats supported by the Symphonia library
  &quot;shader_format_glsl&quot;, # GLSL shader support
  &quot;shader_format_spirv&quot;, # SPIR-V shader support

  # Platform-specific:
  &quot;wayland&quot;,              # (Linux) Support Wayland windowing system
  &quot;accesskit_unix&quot;,       # (Unix-like) AccessKit integration for UI Accessibility
  &quot;bevy_dynamic_plugin&quot;,  # (Desktop) support for loading of `DynamicPlugin`s

  # Development/Debug features:
  &quot;dynamic_linking&quot;,   # Dynamic linking for faster compile-times
  &quot;trace&quot;,             # Enable tracing for performance measurement
  &quot;detailed_trace&quot;,    # Make traces more verbose
  &quot;trace_tracy&quot;,       # Tracing using `tracy`
  &quot;trace_tracy_memory&quot;, # + memory profiling
  &quot;trace_chrome&quot;,      # Tracing using the Chrome format
  &quot;wgpu_trace&quot;,        # WGPU/rendering tracing
  &quot;debug_glam_assert&quot;, # Assertions to validate math (glam) usage
  &quot;embedded_watcher&quot;,  # Hot-reloading for Bevy's internal/builtin assets
]
</code></pre>
<p>(See <a href="https://docs.rs/crate/bevy/0.12.0/features">here</a> for a full list of Bevy's cargo features.)</p>
<h3 id="graphics--rendering"><a class="header" href="#graphics--rendering">Graphics / Rendering</a></h3>
<p>For a graphical application or game (most Bevy projects), you can include
<code>bevy_winit</code> and your selection of Rendering features. For
<a href="setup//platforms/linux.html">Linux</a> support, you need at least one of <code>x11</code> or <code>wayland</code>.</p>
<p><code>bevy_render</code> and <code>bevy_core_pipeline</code> are required for any application using
Bevy rendering.</p>
<p>If you only need 2D and no 3D, add <code>bevy_sprite</code>.</p>
<p>If you only need 3D and no 2D, add <code>bevy_pbr</code>. If you are <a href="setup//3d/gltf.html">loading 3D models
from GLTF files</a>, add <code>bevy_gltf</code>.</p>
<p>If you are using Bevy UI, you need <code>bevy_text</code> and <code>bevy_ui</code>. <code>default_font</code>
embeds a simple font file, which can be useful for prototyping, so you don't
need to have a font asset in your project. In a real project, you probably
want to use your own fonts, so your text can look good with your game's art
style. In that case, you can disable the <code>default_font</code> feature.</p>
<p>If you want to draw debug lines and shapes on-screen, add <code>bevy_gizmos</code>.</p>
<p>If you don't need any graphics (like for a dedicated game server, scientific
simulation, etc.), you may remove all of these features.</p>
<h3 id="file-formats-1"><a class="header" href="#file-formats-1">File Formats</a></h3>
<p>You can use the relevant cargo features to enable/disable support for loading
assets with various different file formats.</p>
<p>See <a href="setup//builtins.html#file-formats">here</a> for more information.</p>
<h3 id="input-devices"><a class="header" href="#input-devices">Input Devices</a></h3>
<p>If you do not care about <a href="setup//input/gamepad.html">gamepad (controller/joystick)</a>
support, you can disable <code>bevy_gilrs</code>.</p>
<h3 id="platform-specific"><a class="header" href="#platform-specific">Platform-specific</a></h3>
<h4 id="linux-windowing-backend"><a class="header" href="#linux-windowing-backend">Linux Windowing Backend</a></h4>
<p>On <a href="setup//platforms/linux.html">Linux</a>, you can choose to support X11, Wayland,
or both. Only <code>x11</code> is enabled by default, as it is the legacy system
that should be compatible with most/all distributions, to make your builds
smaller and compile faster. You might want to additionally enable <code>wayland</code>,
to fully and natively support modern Linux environments. This will add a few
extra transitive dependencies to your project.</p>
<p>Some Linux distros or platforms might struggle with X11 and work better with
Wayland. You should enable both for best compatibility.</p>
<h4 id="webgpu-vs-webgl2"><a class="header" href="#webgpu-vs-webgl2">WebGPU vs WebGL2</a></h4>
<p>On [Web/WASM][platform::web], you have a choice between these two rendering backends.</p>
<p>WebGPU is the modern experimental solution, offering good performance and
full feature support, but browser support for it is limited (only known to
work in very recent versions of Chrome and Firefox nightly).</p>
<p>WebGL2 gives the best compatibility with all browsers, but has worse performance
and some limitations on what kinds of graphics features you can use in Bevy.</p>
<p>The <code>webgl2</code> cargo feature selects WebGL2 if enabled. If disabled, WebGPU is used.</p>
<h3 id="development-features"><a class="header" href="#development-features">Development Features</a></h3>
<p>While you are developing your project, these features might be useful:</p>
<h4 id="asset-hot-reloading-and-processing"><a class="header" href="#asset-hot-reloading-and-processing">Asset hot-reloading and processing</a></h4>
<p>The <code>file_watcher</code> feature enables support for <a href="setup//assets/hot-reload.html">hot-reloading of
assets</a>, supported on desktop platforms.</p>
<p>The <code>asset_processor</code> feature enables support for <a href="setup//assets/processing.html">asset
processing</a>, allowing you to automatically convert and
optimize assets during development.</p>
<h4 id="dynamic-linking"><a class="header" href="#dynamic-linking">Dynamic Linking</a></h4>
<p><code>dynamic_linking</code> causes Bevy to be built and linked as a shared/dynamic
library. This will make recompilation <em>much</em> faster during development.</p>
<p>This is only supported on desktop platforms. Known to work very well on Linux.
Windows and macOS are also supported, but are less tested and have had issues in
the past.</p>
<p>It is not recommended to enable this for release builds you intend to publish
to other people, unless you have a very good special reason to and you know
what you are doing. It introduces unneeded complexity (you need to bundle
extra files) and potential for things to not work correctly. You should only
use it during development.</p>
<p>For this reason, it may be convenient to specify the feature as a commandline
option to <code>cargo</code>, instead of putting it in your <code>Cargo.toml</code>. Simply run your
project like this:</p>
<pre><code class="language-sh">cargo run --features bevy/dynamic_linking
</code></pre>
<p>You could also add this to your <a href="setup//setup/editor.html">IDE/editor configuration</a>.</p>
<h4 id="tracing"><a class="header" href="#tracing">Tracing</a></h4>
<p>The features <code>trace</code> and <code>wgpu_trace</code> may be useful for profiling and
diagnosing performance issues.</p>
<p><code>trace_chrome</code> and <code>trace_tracy</code> choose the backend you want to use to
visualize the traces.</p>
<p>See <a href="https://github.com/bevyengine/bevy/blob/main/docs/profiling.md">Bevy's official docs on profiling</a> to learn more.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="community-plugins-ecosystem"><a class="header" href="#community-plugins-ecosystem">Community Plugins Ecosystem</a></h1>
<p>There is a growing ecosystem of unofficial community-made plugins for Bevy.
They provide a lot of functionality that is not officially included with the
engine. You might greatly benefit from using some of these in your projects.</p>
<p>To find such plugins, you should search the <a href="https://bevyengine.org/assets">Bevy Assets</a>
page on the official Bevy website. This is the official registry of known
community-made things for Bevy. If you publish your own plugins for Bevy,
you should <a href="https://github.com/bevyengine/bevy-assets">contribute a link to be added to that page</a>.</p>
<p>Beware that some 3rd-party plugins may use unusual licenses! Be sure to
check the license before using a plugin in your project.</p>
<hr />
<p>Other pages in this book with valuable information when using 3rd-party plugins:</p>
<ul>
<li>Some plugins may require you to <a href="setup//setup/bevy-config.html">configure Bevy in some specific way</a>.</li>
<li>If you are <a href="setup//setup/bevy-git.html">using bleeding-edge unreleased Bevy (main)</a>, you may encounter difficulties with plugin compatibility.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-11">0.11</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="dev-tools-and-editors-for-bevy"><a class="header" href="#dev-tools-and-editors-for-bevy">Dev Tools and Editors for Bevy</a></h1>
<p>Bevy does not yet have an official editor or other such tools. An official
editor is planned as a long-term future goal. In the meantime, here are
some community-made tools to help you.</p>
<hr />
<h2 id="editor"><a class="header" href="#editor">Editor</a></h2>
<p><a href="https://github.com/jakobhellermann/bevy-inspector-egui"><code>bevy_inspector_egui</code></a> gives you a simple
editor-like property inspector window in-game. It lets you modify the values of
your components and resources in real-time as the game is running.</p>
<p><a href="https://github.com/jakobhellermann/bevy_editor_pls"><code>bevy_editor_pls</code></a> is an editor-like interface that
you can embed into your game. It has even more features, like switching app
states, fly camera, performance diagnostics, and inspector panels.</p>
<p><a href="https://github.com/rewin123/space_editor"><code>space_editor</code></a> is another such editor that can be
embedded into your game. It seems to be designed for a Unity-inspired prefab
workflow.</p>
<p>You can also use <a href="https://www.blender.org/">Blender</a> as a level/scene editor,
by exporting your scenes to <a href="setup//3d/gltf.html">GLTF</a>. The <a href="https://github.com/kaosat-dev/Blender_bevy_components_workflow">Blender Bevy Components
Workflow</a> project improves on this
experience, by allowing you to setup your Bevy ECS <a href="setup//programming/ec.html#components">Components</a>
in Blender, include them in the exported GLTF, and use them in Bevy.</p>
<h2 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h2>
<p><a href="https://github.com/jakobhellermann/bevy_mod_debugdump"><code>bevy_mod_debugdump</code></a> is a tool to help visualize
your <a href="setup/../programming/app-builder.html">App Schedules</a> (all of the registered
<a href="setup/../programming/systems.html">systems</a> with their <a href="setup/../programming/system-order.html">ordering
dependencies</a>), and the Bevy Render Graph.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="performance-tunables"><a class="header" href="#performance-tunables">Performance Tunables</a></h1>
<p>Bevy offers a lot of features that should improve performance in most cases, and
most of them are enabled by default. However, they might be detrimental to some
projects.</p>
<p>Luckily, most of them are configurable. Most users should probably not touch
these settings, but if your game does not perform well with Bevy's default
configuration, this page will show you some things you can try to change, to see
if they help your project.</p>
<p>Bevy's default configruation is designed with <em>scalability</em> in mind. That is, so
that you don't have to worry too much about performance, as you add more
features and complexity to your project. Bevy will automatically take care to
distribute the workload as to make good use of the available hardware (GPU, CPU
multithreading).</p>
<p>However, it might hurt simpler projects or have undesirable implications in some
cases.</p>
<p>This trade-off is good, because small and simple games will probably be fast
enough anyway, even with the additional overhead, but large and complex games
will benefit from the advanced scheduling to avoid bottlenecks. You can
develop your game without performance degrading much as you add more stuff.</p>
<h2 id="multithreading-overhead"><a class="header" href="#multithreading-overhead">Multithreading Overhead</a></h2>
<p>Bevy has a smart multithreaded executor, so that your <a href="setup//programming/systems.html">systems</a> can
automatically <a href="setup//programming/intro-code.html">run in parallel</a> across multiple CPU cores,
when they don't need conflicting access to the same data, while <a href="setup//programming/system-order.html">honoring ordering
constraints</a>. This is great, because you can just keep adding
more systems to do different things and implement more features in your game,
and Bevy will make good use of modern multi-core CPUs with no effort from you!</p>
<p>However, the smart scheduling adds some overhead to all common operations (such
as every time a <a href="setup//programming/systems.html">system</a> runs). In projects that have little work to
do every frame, especially if all of your systems complete very quickly, the
overhead can add up to overshadow the actual useful work you are doing!</p>
<p>You might want to try disabling multithreading, to see if your game might
perform better without it.</p>
<h3 id="disabling-multithreading-for-update-schedule-only"><a class="header" href="#disabling-multithreading-for-update-schedule-only">Disabling Multithreading for Update Schedule Only</a></h3>
<p>Multithreading can be disabled per-<a href="setup//programming/schedules.html">schedule</a>. This means it
is easy to disable it only for your code / game logic (in the <code>Update</code> schedule),
while still leaving it enabled for all the Bevy engine internal systems.</p>
<p>This could speed up simple games that don't have much gameplay logic, while still
letting the engine run with multithreading.</p>
<p>You can edit the settings of a specific <a href="setup//programming/schedules.html">schedule</a> via the <a href="setup//programming/app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">use bevy::ecs::schedule::ExecutorKind;

App::new()
    .add_plugins(DefaultPlugins)
    .edit_schedule(Update, |schedule| {
        schedule.set_executor_kind(ExecutorKind::SingleThreaded);
    })
    // ...</code></pre>
<h3 id="disabling-multithreading-completely"><a class="header" href="#disabling-multithreading-completely">Disabling Multithreading Completely</a></h3>
<p>If you want to try to completely disable multithreading for everything,
you can do so by removing the <code>multi-threaded</code> default Cargo feature.</p>
<p>In <code>Cargo.toml</code></p>
<pre><code class="language-toml">[dependencies.bevy]
version = &quot;0.12&quot;
default-features = false
features = [
   # re-enable everything you need, without `multi-threaded`
   # ...
]
</code></pre>
<p><a href="setup//setup/bevy-config.html">(see here for how to configure Bevy's cargo features)</a></p>
<p>This is generally not recommended. Bevy is designed to work with multithreading.
Only consider it if you really need it (like if you are making a special build
of your project to run on a system where it makes sense, like WASM or old
hardware).</p>
<h2 id="multithreading-configuration"><a class="header" href="#multithreading-configuration">Multithreading Configuration</a></h2>
<p>You can configure how many CPU threads Bevy uses.</p>
<p>Bevy creates threads for 3 different purposes:</p>
<ul>
<li>Compute: where all your systems and all per-frame work is run</li>
<li>AsyncCompute: for background processing independent from framerate</li>
<li>I/O: for loading of assets and other disk/network activity</li>
</ul>
<p>By default, Bevy <em>splits/partitions</em> the available CPU threads as follows:</p>
<ul>
<li>I/O: 25% of the available CPU threads, minimum 1, maximum 4</li>
<li>AsyncCompute: 25% of the available CPU threads, minimum 1, maximum 4</li>
<li>Compute: all remaining threads</li>
</ul>
<p>This means <em>no overprovisioning</em>. Every hardware CPU thread is used
for one specific purpose.</p>
<p>This provides a good balance for mixed CPU workloads. Particularly for games
that load a lot of assets (especially if assets are loaded dynamically during
gameplay), the dedicated I/O threads will reduce stuttering and load times.
Background computation will not affect your framerate. Etc.</p>
<p>Examples:</p>
<div class="table-wrapper"><table><thead><tr><th>CPU Cores/Threads</th><th># I/O</th><th># AsyncCompute</th><th># Compute</th></tr></thead><tbody>
<tr><td>1-3</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>4</td><td>1</td><td>1</td><td>2</td></tr>
<tr><td>6</td><td>2</td><td>2</td><td>2</td></tr>
<tr><td>8</td><td>2</td><td>2</td><td>4</td></tr>
<tr><td>10</td><td>3</td><td>3</td><td>4</td></tr>
<tr><td>12</td><td>3</td><td>3</td><td>6</td></tr>
<tr><td>16</td><td>4</td><td>4</td><td>8</td></tr>
<tr><td>24</td><td>4</td><td>4</td><td>16</td></tr>
<tr><td>32</td><td>4</td><td>4</td><td>24</td></tr>
</tbody></table>
</div>
<p>Note: Bevy does not currently have any special handling for asymmetric
(big.LITTLE or Intel P/E cores) CPUs. In an ideal world, maybe it would be nice
to use the number of big/P cores for Compute and little/E cores for I/O.</p>
<h3 id="overprovisioning"><a class="header" href="#overprovisioning">Overprovisioning</a></h3>
<p>However, if your game does very little I/O (asset loading) or background
computation, this default configuration might be sub-optimal. Those threads will
be sitting idle a lot of the time. Meanwhile, Compute, which is your frame
update loop and is important to your game's overall framerate, is limited to
fewer threads. This can be especially bad on CPUs with few cores (less than 4
total threads).</p>
<p>For example, in my projects, I usually load all my assets during a loading
screen, so the I/O threads are unused during normal gameplay. I rarely use
AsyncCompute.</p>
<p>If your game is like that, you might want to make all CPU threads available for
Compute. This could boost your framerate, especially on CPUs with few cores.
However, any AsyncCompute or I/O workloads during gameplay could impact your
game's performance / framerate consistency.</p>
<p>Here is how to do that:</p>
<pre><code class="language-rust no_run noplayground">use bevy::core::TaskPoolThreadAssignmentPolicy;
use bevy::tasks::available_parallelism;

App::new()
    .add_plugins(DefaultPlugins.set(TaskPoolPlugin {
        task_pool_options: TaskPoolOptions {
            compute: TaskPoolThreadAssignmentPolicy {
                // set the minimum # of compute threads
                // to the total number of available threads
                min_threads: available_parallelism(),
                max_threads: std::usize::MAX, // unlimited max threads
                percent: 1.0, // this value is irrelevant in this case
            },
            // keep the defaults for everything else
            ..default()
        }
    }))
    // ...</code></pre>
<p>And here is an example of an entirely custom configuration:</p>
<pre><code class="language-rust no_run noplayground">App::new()
    .add_plugins(DefaultPlugins.set(TaskPoolPlugin {
        task_pool_options: TaskPoolOptions {
            min_total_threads: 1,
            max_total_threads: std::usize::MAX, // unlimited threads
            io: TaskPoolThreadAssignmentPolicy {
                // say we know our app is i/o intensive (asset streaming?)
                // so maybe we want lots of i/o threads
                min_threads: 4,
                max_threads: std::usize::MAX,
                percent: 0.5, // use 50% of available threads for I/O
            },
            async_compute: TaskPoolThreadAssignmentPolicy {
                // say our app never does any background compute,
                // so we don't care, but keep one thread just in case
                min_threads: 1,
                max_threads: 1,
                percent: 0.0,
            },
            compute: TaskPoolThreadAssignmentPolicy {
                // say we want to use at least half the CPU for compute
                // (maybe over-provisioning if there are very few cores)
                min_threads: available_parallelism() / 2,
                // but limit it to a maximum of 8 threads
                max_threads: 8,
                // 1.0 in this case means &quot;use all remaining threads&quot;
                // (that were not assigned to io/async_compute)
                // (clamped to min_threads..=max_threads)
                percent: 1.0,
            },
        }
    }))
    // ...</code></pre>
<h2 id="pipelined-rendering"><a class="header" href="#pipelined-rendering">Pipelined Rendering</a></h2>
<p>Bevy has a <a href="setup//gpu/intro.html">pipelined rendering architecture</a>. This
means Bevy's GPU-related <a href="setup//programming/systems.html">systems</a> (that run on the CPU to prepare
work for the GPU every frame) will run in parallel with all the normal systems
for the next frame. Bevy will render the previous frame in parallel with the
next frame update.</p>
<p>This will improve GPU utilization (make it less likely the GPU will sit idle
waiting for the CPU to give it work to do), by making better use of CPU
multithreading. Typically, it can result in 10-30% higher framerate, sometimes
more.</p>
<p>However, it can also affect perceived input latency (&quot;click-to-photon&quot;
latency), often for the worse. The effects of the player's input might be
shown on screen delayed by one frame. It might be compensated by the faster
framerate, or it might not be. Here is a diagram to visualize what happens:</p>
<p><img src="setup//img/pipelined-latency.png" alt="Timeline comparing pipelined and non-pipelined rendering. In the pipelined case, one additional frame is displayed before the effects of the mouse click can be seen on-screen." /></p>
<p>The actual mouse click happens in-between frames. In both cases, frame #4 is
when the input is detected by Bevy. In the pipelined case, rendering
of the previous frame is done in parallel, so an additional frame without
the input appears on-screen.</p>
<p>Without pipelining, the user will see their input delayed by 1 frame. With
pipelining, it will be delayed by 2 frames.</p>
<p>However, in the diagram above, the frame rate increase from pipelining is
big enough that overall the input is processed and displayed sooner. Your
application might not be so lucky.</p>
<hr />
<p>If you care more about latency than framerate, you might want to disable
pipelined rendering. For the best latency, you probably also want to
<a href="setup//window/props.html#vsync">disable VSync</a>.</p>
<p>Here is how to disable pipelined rendering:</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::pipelined_rendering::PipelinedRenderingPlugin;

App::new()
    .add_plugins(DefaultPlugins.build().disable::&lt;PipelinedRenderingPlugin&gt;())
    // ...
    .run();</code></pre>
<h2 id="clustered-forward-rendering"><a class="header" href="#clustered-forward-rendering">Clustered Forward Rendering</a></h2>
<p>By default, Bevy uses a Clustered Forward Rendering architecture for 3D.  The
viewport (on-screen area where the game is displayed) is split into
rectangles/voxels, so that the lighting can be handled separately for each small
portion of the scene. This allows you to use many lights in your 3D scenes,
without destroying performance.</p>
<p>The dimensions of these clusters can affect rendering performance. The default
settings are good for most 3D games, but fine-tuning them could improve
performance, depending on your game.</p>
<p>In games with a top-down-view camera (such as many strategy and simulation
games), most of the lights tend to be a similar distance away from the camera.
In such cases, you might want to reduce the number of Z slices (so that the
screen is split into smaller X/Y rectangles, but each one covering more
distance/depth):</p>
<pre><code class="language-rust no_run noplayground">use bevy::pbr::ClusterConfig;

commands.spawn((
    Camera3dBundle {
        // ... your 3D camera configruation
        ..Default::default()
    },
    ClusterConfig::FixedZ {
        // 4096 clusters is the Bevy default
        // if you don't have many lights, you can reduce this value
        total: 4096,
        // Bevy default is 24 Z-slices
        // For a top-down-view game, 1 is probably optimal.
        z_slices: 1,
        dynamic_resizing: true,
        z_config: Default::default(),
    }
));</code></pre>
<p>For games that use very few lights, or where lights affect the entire scene (
such as inside a small room / indoor area), you might want to try disabling
clustering:</p>
<pre><code class="language-rust no_run noplayground">commands.spawn((
    Camera3dBundle {
        // ... your 3D camera configruation
        ..Default::default()
    },
    ClusterConfig::Single,
));</code></pre>
<p>Changing these settings will probably result in bad performance for many games,
outside of the specific scenarios described above.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="using-bleeding-edge-bevy-bevy-main"><a class="header" href="#using-bleeding-edge-bevy-bevy-main">Using bleeding-edge Bevy (bevy main)</a></h1>
<p>Bevy development moves very fast, and there are often exciting new things that
are yet unreleased. This page will give you advice about using development
versions of bevy.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>If you are <em>not</em> using any 3rd-party plugins and just want to use the bevy
main development branch:</p>
<pre><code class="language-toml">[dependencies]
bevy = { git = &quot;https://github.com/bevyengine/bevy&quot; }
</code></pre>
<p>However, if you <em>are</em> working with external plugins, you should read the rest
of this page. You will likely need to do more to make everything compatible.</p>
<h2 id="should-you-use-bleeding-edge-bevy-what-version-of-bevy-should-you-use"><a class="header" href="#should-you-use-bleeding-edge-bevy-what-version-of-bevy-should-you-use">Should you use bleeding-edge Bevy? What version of Bevy should you use?</a></h2>
<p>Bevy follows a &quot;train release&quot; model, with loose deadlines. Every 3 months,
a new major release is prepared, which will contain all new developments
(features, fixes, etc.) since the last release. The release date is not
strict and is often delayed by a few weeks to tie up loose ends.</p>
<p>Further, Bevy usually follows up every major release with a patch release
or two, as needed, to fix any bugs discovered soon after release. It will
not contain all fixes, just small non-breaking things that are considered
critical enough.</p>
<p>Most Bevy projects should use the latest release on crates.io. If you want
to play it safe, you can wait until the first patch release (<code>0.*.1</code>),
before upgrading to a new major version. You might also want to wait for
any 3rd-party plugins you are using to support the new Bevy version.</p>
<p>On the other hand, for experimentation and for Bevy development, you are
encouraged to try the latest in-development code from git! The latest
release is often missing the freshest bug fixes, usability improvements,
and features. It may be compelling to join in on the action!</p>
<p>If you are new to Bevy, this might not be for you. You might be more
comfortable using the released version. It will have the best compatibility
with community plugins and documentation.</p>
<p>The in-development version of Bevy has frequent breaking changes. Therefore,
it can be very annoying to use for real projects. Also, 3rd-party plugin
authors often don't bother to stay compatible. You will face breakage often
and probably have to fix it yourself.</p>
<p>It is only recommended to do this for more experimental or toy projects.</p>
<p>Though, there are ways you can manage the breakage and make it less of a
problem. Thanks to cargo, you can update bevy at your convenience, whenever you
feel ready to handle any possible breaking changes.</p>
<p>You may want to consider forking the repositories of Bevy and any plugins you
use. Using your own forks allows you to easily apply fixes if needed, or edit
their <code>Cargo.toml</code> for any special configuration to make your project work.</p>
<p>If you choose to use Bevy main, you are highly encouraged to interact with
the Bevy community on <a href="https://discord.gg/bevy">Discord</a> and <a href="https://github.com/bevyengine/bevy">GitHub</a>, so
you can keep track of what's going on, get help, or participate in discussions.</p>
<h2 id="common-pitfall-mysterious-compile-errors"><a class="header" href="#common-pitfall-mysterious-compile-errors">Common pitfall: mysterious compile errors</a></h2>
<p>When changing between different versions of Bevy (say, transitioning an existing
project from the released version to the git version), you might get lots of
strange unexpected build errors.</p>
<p>You can typically fix them by removing <code>Cargo.lock</code> and the <code>target</code> directory:</p>
<pre><code class="language-sh">rm -rf Cargo.lock target
</code></pre>
<p>See <a href="setup//pitfalls/build-errors.html">this page</a> for more info.</p>
<p>If you are still getting errors, it is probably because cargo is trying
to use multiple different versions of bevy in your dependency tree
simultaneously. This can happen if some of the plugins you use have specified
a different Bevy version/commit from your project.</p>
<p>If you are using any 3rd-party plugins, please consider forking them, so you can
edit their <code>Cargo.toml</code> and have control over how everything is configured.</p>
<h2 id="cargo-patches"><a class="header" href="#cargo-patches">Cargo Patches</a></h2>
<p>In some cases, you might be able to use &quot;cargo patches&quot; to locally override
dependencies. For example, you might be able to point plugins to use your
fork of bevy, without forking and editing the plugin's <code>Cargo.toml</code>, by
doing something like this:</p>
<pre><code class="language-toml"># replace the bevy git URL source with ours
[patch.&quot;https://github.com/bevyengine/bevy&quot;]
# if we have our own fork
bevy = { git = &quot;https://github.com/me/bevy&quot; }
# if we want to use a local path
bevy = { path = &quot;../bevy&quot; }
# some plugins might depend on individual bevy crates,
# instead of all of bevy, which means we need to patch
# every individual bevy crate specifically:
bevy_ecs = { path = &quot;../bevy/crates/bevy_ecs&quot; }
bevy_app = { path = &quot;../bevy/crates/bevy_app&quot; }
# ...

# replace released versions of crates (crates.io source) with ours
[patch.crates-io]
bevy_some_plugin = { git = &quot;https://github.com/me/bevy_some_plugin&quot;, branch = &quot;bevy_main&quot; }
# also replace bevy itself
bevy = { path = &quot;../bevy&quot; }
# ...
</code></pre>
<h2 id="updating-bevy"><a class="header" href="#updating-bevy">Updating Bevy</a></h2>
<p>It is recommended that you specify a known-good Bevy commit in your
<code>Cargo.toml</code>, so that you can be sure that you only update it when you
actually want to do so, avoiding unwanted breakage.</p>
<pre><code class="language-toml">bevy = { git = &quot;https://github.com/bevyengine/bevy&quot;, rev = &quot;7a1bd34e&quot; }
</code></pre>
<p>When you change anything, be sure to run:</p>
<pre><code class="language-sh">cargo update
</code></pre>
<p>(or delete <code>Cargo.lock</code>)</p>
<p>Otherwise you risk errors from cargo not resolving dependencies correctly.</p>
<h2 id="advice-for-plugin-authors"><a class="header" href="#advice-for-plugin-authors">Advice for plugin authors</a></h2>
<p>If you are publishing a plugin crate, here are some recommendations:</p>
<ul>
<li>Use the main branch in your repository for targeting the released version of Bevy</li>
<li>Have a separate branch in your repository, to keep support for bevy main
separate from your version for the released version of bevy</li>
<li>Put information in your README to tell people how to find it</li>
<li>Set up CI to notify you if your plugin is broken by new changes in bevy</li>
</ul>
<p>Feel free to follow all the advice from this page, including cargo patches
as needed. Cargo patches only apply when you build your project directly,
not as a dependency, so they do not affect your users and can be safely kept
in your <code>Cargo.toml</code>.</p>
<h3 id="ci-setup"><a class="header" href="#ci-setup">CI Setup</a></h3>
<p>Here is an example for GitHub Actions. This will run at 8:00 AM (UTC) every day
to verify that your code still compiles. GitHub will notify you when it fails.</p>
<pre><code class="language-yaml">name: check if code still compiles

on:
  schedule:
    - cron: '0 8 * * *'

env:
  CARGO_TERM_COLOR: always

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Install Dependencies
        run: sudo apt-get update &amp;&amp; sudo apt-get install g++ pkg-config libx11-dev libasound2-dev libudev-dev
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Check code
        run: cargo update &amp;&amp; cargo check --lib --examples
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h1>
<p>This chapter covers some common issues or surprises that you might be
likely to encounter when working with Bevy, with specific advice about how
to address them.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-11">0.11</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="strange-build-errors"><a class="header" href="#strange-build-errors">Strange Build Errors</a></h1>
<p>Sometimes, you can get strange and confusing build errors when trying to
compile your project.</p>
<h2 id="update-your-rust"><a class="header" href="#update-your-rust">Update your Rust</a></h2>
<p>First, make sure your Rust is up-to-date. When using Bevy, you must use at
least the latest stable version of Rust (or nightly).</p>
<p>If you are using <a href="https://rustup.rs"><code>rustup</code></a> to manage your Rust installation, you
can run:</p>
<pre><code class="language-shell">rustup update
</code></pre>
<h2 id="clear-the-cargo-state"><a class="header" href="#clear-the-cargo-state">Clear the cargo state</a></h2>
<p>Many kinds of build errors can often be fixed by forcing <code>cargo</code> to regenerate
its internal state (recompute dependencies, etc.). You can do this by deleting
the <code>Cargo.lock</code> file and the <code>target</code> directory.</p>
<pre><code class="language-shell">rm -rf target Cargo.lock
</code></pre>
<p>Try building your project again after doing this. It is likely that the
mysterious errors will go away.</p>
<p>This trick often fixes the broken build, but if it doesn't help you,
your issue might require further investigation. Reach out to the Bevy
community via GitHub or <a href="https://discord.gg/bevy">Discord</a>, and ask for help.</p>
<p>If you are using bleeding-edge Bevy (&quot;main&quot;), and the above does not solve
the problem, your errors might be caused by 3rd-party plugins. See <a href="pitfalls/../setup/bevy-git.html#how-to-use-bleeding-edge-bevy">this
page</a> for solutions.</p>
<h2 id="new-cargo-resolver"><a class="header" href="#new-cargo-resolver">New Cargo Resolver</a></h2>
<p>Cargo recently added a new dependency resolver algorithm, that is incompatible
with the old one. Bevy <em>requires</em> the new resolver.</p>
<p>If you are just creating a new blank Cargo project, don't worry. This should
already be setup correctly by <code>cargo new</code>.</p>
<p>If you are getting weird compiler errors from Bevy dependencies, read on. Make sure
you have the correct configuration, and then <a href="pitfalls//pitfalls/build-errors.html#clear-the-cargo-state">clear the cargo state</a>.</p>
<h3 id="single-crate-projects"><a class="header" href="#single-crate-projects">Single-Crate Projects</a></h3>
<p>In a single-crate project (if you only have one <code>Cargo.toml</code> file in your project),
if you are using the latest Rust2021 Edition, the new resolver is automatically
enabled.</p>
<p>So, you need either one of these settings in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
edition = &quot;2021&quot;
</code></pre>
<p>or</p>
<pre><code class="language-toml">[package]
resolver = &quot;2&quot;
</code></pre>
<h3 id="multi-crate-workspaces"><a class="header" href="#multi-crate-workspaces">Multi-Crate Workspaces</a></h3>
<p>In a multi-crate Cargo workspace, the resolver is a global setting for the
whole workspace. It will <em>not</em> be enabled by default.</p>
<p>This can bite you if you are transitioning a single-crate project into a workspace.</p>
<p>You <em>must</em> add it manually to the top-level <code>Cargo.toml</code> for your Cargo Workspace:</p>
<pre><code class="language-toml">[workspace]
resolver = &quot;2&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="performance"><a class="header" href="#performance">Performance</a></h1>
<h2 id="unoptimized-debug-builds"><a class="header" href="#unoptimized-debug-builds">Unoptimized debug builds</a></h2>
<p>You can partially enable compiler optimizations in debug/dev mode!</p>
<p>You can enable higher optimizations for dependencies (incl. Bevy), but not
your own code, to keep recompilations fast!</p>
<p>In <code>Cargo.toml</code> or <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml"># Enable max optimizations for dependencies, but not for our code:
[profile.dev.package.&quot;*&quot;]
opt-level = 3
</code></pre>
<p>The above is enough to make Bevy run fast. It will only slow down clean
builds, without affecting recompilation times for your project.</p>
<p>If your own code does CPU-intensive work, you might want to also enable some
optimization for it. However, this might greatly affect compile times in some
projects (similar to a full release build), so it is not generally recommended.</p>
<pre><code class="language-toml"># Enable only a small amount of optimization in debug mode
[profile.dev]
opt-level = 1
</code></pre>
<p><strong>Warning!</strong> If you are using a debugger (like <code>gdb</code> or <code>lldb</code>) to step through
your code, any amount of compiler optimization can mess with the experience.
Your breakpoints might be skipped, and the code flow might jump around in
unexpected ways. If you want to debug / step through your code, you might want
<code>opt-level = 0</code>.</p>
<h3 id="why-is-this-necessary"><a class="header" href="#why-is-this-necessary">Why is this necessary?</a></h3>
<p>Rust without compiler optimizations is <em>very slow</em>. With Bevy in
particular, the default cargo build debug settings will lead to <em>awful</em> runtime
performance. Assets are slow to load and FPS is low.</p>
<p>Common symptoms:</p>
<ul>
<li>Loading high-res 3D models with a lot of large textures, from GLTF
files, can take minutes! This can trick you into thinking
that your code is not working, because you will not see anything on
the screen until it is ready.</li>
<li>After spawning even a few 2D sprites or 3D models, framerate may drop
to unplayable levels.</li>
</ul>
<h3 id="why-not-use---release"><a class="header" href="#why-not-use---release">Why not use <code>--release</code>?</a></h3>
<p>You may have heard the advice: just run with <code>--release</code>! However, this is
bad advice. Don't do it.</p>
<p>Release mode also disables &quot;debug assertions&quot;: extra checks useful during
development. Many libraries also include additional stuff under that
setting. In Bevy and WGPU that includes validation for shaders and GPU API
usage. Release mode disables these checks, causing less-informative crashes,
issues with hot-reloading, or potentially buggy/invalid logic going unnoticed.</p>
<p>Release mode also makes incremental recompilation slow. That negates
Bevy's fast compile times, and can be very annoying while you develop.</p>
<hr />
<p>With the advice at the top of this page, you don't need to build with
<code>--release</code>, just to test your game with adequate performance. You can use
it for <em>actual</em> release builds that you send to your users.</p>
<p>If you want, you can also enable LTO (Link-Time-Optimization) for the actual
release builds, to squeeze out even more performance at the cost of very
slow compile times:</p>
<pre><code class="language-toml">[profile.release]
lto = &quot;thin&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-11">0.11</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="obscure-rust-compiler-errors"><a class="header" href="#obscure-rust-compiler-errors">Obscure Rust compiler errors</a></h1>
<p>You can get confusing compiler errors when you try to add <a href="pitfalls//programming/systems.html">systems</a>
to your Bevy <a href="pitfalls//programming/app-builder.html">app</a>.</p>
<h2 id="common-beginner-mistakes"><a class="header" href="#common-beginner-mistakes">Common beginner mistakes</a></h2>
<ul>
<li>Using <code>commands: &amp;mut Commands</code> instead of <code>mut commands: Commands</code>.</li>
<li>Using <code>Query&lt;MyStuff&gt;</code> instead of <code>Query&lt;&amp;MyStuff&gt;</code> or <code>Query&lt;&amp;mut MyStuff&gt;</code>.</li>
<li>Using <code>Query&lt;&amp;ComponentA, &amp;ComponentB&gt;</code> instead of <code>Query&lt;(&amp;ComponentA, &amp;ComponentB)&gt;</code>
(forgetting the tuple)</li>
<li>Using your resource types directly without <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.Res.html"><code>Res</code></a> or <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut</code></a>.</li>
<li>Using your component types directly without putting them in a <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.Query.html"><code>Query</code></a>.</li>
<li>Using a <a href="pitfalls//programming/bundle.html">bundle</a> type in a <a href="pitfalls//programming/queries.html">query</a>. You want individual components.</li>
<li>Using other arbitrary types in your function.</li>
</ul>
<p>Note that <code>Query&lt;Entity&gt;</code> is correct, because the Entity ID is special;
it is not a component.</p>
<h2 id="error-adding-function-as-system"><a class="header" href="#error-adding-function-as-system">Error adding function as system</a></h2>
<p>The errors can look like this:</p>
<pre><code>error[E0277]: the trait bound `for&lt;'a, 'b, 'c&gt; fn(...) {system}: IntoSystem&lt;(), (), _&gt;` is not satisfied
   --&gt; src/main.rs:5:21
    |
5   |         .add_system(my_system)
    |          ---------- ^^^^^^^^^ the trait `IntoSystem&lt;(), (), _&gt;` is not implemented for fn item `for&lt;'a, 'b, 'c&gt; fn(...) {system}`
    |          |
    |          required by a bound introduced by this call
    |
    = help: the following other types implement trait `IntoSystemConfigs&lt;Marker&gt;`:
    = ...
</code></pre>
<p>The error (confusingly) points to the place in your code where you try to add the system,
but in reality, the problem is actually in the <code>fn</code> function definition!</p>
<p>This is caused by your function having invalid parameters. <a href="pitfalls//builtins.html#systemparams">Bevy can
only accept special types as system parameters!</a></p>
<h2 id="error-on-malformed-queries"><a class="header" href="#error-on-malformed-queries">Error on malformed queries</a></h2>
<p>You might also errors that look like this:</p>
<pre><code>error[E0277]: the trait bound `Transform: WorldQuery` is not satisfied
   --&gt; src/main.rs:10:12
    |
10  |     query: Query&lt;Transform&gt;,
    |            ^^^^^^^^^^^^^^^ the trait `WorldQuery` is not implemented for `Transform`
    |
    = help: the following other types implement trait `WorldQuery`:
              &amp;'__w mut T
              &amp;T
              ()
              (F0, F1)
              (F0, F1, F2)
              (F0, F1, F2, F3)
              (F0, F1, F2, F3, F4)
              (F0, F1, F2, F3, F4, F5)
            and 54 others
note: required by a bound in `bevy::prelude::Query`
   --&gt; ~/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bevy_ecs-0.10.0/src/system/query.rs:276:37
    |
276 | pub struct Query&lt;'world, 'state, Q: WorldQuery, F: ReadOnlyWorldQuery = ()&gt; {
    |                                     ^^^^^^^^^^ required by this bound in `Query`
</code></pre>
<p>To access your components, you need to use reference syntax (<code>&amp;</code> or <code>&amp;mut</code>).</p>
<pre><code>error[E0107]: struct takes at most 2 generic arguments but 3 generic arguments were supplied
   --&gt; src/main.rs:10:12
    |
10  |     query: Query&lt;&amp;Transform, &amp;Camera, &amp;GlobalTransform&gt;,
    |            ^^^^^                      ---------------- help: remove this generic argument
    |            |
    |            expected at most 2 generic arguments
    |
note: struct defined here, with at most 2 generic parameters: `Q`, `F`
   --&gt; ~/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bevy_ecs-0.10.0/src/system/query.rs:276:12
    |
276 | pub struct Query&lt;'world, 'state, Q: WorldQuery, F: ReadOnlyWorldQuery = ()&gt; {
    |            ^^^^^                 -              --------------------------
</code></pre>
<p>When you want to query for multiple components, you need to put them in a tuple:
<code>(&amp;Transform, &amp;Camera, &amp;GlobalTransform)</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-11">0.11</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="3d-objects-not-displaying"><a class="header" href="#3d-objects-not-displaying">3D objects not displaying</a></h1>
<p>This page will list some common issues that you may encounter, if you are
trying to spawn a 3D object, but cannot see it on the screen.</p>
<h2 id="missing-visibility-components-on-parent"><a class="header" href="#missing-visibility-components-on-parent">Missing visibility components on parent</a></h2>
<p>If your entity is in a hierarchy, all its parents need to have
<a href="pitfalls//fundamentals/visibility.html">visibility</a> components. It is required even if those parent
entities are not supposed to render anything.</p>
<p>Fix it by inserting a <a href="https://docs.rs/bevy/0.11.0/bevy/render/view/visibility/struct.VisibilityBundle.html"><code>VisibilityBundle</code></a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>commands.entity(parent)
    .insert(VisibilityBundle::default());
<span class="boring">}</span></code></pre></pre>
<p>Or better, make sure to spawn the parent entities correctly in the first place.
You can use a <a href="https://docs.rs/bevy/0.11.0/bevy/render/view/visibility/struct.VisibilityBundle.html"><code>VisibilityBundle</code></a> or
<a href="https://docs.rs/bevy/0.11.0/bevy/render/prelude/struct.SpatialBundle.html"><code>SpatialBundle</code></a> (with <a href="pitfalls//fundamentals/transforms.html">transforms</a>) if you
are not using a bundle that already includes these components.</p>
<h2 id="too-far-from-camera"><a class="header" href="#too-far-from-camera">Too far from camera</a></h2>
<p>If something is further away than a certain distance from the camera, it will be
culled (not rendered). The default value is <code>1000.0</code> units.</p>
<p>You can control this using the <code>far</code> field of
<a href="https://docs.rs/bevy/0.11.0/bevy/render/camera/struct.PerspectiveProjection.html"><code>PerspectiveProjection</code></a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>commands.spawn(Camera3dBundle {
    projection: Projection::Perspective(PerspectiveProjection {
        far: 10000.0, // change the maximum render distance
        ..default()
    }),
    ..default()
});
<span class="boring">}</span></code></pre></pre>
<h2 id="missing-vertex-attributes"><a class="header" href="#missing-vertex-attributes">Missing Vertex Attributes</a></h2>
<p>Make sure your <a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a> includes all vertex attributes required
by your shader/material.</p>
<p>Bevy's default PBR <a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a>
requires <em>all</em> meshes to have:</p>
<ul>
<li>Positions</li>
<li>Normals</li>
</ul>
<p>Some others that may be required:</p>
<ul>
<li>UVs (if using textures in the material)</li>
<li>Tangents (only if using normal maps, otherwise not required)</li>
</ul>
<p>If you are generating your own mesh data, make sure to provide everything
you need.</p>
<p>If you are loading meshes from asset files, make sure they include everything
that is needed (check your export settings).</p>
<p>If you need Tangents for normal maps, it is recommended that you include them
in your GLTF files. This avoids Bevy having to autogenerate them at runtime.
Many 3D editors (like Blender) do not enable this option by default.</p>
<h2 id="incorrect-usage-of-bevy-gltf-assets"><a class="header" href="#incorrect-usage-of-bevy-gltf-assets">Incorrect usage of Bevy GLTF assets</a></h2>
<p>Refer to the <a href="pitfalls//3d/gltf.html">GLTF page</a> to learn how to correctly
use GLTF with Bevy.</p>
<p>GLTF files are complex. They contain many sub-assets, represented by
different Bevy types. Make sure you are using the correct thing.</p>
<p>Make sure you are spawning a GLTF Scene, or using the correct
<a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a> and <a href="https://docs.rs/bevy/0.11.0/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a>
associated with the correct GLTF Primitive.</p>
<p>If you are using an asset path, be sure to include a label for the sub-asset you want:</p>
<pre><code class="language-rust no_run noplayground">let handle_scene: Handle&lt;Scene&gt; = asset_server.load(&quot;my.gltf#Scene0&quot;);</code></pre>
<p>If you are spawning the top-level <a href="https://docs.rs/bevy/0.11.0/bevy/gltf/struct.Gltf.html"><code>Gltf</code></a> <a href="pitfalls//3d/gltf.html#gltf-master-asset">master asset</a>, it won't work.</p>
<p>If you are spawning a GLTF Mesh, it won't work.</p>
<h2 id="unsupported-gltf"><a class="header" href="#unsupported-gltf">Unsupported GLTF</a></h2>
<p>Bevy does not fully support all features of the GLTF format and has some
specific requirements about the data. Not all GLTF files can be loaded and
rendered in Bevy. Unfortunately, in many of these cases, you will not get
any error or diagnostic message.</p>
<p>Commonly-encountered limitations:</p>
<ul>
<li>Textures embedded in ascii (<code>*.gltf</code>) files (base64 encoding) cannot be loaded.
Put your textures in external files, or use the binary (<code>*.glb</code>) format.</li>
<li>Mipmaps are only supported if the texture files (in KTX2 or DDS format) contain them.
The GLTF spec requires missing mipmap data to be generated by the game engine, but Bevy
does not support this yet. If your assets are missing mipmaps, textures will look grainy/noisy.</li>
</ul>
<p>This list is not exhaustive. There may be other unsupported scenarios that I
did not know of or forgot to include here. :)</p>
<h2 id="vertex-order-and-culling"><a class="header" href="#vertex-order-and-culling">Vertex Order and Culling</a></h2>
<p>By default, the Bevy renderer assumes Counter-Clockwise vertex order and has
back-face culling enabled.</p>
<p>If you are generating your <a href="https://docs.rs/bevy/0.11.0/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a> from code, make sure your
vertices are in the correct order.</p>
<h2 id="unoptimized--debug-builds"><a class="header" href="#unoptimized--debug-builds">Unoptimized / Debug builds</a></h2>
<p>Maybe your asset just takes a while to load? Bevy is very slow without
compiler optimizations. It's actually possible that complex GLTF files with
big textures can take over a minute to load and show up on the screen. It
would be almost instant in optimized builds. <a href="pitfalls//pitfalls/performance.html">See here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="borrow-multiple-fields-from-struct"><a class="header" href="#borrow-multiple-fields-from-struct">Borrow multiple fields from struct</a></h1>
<p>When you have a <a href="pitfalls//programming/ec.html#components">component</a> or <a href="pitfalls//programming/res.html">resource</a>, that is
larger struct with multiple fields, sometimes you want to borrow several of
the fields at the same time, possibly mutably.</p>
<pre><code class="language-rust no_run noplayground">struct MyThing {
    a: Foo,
    b: Bar,
}

fn my_system(mut q: Query&lt;&amp;mut MyThing&gt;) {
    for thing in q.iter_mut() {
        helper_func(&amp;thing.a, &amp;mut thing.b); // ERROR!
    }
}

fn helper_func(foo: &amp;Foo, bar: &amp;mut Bar) {
    // do something
}</code></pre>
<p>This can result in a compiler error about conflicting borrows:</p>
<pre><code>error[E0502]: cannot borrow `thing` as mutable because it is also borrowed as immutable
    |
    |         helper_func(&amp;thing.a, &amp;mut thing.b); // ERROR!
    |         -----------  -----         ^^^^^ mutable borrow occurs here
    |         |            |
    |         |            immutable borrow occurs here
    |         immutable borrow later used by call
</code></pre>
<p>The solution is to use the &quot;reborrow&quot; idiom, a common but non-obvious trick in Rust programming:</p>
<pre><code class="language-rust no_run noplayground">// add this at the start of the for loop, before using `thing`:
let thing = &amp;mut *thing;

// or, alternatively, Bevy provides a method, which does the same:
let thing = thing.into_inner();</code></pre>
<p>Note that this line triggers <a href="pitfalls//programming/change-detection.html">change detection</a>. Even if
you don't modify the data afterwards, the component gets marked as changed.</p>
<h2 id="explanation"><a class="header" href="#explanation">Explanation</a></h2>
<p>Bevy typically gives you access to your data via special wrapper types (like
[<code>Res&lt;T&gt;</code>][bevy::Res], [<code>ResMut&lt;T&gt;</code>][bevy::ResMut], and [<code>Mut&lt;T&gt;</code>][bevy::Mut]
(when <a href="pitfalls//programming/queries.html">querying</a> for components mutably)). This lets Bevy track
access to the data.</p>
<p>These are &quot;smart pointer&quot; types that use the Rust <a href="https://doc.rust-lang.org/stable/std/ops/trait.Deref.html"><code>Deref</code></a>
trait to dereference to your data. They usually work seamlessly and you
don't even notice them.</p>
<p>However, in a sense, they are opaque to the compiler. The Rust language
allows fields of a struct to be borrowed individually, when you have direct
access to the struct, but this does not work when it is wrapped in another type.</p>
<p>The &quot;reborrow&quot; trick shown above, effectively converts the wrapper
into a regular Rust reference. <code>*thing</code> dereferences the wrapper via
<a href="https://doc.rust-lang.org/stable/std/ops/trait.DerefMut.html"><code>DerefMut</code></a>, and then <code>&amp;mut</code> borrows it mutably. You now have
<code>&amp;mut MyStuff</code> instead of <code>Mut&lt;MyStuff&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-11">0.11</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="bevy-time-vs-rustos-time"><a class="header" href="#bevy-time-vs-rustos-time">Bevy Time vs. Rust/OS time</a></h1>
<p>Do <em>not</em> use <a href="https://doc.rust-lang.org/stable/std/time/struct.Instant.html"><code>std::time::Instant::now()</code></a> to get the
current time. <a href="pitfalls//fundamentals/time.html">Get your timing information from Bevy</a>, using
<a href="https://docs.rs/bevy/0.11.0/bevy/time/struct.Time.html"><code>Res&lt;Time&gt;</code></a>.</p>
<p>Rust (and the OS) give you the precise time of the moment you call that
function. However, that's not what you want.</p>
<p>Your game systems are run by Bevy's parallel scheduler, which means that they
could be called at vastly different instants every frame! This will result in
inconsistent / jittery timings and make your game misbehave or look stuttery.</p>
<p>Bevy's <a href="https://docs.rs/bevy/0.11.0/bevy/time/struct.Time.html"><code>Time</code></a> gives you timing information that is consistent
throughout the frame update cycle. It is intended to be used for game logic.</p>
<p>This is not Bevy-specific, but applies to game development in general. Always
get your time from your game engine, not from your programming language or
operating system.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="pitfalls//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-11">0.11</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="uv-coordinates-in-bevy"><a class="header" href="#uv-coordinates-in-bevy">UV coordinates in Bevy</a></h1>
<p>In Bevy, the vertical axis for the pixels of textures / images, and when
sampling textures in a shader, points <em>downwards</em>, from top to bottom. The
origin is at the top left.</p>
<p>This is inconsistent with the <a href="pitfalls//fundamentals/coords.html">World-coordinate system used everywhere else
in Bevy</a>, where the Y axis points up.</p>
<p>It is, however, consistent with how most image file formats store pixel data,
and with how most graphics APIs work (including DirectX, Vulkan, Metal,
WebGPU, but <em>not</em> OpenGL).</p>
<p>OpenGL (and frameworks based on it) is different. If your prior experience
is with that, you may find that your textures appear flipped vertically.</p>
<hr />
<p>If you are using a mesh, make sure it has the correct UV values. If it was
created with other software, be sure to select the correct settings.</p>
<p>If you are writing a custom shader, make sure your UV arithmetic is correct.</p>
<h2 id="sprites"><a class="header" href="#sprites">Sprites</a></h2>
<p>If the images of your 2D sprites are flipped (for whatever reason), you can
correct that using Bevy's sprite-flipping feature:</p>
<pre><code class="language-rust no_run noplayground">commands.spawn(SpriteBundle {
    sprite: Sprite {
        flip_y: true,
        flip_x: false,
        ..Default::default()
    },
    ..Default::default()
});</code></pre>
<h2 id="quads"><a class="header" href="#quads">Quads</a></h2>
<p>If you want to display an image (or custom shader) on a <a href="https://docs.rs/bevy/0.11.0/bevy/prelude/shape/struct.Quad.html"><code>Quad</code></a>
mesh, you can flip it vertically as follows:</p>
<pre><code class="language-rust no_run noplayground">let size = Vec2::new(2.0, 3.0);
let my_quad = shape::Quad::flipped(-size);</code></pre>
<p>(this workaround is necessary, because the <code>flipped</code> feature of Bevy's
<a href="https://docs.rs/bevy/0.11.0/bevy/prelude/shape/struct.Quad.html"><code>Quad</code></a> primitive only does a horizonal flip, but we want a vertical flip)</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="game-engine-fundamentals"><a class="header" href="#game-engine-fundamentals">Game Engine Fundamentals</a></h1>
<p>This chapter covers the fundamentals of using Bevy as a game engine.</p>
<p>You are expected to be familiar with Bevy programming in general. For that,
see the <a href="/programming.html">Bevy Programming Framework</a> chapter.</p>
<p>The topics covered in this chapter are applicable to all projects that want
to use Bevy as more than just an ECS library. If you are making a game or
other app using Bevy, this is for you.</p>
<p>This chapter only covers the general fundamentals. Complex topics that
deserve more extensive coverage have their own chapters in the book:</p>
<ul>
<li><a href="/input.html">Input Handling</a></li>
<li><a href="/window.html">Window Management</a></li>
<li><a href="/assets.html">Asset Management</a></li>
<li><a href="/graphics.html">General Graphics Features</a></li>
<li><a href="/2d.html">2D Graphics</a></li>
<li><a href="/3d.html">3D Graphics</a></li>
<li><a href="/audio.html">Audio</a></li>
<li><a href="/ui.html">Bevy UI Framework</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="coordinate-system"><a class="header" href="#coordinate-system">Coordinate System</a></h1>
<h2 id="2d-and-3d-scenes-and-cameras"><a class="header" href="#2d-and-3d-scenes-and-cameras">2D and 3D scenes and cameras</a></h2>
<p>Bevy uses a right-handed Y-up coordinate system for the game world. The
coordinate system is the same for 3D and 2D, for consistency.</p>
<p>It is easiest to explain in terms of 2D:</p>
<ul>
<li>The X axis goes from left to right (+X points right).</li>
<li>The Y axis goes from bottom to top (+Y points up).</li>
<li>The Z axis goes from far to near (+Z points towards you, out of the screen).</li>
<li>For 2D, the origin (X=0.0; Y=0.0) is at the <em>center of the screen</em> by default.</li>
</ul>
<p>When you are working with 2D sprites, you can put the background on Z=0.0, and
place other sprites at increasing positive Z coordinates to layer them on top.</p>
<p>In 3D, the axes are oriented the same way:</p>
<ul>
<li>Y points up</li>
<li>The forward direction is -Z</li>
</ul>
<p>This is a right-handed coordinate system. You can use the fingers of your right
hand to visualize the 3 axes: thumb=X, index=Y, middle=Z.</p>
<p>It is the same as Godot, Maya, and OpenGL. Compared to Unity, the Z axis
is inverted.</p>
<p><img src="fundamentals//img/handedness.png" alt="Chart comparing coordinate system orientation in different game engines and 3D software" /></p>
<p>(graphic modifed and used with permission; original by <a href="https://twitter.com/FreyaHolmer">@FreyaHolmer</a>)</p>
<h2 id="ui"><a class="header" href="#ui">UI</a></h2>
<p>For UI, Bevy follows the same convention as most other UI toolkits, the Web, etc.</p>
<ul>
<li>The origin is at the top left corner of the screen</li>
<li>The Y axis points downwards</li>
<li>X goes from 0.0 (left screen edge) to the number of screen pixels (right screen edge)</li>
<li>Y goes from 0.0 (top screen edge) to the number of screen pixels (bottom screen edge)</li>
</ul>
<p>The units represent logical (compensated for DPI scaling) screen pixels.</p>
<p>UI layout flows from top to bottom, similar to a web page.</p>
<h2 id="cursor-and-screen"><a class="header" href="#cursor-and-screen">Cursor and Screen</a></h2>
<p>The cursor position and any other window (screen-space) coordinates follow the same
conventions as UI, as described above.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="transforms"><a class="header" href="#transforms">Transforms</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/main/examples/transforms/transform.rs"><code>transform</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/main/examples/transforms/translation.rs"><code>translation</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/main/examples/2d/rotation.rs"><code>rotation</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/main/examples/transforms/3d_rotation.rs"><code>3d_rotation</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/main/examples/transforms/scale.rs"><code>scale</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/main/examples/2d/move_sprite.rs"><code>move_sprite</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/main/examples/3d/parenting.rs"><code>parenting</code></a>,
anything that spawns 2D or 3D objects.</p>
<hr />
<p>First, a quick definition, if you are new to game development:</p>
<p>a Transform is what allows you to place an object in the game world. It
is a combination of the object's &quot;translation&quot; (position/coordinates),
&quot;rotation&quot;, and &quot;scale&quot; (size adjustment).</p>
<p>You move objects around by modifying the translation, rotate them by modifying
the rotation, and make them larger or smaller by modifying the scale.</p>
<pre><code class="language-rust no_run noplayground">// To simply position something at specific coordinates
let xf_pos567 = Transform::from_xyz(5.0, 6.0, 7.0);

// To scale an object, making it twice as big in all dimensions
let xf_scale = Transform::from_scale(Vec3::splat(2.0));

// To rotate an object in 2D (Z-axis rotation) by 30¬∞
// (angles are in radians! must convert from degrees!)
let xf_rot2d = Transform::from_rotation(Quat::from_rotation_z((30.0_f32).to_radians()));

// 3D rotations can be complicated; explore the methods available on `Quat`

// Simple 3D rotation by Euler-angles (X, Y, Z)
let xf_rot2d = Transform::from_rotation(Quat::from_euler(
    EulerRot::XYZ,
    (20.0_f32).to_radians(),
    (10.0_f32).to_radians(),
    (30.0_f32).to_radians(),
));

// Everything:
let xf = Transform::from_xyz(1.0, 2.0, 3.0)
    .with_scale(Vec3::new(0.5, 0.5, 1.0))
    .with_rotation(Quat::from_rotation_y(0.125 * std::f32::consts::PI));</code></pre>
<h2 id="transform-components"><a class="header" href="#transform-components">Transform Components</a></h2>
<p>In Bevy, transforms are represented by <strong>two</strong> <a href="fundamentals//programming/ec.html#components">components</a>:
<a href="https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> and <a href="https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a>.</p>
<p>Any <a href="fundamentals//programming/ecs-intro.html">Entity</a> that represents an object in the game world
needs to have both. All of Bevy's <a href="fundamentals//builtins.html#bundles">built-in bundle types</a>
include them.</p>
<p>If you are creating a custom entity without using those <a href="fundamentals//programming/bundle.html">bundles</a>,
you can use one of the following to ensure you don't miss them:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.12.0/bevy/render/prelude/struct.SpatialBundle.html"><code>SpatialBundle</code></a> for transforms + <a href="fundamentals//fundamentals/visibility.html">visibility</a></li>
<li><a href="https://docs.rs/bevy/0.12.0/bevy/transform/struct.TransformBundle.html"><code>TransformBundle</code></a> for just the transforms</li>
</ul>
<pre><code class="language-rust no_run noplayground">fn spawn_special_entity(
    mut commands: Commands,
) {
    // create an entity that does not use one of the common Bevy bundles,
    // but still needs transforms and visibility
    commands.spawn((
        ComponentA,
        ComponentB,
        SpatialBundle {
            transform: Transform::from_scale(Vec3::splat(3.0)),
            visibility: Visibility::Hidden,
            ..Default::default()
        },
    ));
}</code></pre>
<h3 id="transform"><a class="header" href="#transform"><code>Transform</code></a></h3>
<p><a href="https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> is what you typically work with. It is
a <code>struct</code> containing the translation, rotation, and scale. To read or
manipulate these values, access it from your <a href="fundamentals//programming/systems.html">systems</a> using a
<a href="fundamentals//programming/queries.html">query</a>.</p>
<p>If the entity has a <a href="fundamentals//fundamentals/hierarchy.html">parent</a>, the <a href="https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>
component is relative to the parent. This means that the child object will
move/rotate/scale along with the parent.</p>
<pre><code class="language-rust no_run noplayground">fn inflate_balloons(
    mut query: Query&lt;&amp;mut Transform, With&lt;Balloon&gt;&gt;,
    keyboard: Res&lt;Input&lt;KeyCode&gt;&gt;,
) {
    // every time the Spacebar is pressed,
    // make all the balloons in the game bigger by 25%
    if keyboard.just_pressed(KeyCode::Space) {
        for mut transform in &amp;mut query {
            transform.scale *= 1.25;
        }
    }
}

fn throwable_fly(
    time: Res&lt;Time&gt;,
    mut query: Query&lt;&amp;mut Transform, With&lt;ThrowableProjectile&gt;&gt;,
) {
    // every frame, make our projectiles fly across the screen and spin
    for mut transform in &amp;mut query {
        // do not forget to multiply by the time delta!
        // this is required to move at the same speed regardless of frame rate!
        transform.translation.x += 100.0 * time.delta_seconds();
        transform.rotate_z(2.0 * time.delta_seconds());
    }
}</code></pre>
<h3 id="globaltransform"><a class="header" href="#globaltransform"><code>GlobalTransform</code></a></h3>
<p><a href="https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> represents the absolute global
position in the world.</p>
<p>If the entity does not have a <a href="fundamentals//fundamentals/hierarchy.html">parent</a>, then this will match
the <a href="https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>.</p>
<p>The value of <a href="https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> is calculated/managed
internally by Bevy (<a href="fundamentals/transforms.html#transform-propagation">&quot;transform propagation&quot;</a>).</p>
<p>Unlike <a href="https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>, the translation/rotation/scale are not
accessible directly. The data is stored in an optimized way (using <code>Affine3A</code>)
and it is possible to have complex transformations in a hierarchy that cannot
be represented as a simple transform. For example, a combination of rotation
and scale across multiple parents, resulting in shearing.</p>
<p>If you want to try to convert a <a href="https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> back
into a workable translation/rotation/scale representation, you can try the methods:</p>
<ul>
<li><code>.translation()</code></li>
<li><code>.to_scale_rotation_translation()</code> (may be invalid)</li>
<li><code>.compute_transform()</code> (may be invalid)</li>
</ul>
<h2 id="transform-propagation"><a class="header" href="#transform-propagation">Transform Propagation</a></h2>
<p>The two components are synchronized by a bevy-internal system (the &quot;transform
propagation system&quot;), which runs in the <a href="https://docs.rs/bevy/0.12.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a>
<a href="fundamentals//programming/schedules.html">schedule</a>.</p>
<p>Beware: When you mutate the <a href="https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>, the
<a href="https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> is not updated immediately. They
will be out-of-sync until the transform propagation system runs.</p>
<p>If you need to work with <a href="https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a>
directly, you should <a href="fundamentals//programming/app-builder.html">add</a> your
<a href="fundamentals//programming/systems.html">system</a> to the <a href="https://docs.rs/bevy/0.12.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a>
<a href="fundamentals//programming/schedules.html">schedule</a> and <a href="fundamentals//programming/system-order.html">order it after</a>
<a href="https://docs.rs/bevy/0.12.0/bevy/transform/enum.TransformSystem.html"><code>TransformSystem::TransformPropagate</code></a>.</p>
<pre><code class="language-rust no_run noplayground">/// Print the up-to-date global coordinates of the player
fn debug_globaltransform(
    query: Query&lt;&amp;GlobalTransform, With&lt;Player&gt;&gt;,
) {
    let gxf = query.single();
    debug!(&quot;Player at: {:?}&quot;, gxf.translation());
}</code></pre>
<pre><code class="language-rust no_run noplayground">// the label to use for ordering
use bevy::transform::TransformSystem;

app.add_systems(PostUpdate,
    debug_globaltransform
        // we want to read the GlobalTransform after
        // it has been updated by Bevy for this frame
        .after(TransformSystem::TransformPropagate)
);</code></pre>
<h2 id="transformhelper"><a class="header" href="#transformhelper"><code>TransformHelper</code></a></h2>
<p>If you need to get an up-to-date <a href="https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a>
in a <a href="fundamentals//programming/systems.html">system</a> that has to run before transform propagation,
you can use the special <a href="https://docs.rs/bevy/0.12.0/bevy/transform/helper/struct.TransformHelper.html"><code>TransformHelper</code></a> system parameter.</p>
<p>It allows you to compute a specific entity's
<a href="https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> immediately, on demand.</p>
<p>An example of where this could be useful might be a system to make
a camera follow an entity on-screen. You need to update the camera's
<a href="https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> (which means you have to do it before Bevy's
transform propagation, so it can account for the camera's new transform),
but you also need to know the current up-to-date position of the entity you
are following.</p>
<pre><code class="language-rust no_run noplayground">fn camera_look_follow(
    q_target: Query&lt;Entity, With&lt;MySpecialMarker&gt;&gt;,
    mut transform_params: ParamSet&lt;(
        TransformHelper,
        Query&lt;&amp;mut Transform, With&lt;MyGameCamera&gt;&gt;,
    )&gt;,
) {
    // get the Entity ID we want to target
    let e_target = q_target.single();
    // compute its actual current GlobalTransform
    // (could be Err if entity doesn't have transforms)
    let Ok(global) = transform_params.p0().compute_global_transform(e_target) else {
        return;
    };
    // get camera transform and make it look at the global translation
    transform_params.p1().single_mut().look_at(global.translation(), Vec3::Y);
}</code></pre>
<p>Internally, <a href="https://docs.rs/bevy/0.12.0/bevy/transform/helper/struct.TransformHelper.html"><code>TransformHelper</code></a> behaves like two
read-only <a href="fundamentals//programming/queries.html">queries</a>. It needs access to the <a href="https://docs.rs/bevy/0.12.0/bevy/hierarchy/struct.Parent.html"><code>Parent</code></a>
and <a href="https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> components to do its job. It would
conflict with our other <code>&amp;mut Transform</code> query. That's why we have to use a
<a href="fundamentals//programming/paramset.html">param set</a> in the example above.</p>
<p>Note: if you over-use <a href="https://docs.rs/bevy/0.12.0/bevy/transform/helper/struct.TransformHelper.html"><code>TransformHelper</code></a>, it
could become a performance issue. It calculates the global transform
for you, but it does not update the data stored in the entity's
<a href="https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a>. Bevy will still do the same
computation again later, during transform propagation. It leads to repetitive
work. If your system can run after transform propagation, so it can just
read the value after Bevy updates it, you should prefer to do that instead
of using <a href="https://docs.rs/bevy/0.12.0/bevy/transform/helper/struct.TransformHelper.html"><code>TransformHelper</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="visibility"><a class="header" href="#visibility">Visibility</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/main/examples/3d/parenting.rs"><code>parenting</code></a>.</p>
<hr />
<p>Visibility is used to control if something is to be rendered or not. If you
want an entity to exist in the world, just not be displayed, you can hide it.</p>
<pre><code class="language-rust no_run noplayground">/// Prepare the game map, but do not display it until later
fn setup_map_hidden(
    mut commands: Commands,
) {
    commands.spawn((
        GameMapEntity,
        SceneBundle {
            scene: todo!(),
            visibility: Visibility::Hidden,
            ..Default::default()
        },
    ));
}

/// When everything is ready, un-hide the game map
fn reveal_map(
    mut query: Query&lt;&amp;mut Visibility, With&lt;GameMapEntity&gt;&gt;,
) {
    let mut vis_map = query.single_mut();
    *vis_map = Visibility::Visible;
}</code></pre>
<h2 id="visibility-components"><a class="header" href="#visibility-components">Visibility Components</a></h2>
<p>In Bevy, visibility is represented by <strong>multiple</strong> <a href="fundamentals//programming/ec.html#components">components</a>:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.12.0/bevy/render/view/enum.Visibility.html"><code>Visibility</code></a>: the user-facing toggle (here is where you set what you want)</li>
<li><a href="https://docs.rs/bevy/0.12.0/bevy/render/view/struct.InheritedVisibility.html"><code>InheritedVisibility</code></a>: used by Bevy to keep track of the state from any <a href="fundamentals//fundamentals/hierarchy.html">parent entities</a></li>
<li><a href="https://docs.rs/bevy/0.12.0/bevy/render/view/struct.ViewVisibility.html"><code>ViewVisibility</code></a>: used by Bevy to track if the entity should actually be displayed</li>
</ul>
<p>Any <a href="fundamentals//programming/ecs-intro.html">Entity</a> that represents a renderable object in
the game world needs to have them all. All of Bevy's <a href="fundamentals//builtins.html#bundles">built-in bundle
types</a> include them.</p>
<p>If you are creating a custom entity without using those <a href="fundamentals//programming/bundle.html">bundles</a>,
you can use one of the following to ensure you don't miss them:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.12.0/bevy/render/prelude/struct.SpatialBundle.html"><code>SpatialBundle</code></a> for <a href="fundamentals//fundamentals/transforms.html">transforms</a> + visibility</li>
<li><a href="https://docs.rs/bevy/0.12.0/bevy/render/view/visibility/struct.VisibilityBundle.html"><code>VisibilityBundle</code></a> for just visibility</li>
</ul>
<pre><code class="language-rust no_run noplayground">fn spawn_special_entity(
    mut commands: Commands,
) {
    // create an entity that does not use one of the common Bevy bundles,
    // but still needs transforms and visibility
    commands.spawn((
        ComponentA,
        ComponentB,
        SpatialBundle {
            transform: Transform::from_scale(Vec3::splat(3.0)),
            visibility: Visibility::Hidden,
            ..Default::default()
        },
    ));
}</code></pre>
<p>If you don't do this correctly (say, you manually add just the <code>Visibility</code>
component and forget the others, because you don't use a bundle), your
entities will not render!</p>
<h3 id="visibility-1"><a class="header" href="#visibility-1"><code>Visibility</code></a></h3>
<p><a href="https://docs.rs/bevy/0.12.0/bevy/render/view/enum.Visibility.html"><code>Visibility</code></a> is the &quot;user-facing toggle&quot;. This is where
you specify what you want for the current entity:</p>
<ul>
<li><code>Inherited</code> (default): show/hide depending on <a href="fundamentals//fundamentals/hierarchy.html">parent</a></li>
<li><code>Visible</code>: always show the entity, regardless of parent</li>
<li><code>Hidden</code>: always hide the entity, regardless of parent</li>
</ul>
<p>If the current entity has any <a href="fundamentals//fundamentals/hierarchy.html">children</a> that have <code>Inherited</code>,
their visibility will be affected if you set the current entity to <code>Visible</code>
or <code>Hidden</code>.</p>
<p>If an entity has a parent, but the parent entity is missing the
visibility-related components, things will behave as if there was no parent.</p>
<h3 id="inheritedvisibility"><a class="header" href="#inheritedvisibility"><code>InheritedVisibility</code></a></h3>
<p><a href="https://docs.rs/bevy/0.12.0/bevy/render/view/struct.InheritedVisibility.html"><code>InheritedVisibility</code></a> represents the state the
current entity would have based on its <a href="fundamentals//fundamentals/hierarchy.html">parent</a>'s visibility.</p>
<p>The value of <a href="https://docs.rs/bevy/0.12.0/bevy/render/view/struct.InheritedVisibility.html"><code>InheritedVisibility</code></a> should
be considered read-only. It is managed internally by Bevy, in a manner
similar to <a href="fundamentals//fundamentals/transforms.html#transform-propagation">transform propagation</a>. A &quot;visibility
propagation&quot; <a href="fundamentals//programming/systems.html">system</a> runs in the <a href="https://docs.rs/bevy/0.12.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a>
<a href="fundamentals//programming/schedules.html">schedule</a>.</p>
<p>If you want to read the up-to-date value for the current frame, you should
<a href="fundamentals//programming/app-builder.html">add</a> your <a href="fundamentals//programming/systems.html">system</a> to the <a href="https://docs.rs/bevy/0.12.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a>
<a href="fundamentals//programming/schedules.html">schedule</a> and <a href="fundamentals//programming/system-order.html">order it after</a>
<a href="https://docs.rs/bevy/0.12.0/bevy/render/view/visibility/enum.VisibilitySystems.html"><code>VisibilitySystems::VisibilityPropagate</code></a>.</p>
<pre><code class="language-rust no_run noplayground">/// Check if a specific UI button is visible
/// (could be hidden if the whole menu is hidden?)
fn debug_player_visibility(
    query: Query&lt;&amp;InheritedVisibility, With&lt;MyAcceptButton&gt;&gt;,
) {
    let vis = query.single();

    debug!(&quot;Button visibility: {:?}&quot;, vis.get());
}</code></pre>
<pre><code class="language-rust no_run noplayground">use bevy::render::view::VisibilitySystems;

app.add_systems(PostUpdate,
    debug_player_visibility
        .after(VisibilitySystems::VisibilityPropagate)
);</code></pre>
<h3 id="viewvisibility"><a class="header" href="#viewvisibility"><code>ViewVisibility</code></a></h3>
<p><a href="https://docs.rs/bevy/0.12.0/bevy/render/view/struct.ViewVisibility.html"><code>ViewVisibility</code></a> represents the actual final
decision made by Bevy about whether this entity needs to be rendered.</p>
<p>The value of <a href="https://docs.rs/bevy/0.12.0/bevy/render/view/struct.ViewVisibility.html"><code>ViewVisibility</code></a> is read-only. It
is managed internally by Bevy.</p>
<p>It is used for &quot;culling&quot;: if the entity is not in the range of
any Camera or Light, it does not need to be rendered, so Bevy will hide it
to improve performance.</p>
<p>Every frame, after &quot;visibility propagation&quot;, Bevy will check what entities
can be seen by what view (camera or light), and store the outcome in these
components.</p>
<p>If you want to read the up-to-date value for the current frame, you should
<a href="fundamentals//programming/app-builder.html">add</a> your <a href="fundamentals//programming/systems.html">system</a> to the <a href="https://docs.rs/bevy/0.12.0/bevy/app/struct.PostUpdate.html"><code>PostUpdate</code></a>
<a href="fundamentals//programming/schedules.html">schedule</a> and <a href="fundamentals//programming/system-order.html">order it after</a>
<a href="https://docs.rs/bevy/0.12.0/bevy/render/view/visibility/enum.VisibilitySystems.html"><code>VisibilitySystems::CheckVisibility</code></a>.</p>
<pre><code class="language-rust no_run noplayground">/// Check if balloons are seen by any Camera, Light, etc‚Ä¶ (not culled)
fn debug_balloon_visibility(
    query: Query&lt;&amp;ViewVisibility, With&lt;Balloon&gt;&gt;,
) {
    for vis in query.iter() {
        if vis.get() {
            debug!(&quot;Balloon will be rendered.&quot;);
        }
    }
}</code></pre>
<pre><code class="language-rust no_run noplayground">use bevy::render::view::VisibilitySystems;

app.add_systems(PostUpdate,
    debug_balloon_visibility
        .after(VisibilitySystems::CheckVisibility)
);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="time-and-timers"><a class="header" href="#time-and-timers">Time and Timers</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/ecs/timers.rs"><code>timers</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/2d/move_sprite.rs"><code>move_sprite</code></a>.</p>
<hr />
<h2 id="time"><a class="header" href="#time">Time</a></h2>
<p>The <a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Time.html"><code>Time</code></a> <a href="fundamentals//programming/res.html">resource</a> is your main global source
of timing information, that you can access from any <a href="fundamentals//programming/systems.html">system</a>
that does anything that needs time. <a href="fundamentals//pitfalls/time.html">You should derive all timings from
it</a>.</p>
<p>Bevy updates these values at the beginning of every frame.</p>
<h3 id="delta-time"><a class="header" href="#delta-time">Delta Time</a></h3>
<p>The most common use case is &quot;delta time&quot; ‚Äì how much time passed between
the previous frame update and the current one. This tells you how fast the
game is running, so you can scale things like movement and animations. This
way everything can happen smoothly and run at the same speed, regardless of
the game's frame rate.</p>
<pre><code class="language-rust no_run noplayground">fn asteroids_fly(
    time: Res&lt;Time&gt;,
    mut q: Query&lt;&amp;mut Transform, With&lt;Asteroid&gt;&gt;,
) {
    for mut transform in q.iter_mut() {
        // move our asteroids along the X axis
        // at a speed of 10.0 units per second
        transform.translation.x += 10.0 * time.delta_seconds();
    }
}</code></pre>
<h3 id="ongoing-time"><a class="header" href="#ongoing-time">Ongoing Time</a></h3>
<p><a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Time.html"><code>Time</code></a> can also give you the total running time since startup.
Use this if you need a cumulative, increasing, measurement of time.</p>
<pre><code class="language-rust no_run noplayground">use std::time::Instant;

/// Say, for whatever reason, we want to keep track
/// of when exactly some specific entities were spawned.
#[derive(Component)]
struct SpawnedTime(Instant);

fn spawn_my_stuff(
    mut commands: Commands,
    time: Res&lt;Time&gt;,
) {
    commands.spawn((/* ... */))
        // we can use startup time and elapsed duration
        .insert(SpawnedTime(time.startup() + time.elapsed()))
        // or just the time of last update
        .insert(SpawnedTime(time.last_update().unwrap()));
}</code></pre>
<h2 id="timers-and-stopwatches"><a class="header" href="#timers-and-stopwatches">Timers and Stopwatches</a></h2>
<p>There are also facilities to help you track specific intervals or timings:
<a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Timer.html"><code>Timer</code></a> and <a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Stopwatch.html"><code>Stopwatch</code></a>. You can create
many instances of these, to track whatever you want. You can use them in
your own <a href="fundamentals//programming/ec.html#components">component</a> or <a href="fundamentals//programming/res.html">resource</a> types.</p>
<p>Timers and Stopwatches need to be ticked. You need to have some system
calling <code>.tick(delta)</code>, for it to make progress, or it will be inactive.
The delta should come from the <a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Time.html"><code>Time</code></a> resource.</p>
<h3 id="timer"><a class="header" href="#timer">Timer</a></h3>
<p><a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Timer.html"><code>Timer</code></a> allows you to detect when a certain interval of time
has elapsed. Timers have a set duration. They can be &quot;repeating&quot; or
&quot;non-repeating&quot;.</p>
<p>Both kinds can be manually &quot;reset&quot; (start counting the time interval from the
beginning) and &quot;paused&quot; (they will not progress even if you keep ticking them).</p>
<p>Repeating timers will automatically reset themselves after they reach their
set duration.</p>
<p>Use <code>.finished()</code> to detect when a timer has reached its set duration. Use
<code>.just_finished()</code>, if you need to detect only on the exact tick when the
duration was reached.</p>
<pre><code class="language-rust no_run noplayground">use std::time::Duration;

#[derive(Component)]
struct FuseTime {
    /// track when the bomb should explode (non-repeating timer)
    timer: Timer,
}

fn explode_bombs(
    mut commands: Commands,
    mut q: Query&lt;(Entity, &amp;mut FuseTime)&gt;,
    time: Res&lt;Time&gt;,
) {
    for (entity, mut fuse_timer) in q.iter_mut() {
        // timers gotta be ticked, to work
        fuse_timer.timer.tick(time.delta());

        // if it finished, despawn the bomb
        if fuse_timer.timer.finished() {
            commands.entity(entity).despawn();
        }
    }
}

#[derive(Resource)]
struct BombsSpawnConfig {
    /// How often to spawn a new bomb? (repeating timer)
    timer: Timer,
}

/// Spawn a new bomb in set intervals of time
fn spawn_bombs(
    mut commands: Commands,
    time: Res&lt;Time&gt;,
    mut config: ResMut&lt;BombsSpawnConfig&gt;,
) {
    // tick the timer
    config.timer.tick(time.delta());

    if config.timer.finished() {
        commands.spawn((
            FuseTime {
                // create the non-repeating fuse timer
                timer: Timer::new(Duration::from_secs(5), TimerMode::Once),
            },
            // ... other components ...
        ));
    }
}

/// Configure our bomb spawning algorithm
fn setup_bomb_spawning(
    mut commands: Commands,
) {
    commands.insert_resource(BombsSpawnConfig {
        // create the repeating timer
        timer: Timer::new(Duration::from_secs(10), TimerMode::Repeating),
    })
}</code></pre>
<p>Note that Bevy's timers do <em>not</em> work like typical real-life timers (which
count downwards toward zero). Bevy's timers start from zero and count <em>up</em>
towards their set duration. They are basically like stopwatches with extra
features: a maximum duration and optional auto-reset.</p>
<h3 id="stopwatch"><a class="header" href="#stopwatch">Stopwatch</a></h3>
<p><a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Stopwatch.html"><code>Stopwatch</code></a> allow you to track how much time has passed
since a certain point.</p>
<p>It will just keep accumulating time, which you can check with
<code>.elapsed()</code>/<code>.elapsed_secs()</code>. You can manually reset it at any time.</p>
<pre><code class="language-rust no_run noplayground">use bevy::time::Stopwatch;

#[derive(Component)]
struct JumpDuration {
    time: Stopwatch,
}

fn jump_duration(
    time: Res&lt;Time&gt;,
    mut q_player: Query&lt;&amp;mut JumpDuration, With&lt;Player&gt;&gt;,
    kbd: Res&lt;Input&lt;KeyCode&gt;&gt;,
) {
    // assume we have exactly one player that jumps with Spacebar
    let mut jump = q_player.single_mut();

    if kbd.just_pressed(KeyCode::Space) {
        jump.time.reset();
    }

    if kbd.pressed(KeyCode::Space) {
        println!(&quot;Jumping for {} seconds.&quot;, jump.time.elapsed_secs());
        // stopwatch has to be ticked to progress
        jump.time.tick(time.delta());
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="logging-console-messages"><a class="header" href="#logging-console-messages">Logging, Console Messages</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/main/examples/app/logs.rs"><code>logs</code></a>.</p>
<hr />
<p>You may have noticed how, when you run your Bevy project, you get messages
in your console window. For example:</p>
<pre><code>2022-06-12T13:28:25.445644Z  WARN wgpu_hal::vulkan::instance: Unable to find layer: VK_LAYER_KHRONOS_validation
2022-06-12T13:28:25.565795Z  INFO bevy_render::renderer: AdapterInfo { name: &quot;AMD Radeon RX 6600 XT&quot;, vendor: 4098, device: 29695, device_type: DiscreteGpu, backend: Vulkan }
2022-06-12T13:28:25.565795Z  INFO mygame: Entered new map area.
</code></pre>
<p>Log messages like this can come from Bevy, dependencies (like wgpu), and
also from your own code.</p>
<p>Bevy offers a logging framework that is much more advanced than simply using
<code>println</code>/<code>eprintln</code> from Rust. Log messages can have metadata, like the
level, timestamp, and Rust module where it came from. You can see that this
metadata is printed alongside the contents of the message.</p>
<p>This is set up by Bevy's <a href="https://docs.rs/bevy/0.12.0/bevy/log/struct.LogPlugin.html"><code>LogPlugin</code></a>. It is part of the
<a href="https://docs.rs/bevy/0.12.0/bevy/struct.DefaultPlugins.html"><code>DefaultPlugins</code></a> plugin group, so most Bevy users
will have it automatically in every typical Bevy project.</p>
<h2 id="levels"><a class="header" href="#levels">Levels</a></h2>
<p>Levels determine how important a message is, and allow messages to be filtered.</p>
<p>The available levels are: <code>off</code>, <code>error</code>, <code>warn</code>, <code>info</code>, <code>debug</code>, <code>trace</code>.</p>
<p>A rough guideline for when to use each level, could be:</p>
<ul>
<li><code>off</code>: disable all log messages</li>
<li><code>error</code>: something happened that prevents things from working correctly</li>
<li><code>warn</code>: something unusual happened, but things can continue to work</li>
<li><code>info</code>: general informational messages</li>
<li><code>debug</code>: for development, messages about what your code is doing</li>
<li><code>trace</code>: for very verbose debug data, like dumping values</li>
</ul>
<h2 id="printing-your-own-log-messages"><a class="header" href="#printing-your-own-log-messages">Printing your own log messages</a></h2>
<p>To display a message, just use the macro named after the level of the
message. The syntax is exactly the same as with Rust's <code>println</code>. See the
<a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a> documentation for more details.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>error!(&quot;Unknown condition!&quot;);
warn!(&quot;Something unusual happened!&quot;);
info!(&quot;Entered game level: {}&quot;, level_id);
debug!(&quot;x: {}, state: {:?}&quot;, x, state);
trace!(&quot;entity transform: {:?}&quot;, transform);
<span class="boring">}</span></code></pre></pre>
<h2 id="filtering-messages"><a class="header" href="#filtering-messages">Filtering messages</a></h2>
<p>To control what messages you would like to see, you can configure Bevy's
<a href="https://docs.rs/bevy/0.12.0/bevy/log/struct.LogPlugin.html"><code>LogPlugin</code></a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::log::LogPlugin;

app.add_plugins(DefaultPlugins.set(LogPlugin {
    filter: &quot;info,wgpu_core=warn,wgpu_hal=warn,mygame=debug&quot;.into(),
    level: bevy::log::Level::DEBUG,
}));
<span class="boring">}</span></code></pre></pre>
<p>The <code>filter</code> field is a string specifying a list of rules for what level to
enable for different Rust modules/crates. In the example above, the string
means: show up to <code>info</code> by default, limit <code>wgpu_core</code> and <code>wgpu_hal</code>
to <code>warn</code> level, for <code>mygame</code> show <code>debug</code>.</p>
<p>All levels higher than the one specified are also enabled. All levels lower
than the one specified are disabled, and those messages will not be displayed.</p>
<p>The <code>level</code> filter is a global limit on the lowest level to use. Messages
below that level will be ignored and most of the performance overhead avoided.</p>
<h3 id="environment-variable"><a class="header" href="#environment-variable">Environment Variable</a></h3>
<p>You can override the filter string when running your app, using the <code>RUST_LOG</code>
environment variable.</p>
<pre><code class="language-sh">RUST_LOG=&quot;warn,mygame=debug&quot; ./mygame
</code></pre>
<p>Note that other Rust projects, such as <code>cargo</code>, also use the same
environment variable to control their logging. This can lead to unexpected
consequences. For example, doing:</p>
<pre><code class="language-sh">RUST_LOG=&quot;debug&quot; cargo run
</code></pre>
<p>will cause your console to also be filled with debug messages from <code>cargo</code>.</p>
<h3 id="different-settings-for-debug-and-release-builds"><a class="header" href="#different-settings-for-debug-and-release-builds">Different settings for debug and release builds</a></h3>
<p>If you want to do different things in your Rust code for debug/release
builds, an easy way to achieve it is using conditional compilation on
&quot;debug assertions&quot;.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bevy::log::LogPlugin;

// this code is compiled only if debug assertions are enabled (debug mode)
#[cfg(debug_assertions)]
app.add_plugins(DefaultPlugins.set(LogPlugin {
    level: bevy::log::Level::DEBUG,
    filter: &quot;debug,wgpu_core=warn,wgpu_hal=warn,mygame=debug&quot;.into(),
}));

// this code is compiled only if debug assertions are disabled (release mode)
#[cfg(not(debug_assertions))]
app.add_plugins(DefaultPlugins.set(LogPlugin {
    level: bevy::log::Level::INFO,
    filter: &quot;info,wgpu_core=warn,wgpu_hal=warn&quot;.into(),
}));
<span class="boring">}</span></code></pre></pre>
<p>This is a good reason why <a href="fundamentals//pitfalls/performance.html">you should not use release mode during development
just for performance reasons</a>.</p>
<p>On Microsoft Windows, your game EXE will also launch with a console window for
displaying log messages by default. You might not want that in release builds.
<a href="fundamentals//platforms/windows.html#disabling-the-windows-console">See here.</a></p>
<h2 id="performance-implications"><a class="header" href="#performance-implications">Performance Implications</a></h2>
<p>Printing messages to the console is a relatively slow operation.</p>
<p>However, if you are not printing a large volume of messages, don't worry
about it. Just avoid spamming lots of messages from performance-sensitive
parts of your code like inner loops.</p>
<p>You can disable log levels like <code>trace</code> and <code>debug</code> in release builds.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="hierarchical-parentchild-entities"><a class="header" href="#hierarchical-parentchild-entities">Hierarchical (Parent/Child) Entities</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/ecs/hierarchy.rs"><code>hierarchy</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/3d/parenting.rs"><code>parenting</code></a>.</p>
<hr />
<p>Technically, the <a href="fundamentals//programming/intro-data.html#entities--components">Entities/Components</a> themselves cannot form a
hierarchy (the <a href="fundamentals//programming/ecs-intro.html">ECS</a> is a flat data structure). However,
logical hierarchies are a common pattern in games.</p>
<p>Bevy supports creating such a logical link between entities, to form
a virtual &quot;hierarchy&quot;, by simply adding <a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Parent.html"><code>Parent</code></a> and
<a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Children.html"><code>Children</code></a> components on the respective entities.</p>
<p>When using <a href="fundamentals//programming/commands.html">Commands</a> to spawn entities,
<a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a> has methods for adding children to entities,
which automatically add the correct components:</p>
<pre><code class="language-rust no_run noplayground">// spawn the parent and get its Entity id
let parent = commands.spawn(MyParentBundle::default()).id();

// do the same for the child
let child = commands.spawn(MyChildBundle::default()).id();

// add the child to the parent
commands.entity(parent).push_children(&amp;[child]);

// you can also use `with_children`:
commands.spawn(MyParentBundle::default())
    .with_children(|parent| {
        parent.spawn(MyChildBundle::default());
    });</code></pre>
<p>Note that this only sets up the <a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Parent.html"><code>Parent</code></a> and
<a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Children.html"><code>Children</code></a> components, and nothing else. Notably, it does not
add <a href="fundamentals//fundamentals/transforms.html">transforms</a> or <a href="fundamentals//fundamentals/visibility.html">visibility</a> for you.  If you
need that functionality, you need to add those components yourself, using
something like <a href="https://docs.rs/bevy/0.9.1/bevy/render/prelude/struct.SpatialBundle.html"><code>SpatialBundle</code></a>.</p>
<p>You can despawn an entire hierarchy with a single <a href="fundamentals//programming/commands.html">command</a>:</p>
<pre><code class="language-rust no_run noplayground">fn close_menu(
    mut commands: Commands,
    query: Query&lt;Entity, With&lt;MainMenuUI&gt;&gt;,
) {
    for entity in query.iter() {
        // despawn the entity and its children
        commands.entity(entity).despawn_recursive();
    }
}</code></pre>
<h2 id="accessing-the-parent-or-children"><a class="header" href="#accessing-the-parent-or-children">Accessing the Parent or Children</a></h2>
<p>To make a system that works with the hierarchy, you typically need two <a href="fundamentals//programming/queries.html">queries</a>:</p>
<ul>
<li>one with the components you need from the child entities</li>
<li>one with the components you need from the parent entities</li>
</ul>
<p>One of the two queries should include the appropriate component, to obtain the
entity ids to use with the other one:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Parent.html"><code>Parent</code></a> in the child query, if you want to iterate entities
and look up their parents, or</li>
<li><a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Children.html"><code>Children</code></a> in the parent query, if you want to iterate entities
and look up their children</li>
</ul>
<p>For example, if we want to get the <a href="https://docs.rs/bevy/0.9.1/bevy/transform/components/struct.Transform.html"><code>Transform</code></a>
of cameras (<a href="https://docs.rs/bevy/0.9.1/bevy/render/camera/struct.Camera.html"><code>Camera</code></a>) that have a parent, and the
<a href="https://docs.rs/bevy/0.9.1/bevy/transform/components/struct.GlobalTransform.html"><code>GlobalTransform</code></a> of their parent:</p>
<pre><code class="language-rust no_run noplayground">fn camera_with_parent(
    q_child: Query&lt;(&amp;Parent, &amp;Transform), With&lt;Camera&gt;&gt;,
    q_parent: Query&lt;&amp;GlobalTransform&gt;,
) {
    for (parent, child_transform) in q_child.iter() {
        // `parent` contains the Entity ID we can use
        // to query components from the parent:
        let parent_global_transform = q_parent.get(parent.get());

        // do something with the components
    }
}</code></pre>
<p>As another example, say we are making a strategy game, and we have Units
that are children of a Squad. Say we need to make a system that works on
each Squad, and it needs some information about the children:</p>
<pre><code class="language-rust no_run noplayground">fn process_squad_damage(
    q_parent: Query&lt;(&amp;MySquadDamage, &amp;Children)&gt;,
    q_child: Query&lt;&amp;MyUnitHealth&gt;,
) {
    // get the properties of each squad
    for (squad_dmg, children) in q_parent.iter() {
        // `children` is a collection of Entity IDs
        for &amp;child in children.iter() {
            // get the health of each child unit
            let health = q_child.get(child);

            // do something
        }
    }
}</code></pre>
<h2 id="transform-and-visibility-propagation"><a class="header" href="#transform-and-visibility-propagation">Transform and Visibility Propagation</a></h2>
<p>If your entities represent &quot;objects in the game world&quot;, you probably expect
the children to be affected by the parent.</p>
<p><a href="fundamentals//fundamentals/transforms.html">Transform</a> propagation allows children to be positioned
relative to their parent and move with it.</p>
<p><a href="fundamentals//fundamentals/visibility.html">Visibility</a> propagation allows children to be hidden if
you manually hide their parent.</p>
<p>Most <a href="fundamentals//builtins.html#bundles">Bundles that come with Bevy</a> provide these behaviors
automatically. Check the docs for the bundles you are using.  Camera bundles,
for example, have transforms, but not visibility.</p>
<p>Otherwise, you can use <a href="https://docs.rs/bevy/0.9.1/bevy/render/prelude/struct.SpatialBundle.html"><code>SpatialBundle</code></a> to make sure
your entities have all the necessary components.</p>
<h2 id="known-pitfalls"><a class="header" href="#known-pitfalls">Known Pitfalls</a></h2>
<h3 id="despawning-child-entities"><a class="header" href="#despawning-child-entities">Despawning Child Entities</a></h3>
<p>If you despawn an entity that has a parent, Bevy does not remove it from the
parent's <a href="https://docs.rs/bevy/0.9.1/bevy/hierarchy/struct.Children.html"><code>Children</code></a>.</p>
<p>If you then query for that parent entity's children, you will get an invaild
entity, and any attempt to manipulate it will likely lead to this error:</p>
<pre><code>thread 'main' panicked at 'Attempting to create an EntityCommands for entity 7v0, which doesn't exist.'
</code></pre>
<p>The workaround is to manually call <code>remove_children</code> alongside the <code>despawn</code>:</p>
<pre><code class="language-rust no_run noplayground">    commands.entity(parent_entity).remove_children(&amp;[child_entity]);
    commands.entity(child_entity).despawn();</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="fundamentals//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="fixed-timestep"><a class="header" href="#fixed-timestep">Fixed Timestep</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/ecs/fixed_timestep.rs"><code>fixed_timestep</code></a>.</p>
<hr />
<p>If you need something to happen at fixed time intervals (a common use case
is Physics updates), you can add the respective <a href="fundamentals//programming/systems.html">systems</a> to
your <a href="fundamentals//programming/app-builder.html">app</a> using Bevy's <a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.FixedTimestep.html"><code>FixedTimestep</code></a>
<a href="fundamentals//programming/run-criteria.html">Run Criteria</a>.</p>
<pre><code class="language-rust no_run noplayground">use bevy::time::FixedTimestep;

// The timestep says how many times to run the SystemSet every second
// For TIMESTEP_1, it's once every second
// For TIMESTEP_2, it's twice every second

const TIMESTEP_1_PER_SECOND: f64 = 60.0 / 60.0;
const TIMESTEP_2_PER_SECOND: f64 = 30.0 / 60.0;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_system_set(
            SystemSet::new()
                // This prints out &quot;hello world&quot; once every second
                .with_run_criteria(FixedTimestep::step(TIMESTEP_1_PER_SECOND))
                .with_system(slow_timestep)
        )
        .add_system_set(
            SystemSet::new()
                // This prints out &quot;goodbye world&quot; twice every second
                .with_run_criteria(FixedTimestep::step(TIMESTEP_2_PER_SECOND))
                .with_system(fast_timestep)
        )
        .run();
}

fn slow_timestep() {
    println!(&quot;hello world&quot;);
}

fn fast_timestep() {
    println!(&quot;goodbye world&quot;);
}</code></pre>
<h2 id="state"><a class="header" href="#state">State</a></h2>
<p>You can check the current state of the fixed timestep trackers, by accessing
the <a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.FixedTimesteps.html"><code>FixedTimesteps</code></a> <a href="fundamentals//programming/res.html">resource</a>. This lets
you know how much time remains until the next time it triggers, or how much
it has overstepped. You need to label your fixed timesteps.</p>
<p>See the <a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/ecs/fixed_timestep.rs">official example</a>, which illustrates this.</p>
<h2 id="caveats"><a class="header" href="#caveats">Caveats</a></h2>
<p>The major problem with Bevy's fixed timestep comes from the fact that
it is implemented using <a href="fundamentals//programming/run-criteria.html">Run Criteria</a>. It cannot be
combined with other run criteria, such as <a href="fundamentals//programming/states.html">states</a>. This makes
it unusable for most projects, which need to rely on states for things
like implementing the main menu / loading screen / etc. Consider using
<a href="https://github.com/IyesGames/iyes_loopless"><code>iyes_loopless</code></a>, which does not have this problem.</p>
<p>Also, note that your <a href="fundamentals//programming/systems.html">systems</a> are still called as part of the
regular frame-update cycle, along with all of the normal systems. So, the
timing is not exact.</p>
<p>The <a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.FixedTimestep.html"><code>FixedTimestep</code></a> run criteria simply checks how much
time passed since the last time your systems were ran, and decides whether
to run them during the current frame, or not, or run them multiple times,
as needed.</p>
<h3 id="danger-lost-events"><a class="header" href="#danger-lost-events"><strong>Danger!</strong> Lost events!</a></h3>
<p>By default, Bevy's <a href="fundamentals//programming/events.html">events</a> are <em>not reliable!</em> They only persist
for 2 frames, after which they are lost. If your fixed-timestep systems
receive events, beware that you may miss some events if the framerate is
higher than 2x the fixed timestep.</p>
<p>One way around that is to use <a href="fundamentals//patterns/manual-event-clear.html">events with manual
clearing</a>. This gives you control over how long events
persist, but can also leak / waste memory if you forget to clear them.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="general-graphics-features"><a class="header" href="#general-graphics-features">General Graphics Features</a></h1>
<p>This chapter covers general graphics-related features in Bevy, that are
relevant to both 2D and 3D games.</p>
<p>Bevy's rendering is driven by / configured via <a href="/graphics/camera.html">cameras</a>. Each
camera <a href="/programming/ec.html#entities">entity</a> will cause Bevy to render your game world,
as configured via the various <a href="/programming/ec.html#components">components</a> on the
<a href="/graphics/camera.html">camera</a>. You can enable all kinds of different workflows, as
well as optional effects, by adding the relevant components to your camera
and configuring them.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="graphics//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="cameras"><a class="header" href="#cameras">Cameras</a></h1>
<p>Cameras drive all rendering in Bevy. They are responsible for configuring what
to draw, how to draw it, and where to draw it.</p>
<p>You must have at least one camera entity, in order for anything to be displayed
at all! If you forget to spawn a camera, you will get an empty black screen.</p>
<p>In the simplest case, you can create a camera with the default settings. Just
spawn an entity using <a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/core_2d/struct.Camera2dBundle.html"><code>Camera2dBundle</code></a> or
<a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/core_3d/struct.Camera3dBundle.html"><code>Camera3dBundle</code></a>. It will simply draw all renderable
entities that are <a href="graphics//fundamentals/visibility.html">visible</a>.</p>
<p>This page gives a general overview of cameras in Bevy. Also see the dedicated
pages for <a href="graphics//2d/camera.html">2D cameras</a> and <a href="graphics//3d/camera.html">3D cameras</a>.</p>
<p>Practical advice: always create <a href="graphics//programming/ec.html#components">marker components</a> for
your camera entities, so that you can <a href="graphics//programming/queries.html">query</a> your cameras easily!</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct MyGameCamera;

fn setup(mut commands: Commands) {
    commands.spawn((
        Camera3dBundle::default(),
        MyGameCamera,
    ));
}</code></pre>
<h2 id="the-camera-transform"><a class="header" href="#the-camera-transform">The Camera Transform</a></h2>
<p>Cameras have <a href="graphics//fundamentals/transforms.html">transforms</a>, which can be used to position or
rotate the camera. This is how you move the camera around.</p>
<p>For examples, see these <a href="graphics//cookbook.html">cookbook</a> pages:</p>
<ul>
<li><a href="graphics//cookbook/pan-orbit-camera.html">3D pan-orbit camera</a>, like in 3D editor apps</li>
</ul>
<p>If you are making a game, you should implement your own custom camera controls
that feel appropriate to your game's genre and gameplay.</p>
<h3 id="zooming-the-camera"><a class="header" href="#zooming-the-camera">Zooming the camera</a></h3>
<p>Do not use the transform scale to &quot;zoom&quot; a camera! It just stretches the image,
which is not &quot;zooming&quot;. It might also cause other issues and incompatibilities.
Use the <a href="graphics//graphics/camera.html#projection">projection</a> to zoom.</p>
<p>For an orthographic projection, change the scale. For a perspective projection,
change the FOV. The FOV mimics the effect of zooming with a lens.</p>
<p>Learn more about how to do this in <a href="graphics//2d/camera.html#projection">2D</a> or
<a href="graphics//3d/camera.html#projection">3D</a>.</p>
<h2 id="projection"><a class="header" href="#projection">Projection</a></h2>
<p>The camera projection is responsible for mapping the coordinate system to the
viewport (commonly, the screen/window). It is what configures the coordinate
space, as well as any scaling/stretching of the image.</p>
<p>Bevy provides two kinds of projections:
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.OrthographicProjection.html"><code>OrthographicProjection</code></a> and
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.PerspectiveProjection.html"><code>PerspectiveProjection</code></a>. They are configurable,
to be able to serve a variety of different use cases.</p>
<p>Orthographic means that everything always appears the same size, regardless of
how far away it is from the camera.</p>
<p>Perspective means that things appear smaller the further away they are from
the camera. This is the effect that gives 3D graphics a sense of depth and
distance.</p>
<p><a href="graphics//2d/camera.html">2D cameras</a> are always orthographic.</p>
<p><a href="graphics//3d/camera.html">3D cameras</a> can use either kind of projection. Perspective is
the most common (and default) choice. Orthographic is useful for applications
such as CAD and engineering, where you want to accurately represent the
dimensions of an object, instead of creating a realistic sense of 3D space. Some
games (notably simulation games) use orthographic as an artistic choice.</p>
<p>It is possible to implement your own <a href="graphics//cookbook/custom-projection.html">custom camera
projections</a>. This can give you full control over
the coordinate system. However, beware that things might behave in unexpected
ways if you violate Bevy's <a href="graphics//fundamentals/coords.html">coordinate system conventions</a>!</p>
<h2 id="hdr-and-tonemapping"><a class="header" href="#hdr-and-tonemapping">HDR and Tonemapping</a></h2>
<p><a href="graphics//graphics/hdr-tonemap.html">See here!</a></p>
<h2 id="render-target"><a class="header" href="#render-target">Render Target</a></h2>
<p>The render target of a camera determines where the GPU will draw things to. It
could be a window (for outputting directly to the screen) or an
<a href="https://docs.rs/bevy/0.12.0/bevy/render/texture/struct.Image.html"><code>Image</code></a> <a href="graphics//assets.html">asset</a> (render-to-texture).</p>
<p>By default, cameras output to the primary window.</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::camera::RenderTarget;

fn debug_render_targets(
    q: Query&lt;&amp;Camera&gt;,
) {
    for camera in &amp;q {
        match &amp;camera.target {
            RenderTarget::Window(wid) =&gt; {
                eprintln!(&quot;Camera renders to window with id: {:?}&quot;, wid);
            }
            RenderTarget::Image(handle) =&gt; {
                eprintln!(&quot;Camera renders to image asset with id: {:?}&quot;, handle);
            }
            RenderTarget::TextureView(_) =&gt; {
                eprintln!(&quot;This is a special camera that outputs to something outside of Bevy.&quot;);
            }
        }
    }
}</code></pre>
<h2 id="viewport"><a class="header" href="#viewport">Viewport</a></h2>
<p>The viewport is an (optional) way to restrict a camera to a sub-area of its
render target, defined as a rectangle. That rectangle is effectively treated as
the &quot;window&quot; to draw in.</p>
<p>An obvious use-case are split-screen games, where you want a camera to only draw
to one half of the screen.</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::camera::Viewport;

fn setup_minimap(mut commands: Commands) {
    commands.spawn((
        Camera2dBundle {
            camera: Camera {
                // renders after / on top of other cameras
                order: 2,
                // set the viewport to a 256x256 square in the top left corner
                viewport: Some(Viewport {
                    physical_position: UVec2::new(0, 0),
                    physical_size: UVec2::new(256, 256),
                    ..default()
                }),
                ..default()
            },
            ..default()
        },
        MyMinimapCamera,
    ));
}</code></pre>
<p>If you need to find out the area a camera renders to (the viewport, if
configured, or the entire window, if not):</p>
<pre><code class="language-rust no_run noplayground">fn debug_viewports(
    q: Query&lt;&amp;Camera, With&lt;MyExtraCamera&gt;&gt;,
) {
    let camera = q.single();

    // the size of the area being rendered to
    let view_dimensions = camera.logical_viewport_size().unwrap();

    // the coordinates of the rectangle covered by the viewport
    let rect = camera.logical_viewport_rect().unwrap();
}</code></pre>
<h2 id="coordinate-conversion"><a class="header" href="#coordinate-conversion">Coordinate Conversion</a></h2>
<p><a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.Camera.html"><code>Camera</code></a> provides methods to help with coordinate conversion
between on-screen coordinates and world-space coordinates. For an example, see
the <a href="graphics//cookbook/cursor2world.html">&quot;cursor to world&quot;</a> cookbook page.</p>
<h2 id="clear-color"><a class="header" href="#clear-color">Clear Color</a></h2>
<p>This is the &quot;background color&quot; that the whole viewport will be cleared to,
before a camera renders anything.</p>
<p>You can also disable clearing on a camera, if you want to preserve all the
pixels as they were before.</p>
<p><a href="graphics//window/clear-color.html">See this page for more info.</a></p>
<h2 id="render-layers"><a class="header" href="#render-layers">Render Layers</a></h2>
<p><a href="https://docs.rs/bevy/0.12.0/bevy/render/view/visibility/struct.RenderLayers.html"><code>RenderLayers</code></a> is a way to filter what entities should be
drawn by what cameras. Insert this <a href="graphics//programming/ec.html#components">component</a> onto your entities
to place them in specific &quot;layers&quot;. The layers are integers from 0 to 31 (32
total available).</p>
<p>Inserting this component onto a camera entity selects what layers that camera
should render. Inserting this component onto renderable entities selects what
cameras should render those entities. An entity will be rendered if there is any
overlap between the camera's layers and the entity's layers (they have at least
one layer in common).</p>
<p>If an entity does not have the <a href="https://docs.rs/bevy/0.12.0/bevy/render/view/visibility/struct.RenderLayers.html"><code>RenderLayers</code></a> component,
it is assumed to belong to layer 0 (only).</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::view::visibility::RenderLayers;
// This camera renders everything in layers 0, 1
commands.spawn((
    Camera2dBundle::default(),
    RenderLayers::from_layers(&amp;[0, 1])
));
// This camera renders everything in layers 1, 2
commands.spawn((
    Camera2dBundle::default(),
    RenderLayers::from_layers(&amp;[1, 2])
));
// This sprite will only be seen by the first camera
commands.spawn((
    SpriteBundle::default(),
    RenderLayers::layer(0),
));
// This sprite will be seen by both cameras
commands.spawn((
    SpriteBundle::default(),
    RenderLayers::layer(1),
));
// This sprite will only be seen by the second camera
commands.spawn((
    SpriteBundle::default(),
    RenderLayers::layer(2),
));
// This sprite will also be seen by both cameras
commands.spawn((
    SpriteBundle::default(),
    RenderLayers::from_layers(&amp;[0, 2]),
));</code></pre>
<p>You can also modify the render layers of entities after they are spawned.</p>
<h2 id="camera-ordering"><a class="header" href="#camera-ordering">Camera Ordering</a></h2>
<p>A camera's <code>order</code> is a simple integer value that controls the order relative
to any other cameras with the same render target.</p>
<p>For example, if you have multiple cameras that all render to the primary window,
they will behave as multiple &quot;layers&quot;. Cameras with a higher order value will render
&quot;on top of&quot; cameras with a lower value. <code>0</code> is the default.</p>
<pre><code class="language-rust no_run noplayground">use bevy::core_pipeline::clear_color::ClearColorConfig;

commands.spawn((
    Camera2dBundle {
        camera_2d: Camera2d {
            // no &quot;background color&quot;, we need to see the main camera's output
            clear_color: ClearColorConfig::None,
            ..default()
        },
        camera: Camera {
            // renders after / on top of the main camera
            order: 1,
            ..default()
        },
        ..default()
    },
    MyOverlayCamera,
));</code></pre>
<h2 id="ui-rendering"><a class="header" href="#ui-rendering">UI Rendering</a></h2>
<p>Bevy UI rendering is integrated into the cameras! Every camera will, by default,
also draw UI.</p>
<p>However, if you are working with multiple cameras, you probably only want your
UI to be drawn once (probably by the main camera). You can disable UI rendering
on your other cameras.</p>
<p>Also, UI on multiple cameras is currently broken in Bevy. Even if you want
multiple UI cameras (say, to display UI in an app with multiple windows), it
does not work correctly.</p>
<pre><code class="language-rust no_run noplayground">commands.spawn((
    Camera3dBundle::default(),
    // UI config is a separate component
    UiCameraConfig {
        show_ui: false,
    },
    MyExtraCamera,
));</code></pre>
<h2 id="disabling-cameras"><a class="header" href="#disabling-cameras">Disabling Cameras</a></h2>
<p>You can deactivate a camera without despawning it. This is useful when you want
to preserve the camera entity and all the configuration it carries, so you can
easily re-enable it later.</p>
<p>Some example use cases: toggling an overlay, switching between a 2D and 3D view.</p>
<pre><code class="language-rust no_run noplayground">fn toggle_overlay(
    mut q: Query&lt;&amp;mut Camera, With&lt;MyOverlayCamera&gt;&gt;,
) {
    let mut camera = q.single_mut();
    camera.is_active = !camera.is_active;
}</code></pre>
<h2 id="multiple-cameras"><a class="header" href="#multiple-cameras">Multiple Cameras</a></h2>
<p>This is an overview of different scenarios where you would need more than one
camera entity.</p>
<h3 id="multiple-windows"><a class="header" href="#multiple-windows">Multiple Windows</a></h3>
<p>Official example: <a href="https://github.com/bevyengine/bevy/blob/main/examples/window/multiple_windows.rs"><code>multiple_windows</code></a>.</p>
<p>If you want to create a Bevy app with multiple windows, you need to spawn
multiple cameras, one for each window, and set their render targets
respectively. Then, you can use your cameras to control what to display in each
window.</p>
<h3 id="split-screen"><a class="header" href="#split-screen">Split-Screen</a></h3>
<p>Official example: <a href="https://github.com/bevyengine/bevy/blob/main/examples/3d/split_screen.rs"><code>split_screen</code></a>.</p>
<p>You can set the camera <a href="graphics/camera.html#viewport">viewport</a> to only render to a part of the
render target. This way, a camera can be made to render one half of the screen
(or any other area). Use a separate camera for each view in a split-screen game.</p>
<h3 id="overlays"><a class="header" href="#overlays">Overlays</a></h3>
<p>Official example: <a href="https://github.com/bevyengine/bevy/blob/main/examples/3d/two_passes.rs"><code>two_passes</code></a>.</p>
<p>You might want to render multiple &quot;layers&quot; (passes) to the same render target.
An example of this might be an overlay/HUD to be displayed on top of the
main game.</p>
<p>The overlay camera could be completely different from the main camera. For
example, the main camera might draw a 3D scene, and the overlay camera might
draw 2D shapes. Such use cases are possible!</p>
<p>Use a separate camera to create the overlay. Set the <a href="graphics/camera.html#priority">priority</a>
higher, to tell Bevy to render it after (on top of) the main camera. Make sure
to disable <a href="graphics/camera.html#clear-color">clearing</a>!</p>
<p>Think about which camera you want to be responsible for <a href="graphics/camera.html#ui-rendering">rendering the
UI</a>. Use the overlay camera if you want it to be unaffected,
or use the main camera if you want the overlay to be on top of the UI. Disable
it on the other camera.</p>
<p>Use <a href="graphics/camera.html#render-layers">Render Layers</a> to control what entities should be rendered
by each camera.</p>
<h3 id="render-to-image"><a class="header" href="#render-to-image">Render to Image</a></h3>
<p>(aka Render to Texture)</p>
<p>Official example: <a href="https://github.com/bevyengine/bevy/blob/main/examples/3d/render_to_texture.rs"><code>render_to_texture</code></a>.</p>
<p>If you want to generate an image in memory, you can output to an <code>Image</code> asset.</p>
<p>This is useful for intermediate steps in games, such as rendering a minimap or
the gun in a shooter game. You can then use that image as part of the final
scene to render to the screen. Item previews are a similar use case.</p>
<p>Another use case is window-less applications that want to generate image files.
For example, you could use Bevy to render something, and then export it to a PNG
file.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="graphics//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="hdr"><a class="header" href="#hdr">HDR</a></h1>
<p>HDR (High Dynamic Range) refers to the ability of the game engine to handle
very bright lights or colors. Bevy's rendering is HDR internally. This means
you can have objects with colors that go above <code>1.0</code>, very bright lights,
or bright emissive materials. All of this is supported for both 3D and 2D.</p>
<p>This is not to be confused with HDR display output, which is the ability to
produce a HDR image to be displayed by a modern monitor or TV with HDR
capabilities. Bevy has no support for this yet.</p>
<p>The internal HDR image has to be converted down to SDR (Standard Dynamic
Range) before it can be displayed on the screen. This process is called
<a href="graphics//graphics/hdr-tonemap.html#tonemapping">Tonemapping</a>. Bevy supports different algorithms that can
result in a different look. It is an artistic choice what tonemapping
algorithm to use for your game.</p>
<h2 id="camera-hdr-configuration"><a class="header" href="#camera-hdr-configuration">Camera HDR configuration</a></h2>
<p>There is a per-camera toggle that lets you decide whether you want Bevy to
preserve the HDR data internally, to make it possible for subsequent passes
(such as postprocessing effects) to use it.</p>
<pre><code class="language-rust no_run noplayground">commands.spawn((
    Camera3dBundle {
        camera: Camera {
            hdr: true,
            ..default()
        },
        ..default()
    },
));</code></pre>
<p>If it is enabled, Bevy's intermediate textures will be in HDR format. The
shaders output HDR values and Bevy will store them, so they can be used in later
rendering passes. This allows you to enable effects like <a href="graphics//graphics/bloom.html">Bloom</a>,
that make use of the HDR data. <a href="graphics//graphics/hdr-tonemap.html#tonemapping">Tonemapping</a> will happen as a
post-processing step, after the HDR data is no longer needed for anything.</p>
<p>If it is disabled, the shaders are expected to output standard RGB colors in
the 0.0 to 1.0 range. <a href="graphics//graphics/hdr-tonemap.html#tonemapping">Tonemapping</a> happens in the shader. The
HDR information is not preserved. Effects that require HDR data, like Bloom,
will not work.</p>
<p>It is disabled by default, because this results in better performance and
reduced VRAM usage for applications with simple graphics that do not need it.</p>
<p>If you have both HDR and MSAA enabled, it is possible you might encounter
issues. There might be visual artifacts in some cases. It is also unsupported on
Web/WASM, crashing at runtime. Disable MSAA if you experience any such issues.</p>
<h2 id="tonemapping"><a class="header" href="#tonemapping">Tonemapping</a></h2>
<p>Tonemapping is the step of the rendering process where the colors of pixels are
converted from their in-engine intermediate repesentation into the final values
as they should be displayed on-screen.</p>
<p>This is very important with HDR applications, as in that case the image can
contain very bright pixels (above 1.0) which need to be remapped into a range
that can be displayed.</p>
<p>Tonemapping is enabled by default. Bevy allows you to configure it via the
(<a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/tonemapping/enum.Tonemapping.html"><code>Tonemapping</code></a>) component, per-camera. Disabling it is not
recommended, unless you know you only have very simple graphics that don't need
it. It can make your graphics look incorrect.</p>
<pre><code class="language-rust no_run noplayground">use bevy::core_pipeline::tonemapping::Tonemapping;

commands.spawn((
    Camera3dBundle {
        // no tonemapping
        tonemapping: Tonemapping::None,
        ..default()
    },
));
commands.spawn((
    Camera3dBundle {
        // this is the default:
        tonemapping: Tonemapping::TonyMcMapface,
        ..default()
    },
));
commands.spawn((
    Camera3dBundle {
        // another common choice:
        tonemapping: Tonemapping::ReinhardLuminance,
        ..default()
    },
));</code></pre>
<p>Bevy supports many different tonemapping algorithms. Each of them results in a
different look, affecting colors and brightness. It can be an artistic choice. You
can decide what algorithm looks best for your game. Bevy's default is TonyMcMapface,
which, despite the silly name, provides very good results for a wide variety of
graphics styles. See the (<a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/tonemapping/enum.Tonemapping.html"><code>Tonemapping</code></a>) documentation for
an explanation of each of the available choices.</p>
<p>Some tonemapping algorithms (incl. the default TonyMcMapface) require the
<code>tonemapping_luts</code> <a href="graphics//setup/bevy-config.html">cargo feature</a>. It is enabled by default. Be
sure to re-enable it if you disable default features and you need it. Enabling
it also enables the <code>ktx2</code> and <code>zstd</code> features, because it works by embedding
special data in KTX2 format into your game, which is used during tonemapping.</p>
<p>The following tonemapping algorithms <em>DO NOT</em> require the special data from
<code>tonemapping_luts</code>:</p>
<ul>
<li>Reinhard</li>
<li>ReinhardLuminance</li>
<li>AcesFitted</li>
<li>SomewhatBoringDisplayTransform</li>
</ul>
<p>The following tonemapping algorithms <em>require</em> the special data from <code>tonemapping_luts</code>:</p>
<ul>
<li>AgX</li>
<li>TonyMcMapface</li>
<li>BlenderFilmic</li>
</ul>
<p>If you want to make a smaller game binary (might be important for Web games),
you could reduce bloat by changing the default tonemapping to something
simpler and disabling the <a href="graphics//setup/bevy-config.html">cargo features</a>.</p>
<h2 id="color-grading"><a class="header" href="#color-grading">Color Grading</a></h2>
<p>Color Grading is a manipulation of the overall look of the image.</p>
<p>Together with tonemapping, this affects the &quot;tone&quot;/&quot;mood&quot; of the final image.</p>
<p>This is also how you can implement a &quot;retina&quot; effect, where the camera
dynamically adapts to very dark (such as inside a cave) and very bright
(such as in daylight) scenes, by adjusting exposure/gamma.</p>
<p>You can also adjust color saturation. Heavily desaturating the image can
result in a greyscale or muted appearance, which can be a great artistic
choice for apocalyptic or horror games.</p>
<p>You can configure these parameters via the <a href="https://docs.rs/bevy/0.12.0/bevy/render/view/struct.ColorGrading.html"><code>ColorGrading</code></a>
component:</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::view::ColorGrading;

commands.spawn((
    Camera3dBundle {
        color_grading: ColorGrading {
            exposure: 0.0,
            gamma: 1.0,
            pre_saturation: 1.0,
            post_saturation: 1.0,
        },
        ..default()
    },
));</code></pre>
<h2 id="deband-dithering"><a class="header" href="#deband-dithering">Deband Dithering</a></h2>
<p>Deband dithering helps color gradients or other areas with subtle changes in
color to appear higher-quality, without a &quot;color banding&quot; effect.</p>
<p>It is enabled by default, and can be disabled per-camera.</p>
<pre><code class="language-rust no_run noplayground">use bevy::core_pipeline::tonemapping::DebandDither;

commands.spawn((
    Camera3dBundle {
        dither: DebandDither::Disabled,
        ..default()
    },
));</code></pre>
<p>Here is an example image without dithering (top) and with dithering (bottom).
Pay attention to the quality/smoothness of the green color gradient on the
ground plane. In games with photorealistic graphics, similar situations can
arise in the sky, in dark rooms, or lights glowing with a bloom effect.</p>
<p><img src="graphics//img/dithering.png" alt="Visual comparison of a scene simple cube on a flat green plane, with dithering disabled/enabled." /></p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="graphics//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="bloom"><a class="header" href="#bloom">Bloom</a></h1>
<p>The &quot;Bloom&quot; effect creates a glow around bright lights. It is not a
physically-accurate effect, though it is inspired by how light looks through
a dirty or imperfect lens.</p>
<p>Bloom does a good job of helping the perception of very bright light,
especially when outputting HDR to the display hardware is not supported.
Your monitor can only display a certain maximum brightness, so Bloom is a
common artistic choice to try to convey light intensity brighter than can
be displayed.</p>
<p>Bloom looks best with a <a href="graphics//graphics/hdr-tonemap.html#tonemapping">Tonemapping</a> algorithm that desaturates
very bright colors. Bevy's default is a good choice.</p>
<p>Bloom requires <a href="graphics//graphics/hdr-tonemap.html">HDR mode</a> to be enabled on your camera. Add the
<a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/bloom/struct.BloomSettings.html"><code>BloomSettings</code></a> component to the camera to enable
bloom and configure the effect.</p>
<pre><code class="language-rust no_run noplayground">use bevy::core_pipeline::bloom::BloomSettings;

commands.spawn((
    Camera3dBundle {
        camera: Camera {
            hdr: true,
            ..default()
        },
        ..default()
    },
    BloomSettings::NATURAL,
));</code></pre>
<h2 id="bloom-settings"><a class="header" href="#bloom-settings">Bloom Settings</a></h2>
<p>Bevy offers many parameters to tweak the look of the bloom effect.</p>
<p>The default mode is &quot;energy-conserving&quot;, which is closer to how real light
physics might behave. It tries to mimic the effect of light scattering,
without brightening the image artificially. The effect is more subtle and &quot;natural&quot;.</p>
<p>There is also an &quot;additive&quot; mode, which will brighten everything and make it feel
like bright lights are &quot;glowing&quot; unnaturally. This sort of effect is quite common
in many games, especially older games from the 2000s.</p>
<p>Bevy offers three bloom &quot;presets&quot;:</p>
<ul>
<li><code>NATURAL</code>: energy-conerving, subtle, natural look.</li>
<li><code>OLD_SCHOOL</code>: &quot;glowy&quot; effect, similar to how older games looked.</li>
<li><code>SCREEN_BLUR</code>: very intense bloom that makes everything look blurred.</li>
</ul>
<p>You can also create an entirely custom configuration by tweaking all the
parameters in <a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/bloom/struct.BloomSettings.html"><code>BloomSettings</code></a> to your taste. Use the
presets for inspiration.</p>
<p>Here are the settings for the Bevy presets:</p>
<pre><code class="language-rust no_run noplayground">// NATURAL
BloomSettings {
    intensity: 0.15,
    low_frequency_boost: 0.7,
    low_frequency_boost_curvature: 0.95,
    high_pass_frequency: 1.0,
    prefilter_settings: BloomPrefilterSettings {
        threshold: 0.0,
        threshold_softness: 0.0,
    },
    composite_mode: BloomCompositeMode::EnergyConserving,
};

// OLD_SCHOOL
BloomSettings {
    intensity: 0.05,
    low_frequency_boost: 0.7,
    low_frequency_boost_curvature: 0.95,
    high_pass_frequency: 1.0,
    prefilter_settings: BloomPrefilterSettings {
        threshold: 0.6,
        threshold_softness: 0.2,
    },
    composite_mode: BloomCompositeMode::Additive,
};

// SCREEN_BLUR
BloomSettings {
    intensity: 1.0,
    low_frequency_boost: 0.0,
    low_frequency_boost_curvature: 0.0,
    high_pass_frequency: 1.0 / 3.0,
    prefilter_settings: BloomPrefilterSettings {
        threshold: 0.0,
        threshold_softness: 0.0,
    },
    composite_mode: BloomCompositeMode::EnergyConserving,
};</code></pre>
<h2 id="visualization"><a class="header" href="#visualization">Visualization</a></h2>
<p>Here is an example of Bloom in 3D:</p>
<p><img src="graphics//img/bloom_3d.png" alt="The Bloom effect on street lamps." /></p>
<p>And here is a 2D example:</p>
<p><img src="graphics//img/bloom_2d.png" alt="The Bloom effect on a simple hexagon." /></p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="bevy-2d"><a class="header" href="#bevy-2d">Bevy 2D</a></h1>
<p>This chapter covers topics relevant to making 2D games with Bevy.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="2d//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="2d-camera-setup"><a class="header" href="#2d-camera-setup">2D Camera Setup</a></h1>
<p><a href="2d//graphics/camera.html">Cameras</a> in Bevy are mandatory to see anything: they configure the
rendering.</p>
<p>This page will teach you about the specifics of 2D cameras. If you want to learn about
general non-2D specific functionality, see the <a href="2d//graphics/camera.html">general page on cameras</a>.</p>
<h2 id="creating-a-2d-camera"><a class="header" href="#creating-a-2d-camera">Creating a 2D Camera</a></h2>
<p>Bevy provides a <a href="2d//programming/bundle.html">bundle</a> (<a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/core_2d/struct.Camera2dBundle.html"><code>Camera2dBundle</code></a>)
that you can use to <a href="2d//programming/commands.html">spawn</a> a camera <a href="2d//programming/ec.html#entities">entity</a>. It
has reasonable defaults to set up everything correctly.</p>
<p>You might want to set the <a href="2d//fundamentals/transforms.html">transform</a>, to position the camera.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct MyCameraMarker;

fn setup_camera(mut commands: Commands) {
    commands.spawn((
        Camera2dBundle {
            transform: Transform::from_xyz(100.0, 200.0, 0.0),
            ..default()
        },
        MyCameraMarker,
    ));
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_systems(Startup, setup_camera)
        .run();
}</code></pre>
<h2 id="projection-1"><a class="header" href="#projection-1">Projection</a></h2>
<p>The <a href="2d//graphics/camera.html#projection">projection</a> is what determines how coordinates map to the
<a href="2d//graphics/camera.html#viewport">viewport</a> (commonly, the screen/window).</p>
<p>2D cameras always use an Orthographic projection.</p>
<p>When you spawn a 2D camera using <a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/core_2d/struct.Camera2dBundle.html"><code>Camera2dBundle</code></a>,
it adds the <a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.OrthographicProjection.html"><code>OrthographicProjection</code></a>
<a href="2d//programming/ec.html#components">component</a> to your <a href="2d//programming/ec.html#entities">entity</a>. When
you are working with 2D cameras and you want to access
the projection, you should <a href="2d//programming/queries.html">query</a> for
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.OrthographicProjection.html"><code>OrthographicProjection</code></a>.</p>
<pre><code class="language-rust no_run noplayground">fn debug_projection(
    query_camera: Query&lt;&amp;OrthographicProjection, With&lt;MyCameraMarker&gt;&gt;,
) {
    let projection = query_camera.single();
    // ... do something with the projection
}</code></pre>
<p>Note that this is different from <a href="2d//3d/camera.html#projection">3D</a>. If you are
making a library or some other code that should be able to handle both 2D and
3D, you cannot make a single <a href="2d//programming/queries.html">query</a> to access both 2D and 3D
cameras. You should create separate <a href="2d//programming/systems.html">systems</a>, or at least two
separate queries, to handle each kind of camera. This makes sense, as you will
likely need different logic for 2D vs. 3D anyway.</p>
<h3 id="caveat-nearfar-values"><a class="header" href="#caveat-nearfar-values">Caveat: near/far values</a></h3>
<p>The projection contains the <code>near</code> and <code>far</code> values, which indicate the minimum
and maximum Z coordinate (depth) that can be rendered, relative to the position
(<a href="2d//fundamentals/transforms.html">transform</a>) of the camera.</p>
<p><a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/core_2d/struct.Camera2dBundle.html"><code>Camera2dBundle</code></a> sets them appropriately for 2D:
<code>-1000.0</code> to <code>1000.0</code>, allowing entities to be displayed on both positive and
negative Z coordinates. However, if you create the
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.OrthographicProjection.html"><code>OrthographicProjection</code></a> yourself, to change any
other settings, you need to set these values yourself. The default value of the
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.OrthographicProjection.html"><code>OrthographicProjection</code></a> struct is designed for
3D and has a <code>near</code> value of <code>0.0</code>, which means you might not be able to see
your 2D entities.</p>
<pre><code class="language-rust no_run noplayground">commands.spawn((
    Camera2dBundle {
        projection: OrthographicProjection {
            // don't forget to set `near` and `far`
            near: -1000.0,
            far: 1000.0,
            // ... any other settings you want to change ...
            ..default()
        },
        ..default()
    },
    MyCameraMarker,
));</code></pre>
<p>A more foolproof way to go about this is to use a temporary variable, to let the
bundle do its thing, and then mutate whatever you want. This way, you don't have
to worry about the exact values or getting anything wrong:</p>
<pre><code class="language-rust no_run noplayground">let mut camera_bundle = Camera2dBundle::default();
// change the settings we want to change:
camera_bundle.projection.scale = 2.0;
camera_bundle.transform.rotate_z(30f32.to_radians());
// ...

commands.spawn((
    camera_bundle,
    MyCameraMarker,
));</code></pre>
<h3 id="scaling-mode"><a class="header" href="#scaling-mode">Scaling Mode</a></h3>
<p>You can set the <a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/enum.ScalingMode.html"><code>ScalingMode</code></a> according to how you want to
handle window size / resolution.</p>
<p>The default for Bevy 2D cameras is to have 1 screen pixel correspond to 1 world
unit, thus allowing you to think of everything in &quot;pixels&quot;. When the window is
resized, that causes more or less content to be seen.</p>
<p>If you want to keep this window resizing behavior, but change the mapping of screen
pixels to world units, use <code>ScalingMode::WindowSize(x)</code> with a value other than <code>1.0</code>.
The value represents the number of screen pixels for one world unit.</p>
<p>If, instead, you want to always fit the same amount of content
on-screen, regardless of resolution, you should use something like
<code>ScalingMode::FixedVertical</code> or <code>ScalingMode::AutoMax</code>. Then, you can directly
specify how many units you want to display on-screen, and your content will
be upscaled/downscaled as appropriate to fit the window size.</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::camera::ScalingMode;

let mut my_2d_camera_bundle = Camera2dBundle::default();
// For this example, let's make the screen/window height correspond to
// 1600.0 world units. The width will depend on the aspect ratio.
my_2d_camera_bundle.projection.scaling_mode = ScalingMode::FixedVertical(1600.0);
my_2d_camera_bundle.transform = Transform::from_xyz(100.0, 200.0, 0.0);

commands.spawn((
    my_2d_camera_bundle,
    MyCameraMarker,
));</code></pre>
<h3 id="zooming"><a class="header" href="#zooming">Zooming</a></h3>
<p>To &quot;zoom&quot; in 2D, you can change the orthographic projection's <code>scale</code>. This
allows you to just scale everything by some factor, regardless of the
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/enum.ScalingMode.html"><code>ScalingMode</code></a> behavior.</p>
<pre><code class="language-rust no_run noplayground">fn zoom_scale(
    mut query_camera: Query&lt;&amp;mut OrthographicProjection, With&lt;MyCameraMarker&gt;&gt;,
) {
    let mut projection = query_camera.single_mut();
    // zoom in
    projection.scale /= 1.25;
    // zoom out
    projection.scale *= 1.25;
}</code></pre>
<p>Alternatively, you can reconfigure the <a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/enum.ScalingMode.html"><code>ScalingMode</code></a>. This
way you can be confident about how exactly coordinates/units map to the
screen. This also helps avoid scaling artifacts with 2D assets, especially
pixel art.</p>
<pre><code class="language-rust no_run noplayground">fn zoom_scalingmode(
    mut query_camera: Query&lt;&amp;mut OrthographicProjection, With&lt;MyCameraMarker&gt;&gt;,
) {
    use bevy::render::camera::ScalingMode;

    let mut projection = query_camera.single_mut();
    // 4 screen pixels to world/game pixel
    projection.scaling_mode = ScalingMode::WindowSize(4.0);
    // 6 screen pixels to world/game pixel
    projection.scaling_mode = ScalingMode::WindowSize(6.0);
}</code></pre>
<p>Consider having a list of predefined &quot;zoom levels&quot; / scale values, so that you
can make sure your game always looks good.</p>
<p>If you are making a pixel-art game, you want to make sure the default texture
filtering mode is set to Nearest (and not Linear), if you want your pixels
to appear crisp instead of blurry:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins(
            DefaultPlugins
                .set(ImagePlugin::default_nearest())
        )
        // ...
        .run();
}</code></pre>
<p>However, when <em>downscaling</em>, Linear (the default) filtering is preferred
for higher quality. So, for games with high-res assets, you want to leave
it unchanged.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="2d//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-11">0.11</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="sprites-and-atlases"><a class="header" href="#sprites-and-atlases">Sprites and Atlases</a></h1>
<p>Page coming soon‚Ä¶</p>
<p>In the meantime, you can learn from Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">examples</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="bevy-3d"><a class="header" href="#bevy-3d">Bevy 3D</a></h1>
<p>This chapter covers topics relevant to making 3D games with Bevy.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="3d//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="3d-camera-setup"><a class="header" href="#3d-camera-setup">3D Camera Setup</a></h1>
<p><a href="3d//graphics/camera.html">Cameras</a> in Bevy are mandatory to see anything: they configure the
rendering.</p>
<p>This page will teach you about the specifics of 3D cameras. If you want to learn about
general non-3D specific functionality, see the <a href="3d//graphics/camera.html">general page on cameras</a>.</p>
<h2 id="creating-a-3d-camera"><a class="header" href="#creating-a-3d-camera">Creating a 3D Camera</a></h2>
<p>Bevy provides a <a href="3d//programming/bundle.html">bundle</a> that you can use to <a href="3d//programming/commands.html">spawn</a> a
camera <a href="3d//programming/ec.html#entities">entity</a>. It has reasonable defaults to set up everything
correctly.</p>
<p>You might want to set the <a href="3d//fundamentals/transforms.html">transform</a>, to position the camera.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct MyCameraMarker;

fn setup_camera(mut commands: Commands) {
    commands.spawn((
        Camera3dBundle {
            transform: Transform::from_xyz(10.0, 12.0, 16.0)
                .looking_at(Vec3::ZERO, Vec3::Y),
            ..default()
        },
        MyCameraMarker,
    ));
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_systems(Startup, setup_camera)
        .run();
}</code></pre>
<p>The &quot;looking at&quot; function is an easy way to orient a 3D camera. The second
parameter (which we provide as <code>Y</code>) is the &quot;up&quot; direction. If you want the camera
to be tilted sideways, you can use something else there. If you want to make a
top-down camera, looking straight down, you need to use something other than <code>Y</code>.</p>
<h2 id="projection-2"><a class="header" href="#projection-2">Projection</a></h2>
<p>The <a href="3d//graphics/camera.html#projection">projection</a> is what determines how coordinates map to the
<a href="3d//graphics/camera.html#viewport">viewport</a> (commonly, the screen/window).</p>
<p>3D cameras can use either a Perspective or an Orthographic projection.
Perspective is the default, and most common, choice.</p>
<p>When you spawn a 3D camera using Bevy's <a href="3d//programming/bundle.html">bundle</a>
(<a href="https://docs.rs/bevy/0.12.0/bevy/core_pipeline/core_2d/struct.Camera2dBundle.html"><code>Camera3dBundle</code></a>), it adds the
<a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/enum.Projection.html"><code>Projection</code></a> <a href="3d//programming/ec.html#components">component</a> to your
<a href="3d//programming/ec.html#entities">entity</a>, which is an <code>enum</code>, allowing either projection kind to be
used.</p>
<p>When you are working with 3D cameras and you want to access the projection, you
should <a href="3d//programming/queries.html">query</a> for the <a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.OrthographicProjection.html"><code>Projection</code></a>
<a href="3d//programming/ec.html#components">component</a> type. You can then match on the enum, to handle each
case appropriately.</p>
<pre><code class="language-rust no_run noplayground">fn debug_projection(
    query_camera: Query&lt;&amp;Projection, With&lt;MyCameraMarker&gt;&gt;,
) {
    let projection = query_camera.single();
    match projection {
        Projection::Perspective(persp) =&gt; {
            // we have a perspective projection
        }
        Projection::Orthographic(ortho) =&gt; {
            // we have an orthographic projection
        }
    }
}</code></pre>
<p>Note that this is different from <a href="3d//2d/camera.html#projection">2D</a>. If you are
making a library or some other code that should be able to handle both 2D and
3D, you cannot make a single <a href="3d//programming/queries.html">query</a> to access both 2D and 3D
cameras. You should create separate <a href="3d//programming/systems.html">systems</a>, or at least two
separate queries, to handle each kind of camera. This makes sense, as you will
likely need different logic for 2D vs. 3D anyway.</p>
<h3 id="perspective-projections"><a class="header" href="#perspective-projections">Perspective Projections</a></h3>
<p>Perspective creates a realistic sense of 3D space. Things appear smaller the
further away they are from the camera. This is how things appear to the human
eye, and to real-life cameras.</p>
<p>The most important variable here is the FOV (Field-of-View). The FOV determines
the strength of the perspective effect. The FOV is the angle covered by the
height of the screen/image.</p>
<p>A larger FOV is like a wide-angle camera lens. It makes everything appear more
distant, stretched, &quot;zoomed out&quot;. You can see more on-screen.</p>
<p>A smaller FOV is like a telephoto camera lens. It makes everything appear closer
and flatter, &quot;zoomed in&quot;. You can see less on-screen.</p>
<p>For reference, a good neutral value is 45¬∞ (narrower, Bevy default) or 60¬∞
(wider). 90¬∞ is very wide. 30¬∞ is very narrow.</p>
<pre><code class="language-rust no_run noplayground">commands.spawn((
    Camera3dBundle {
        projection: PerspectiveProjection {
            // We must specify the FOV in radians.
            // Rust can convert degrees to radians for us.
            fov: 60.0_f32.to_radians(),
            ..default()
        }.into(),
        transform: Transform::from_xyz(10.0, 12.0, 16.0)
            .looking_at(Vec3::ZERO, Vec3::Y),
        ..default()
    },
    MyCameraMarker,
));</code></pre>
<p><img src="3d//img/camera-3d-fov.png" alt="Side-by-side comparison of different FOV values." /></p>
<p>In the above image, we are halving/doubling the FOV and doubling/halving
how far away the camera is positioned, to compensate. Note how you can see
pretty much the same 3D content, but the higher FOV looks more stretched
and has a stronger 3D perspective effect.</p>
<p>Internally, Bevy's perspective projection uses an <a href="https://developer.nvidia.com/content/depth-precision-visualized">infinite reversed
Z</a> configuration. This allows for good numeric
precision for both nearby and far away objects, avoiding visual artifacts.</p>
<h4 id="zooming-1"><a class="header" href="#zooming-1">Zooming</a></h4>
<p>To &quot;zoom&quot;, change the perspective projection's FOV.</p>
<pre><code class="language-rust no_run noplayground">fn zoom_perspective(
    mut query_camera: Query&lt;&amp;mut Projection, With&lt;MyCameraMarker&gt;&gt;,
) {
    // assume perspective. do nothing if orthographic.
    let Projection::Perspective(persp) = query_camera.single_mut().into_inner() else {
        return;
    };
    // zoom in
    persp.fov /= 1.25;
    // zoom out
    persp.fov *= 1.25;
}</code></pre>
<p>If the camera does not move, decreasing the FOV makes everything appear closer
and increasing it makes everything appear more distant:</p>
<p><img src="3d//img/camera-3d-fov-zoom.png" alt="Side-by-side comparison of a &quot;zoomed in&quot; (small FOV) and a &quot;zoomed out&quot; (large FOV) 3D scene" /></p>
<p>Contrast this with moving the camera itself (using the
<a href="3d//fundamentals/transforms.html">transform</a>) closer or further away, while keeping the FOV the
same:</p>
<p><img src="3d//img/camera-3d-position.png" alt="Side-by-side comparison of a camera positioned nearer to vs. further away from a 3D scene" /></p>
<p>In some applications (such as 3D editors), moving the camera might be preferable,
instead of changing the FOV.</p>
<h3 id="orthographic-projections"><a class="header" href="#orthographic-projections">Orthographic Projections</a></h3>
<p>An Orthographic projection makes everything always look the same size,
regardless of the distance from the camera. It can feel like if 3D was squashed
down into 2D.</p>
<p>Orthographic is useful for applications such as CAD and engineering, where you
want to accurately represent the dimensions of an object. Some games (notably
simulation games) might use orthographic as an artistic choice.</p>
<p>Orthographic can feel confusing and unintuitive to some people, because it does
not create any sense of 3D space. You cannot tell how far away anything is. It
creates a perfectly &quot;flat&quot; look. When displayed from a top-down diagonal angle,
this artistic style is sometimes referred to as &quot;isometric&quot;.</p>
<p>You should set the <a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/enum.ScalingMode.html"><code>ScalingMode</code></a> according to how you want
to handle window size / resolution.</p>
<pre><code class="language-rust no_run noplayground">use bevy::render::camera::ScalingMode;

commands.spawn((
    Camera3dBundle {
        projection: OrthographicProjection {
            // For this example, let's make the screen/window height
            // correspond to 16.0 world units.
            scaling_mode: ScalingMode::FixedVertical(16.0),
            ..default()
        }.into(),
        // the distance doesn't really matter for orthographic,
        // it should look the same (though it might affect
        // shadows and clipping / culling)
        transform: Transform::from_xyz(10.0, 12.0, 16.0)
            .looking_at(Vec3::ZERO, Vec3::Y),
        ..default()
    },
    MyCameraMarker,
));</code></pre>
<p><img src="3d//img/camera-3d-orthographic.png" alt="Visualization of a 3D scene with orthographic projection" /></p>
<h4 id="zooming-2"><a class="header" href="#zooming-2">Zooming</a></h4>
<p>To &quot;zoom&quot;, change the orthographic projection's scale. The scale determines
how much of the scene is visible.</p>
<pre><code class="language-rust no_run noplayground">fn zoom_orthographic(
    mut query_camera: Query&lt;&amp;mut Projection, With&lt;MyCameraMarker&gt;&gt;,
) {
    // assume orthographic. do nothing if perspective.
    let Projection::Orthographic(ortho) = query_camera.single_mut().into_inner() else {
        return;
    };
    // zoom in
    ortho.scale /= 1.25;
    // zoom out
    ortho.scale *= 1.25;
}</code></pre>
<p><img src="3d//img/camera-3d-orthographic-zoom.png" alt="Side-by-side comparison of different orthographic projection scale in 3D" /></p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="3d//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="3d-models-and-scenes-gltf"><a class="header" href="#3d-models-and-scenes-gltf">3D Models and Scenes (GLTF)</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/3d/load_gltf.rs"><code>load_gltf</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/3d/update_gltf_scene.rs"><code>update_gltf_scene</code></a>.</p>
<hr />
<p>Bevy uses the GLTF 2.0 file format for 3D assets.</p>
<p>(other formats may be unofficially available via 3rd-party plugins)</p>
<h2 id="quick-start-spawning-3d-models-into-your-world"><a class="header" href="#quick-start-spawning-3d-models-into-your-world">Quick-Start: Spawning 3D Models into your World</a></h2>
<p>The simplest use case is to just load a &quot;3D model&quot; and spawn it into the game world.</p>
<p>&quot;3D models&quot; can often be complex, consisting of multiple parts. Think of a
house: the windows, roof, doors, etc., are separate pieces, that are likely
made of multiple meshes, materials, and textures. Bevy would technically
need multiple ECS Entities to represent and render the whole thing.</p>
<p>This is why your GLTF &quot;model&quot; is represented by Bevy as a
[Scene][cb::scene]. This way, you can easily spawn it, and Bevy will create
all the relevant <a href="3d//fundamentals/hierarchy.html">child entities</a> and configure them correctly.</p>
<pre><code class="language-rust no_run noplayground">fn spawn_gltf(
    mut commands: Commands,
    ass: Res&lt;AssetServer&gt;,
) {
    // note that we have to include the `Scene0` label
    let my_gltf = ass.load(&quot;my.glb#Scene0&quot;);

    // to position our 3d model, simply use the Transform
    // in the SceneBundle
    commands.spawn(SceneBundle {
        scene: my_gltf,
        transform: Transform::from_xyz(2.0, 0.0, -5.0),
        ..Default::default()
    });
}</code></pre>
<p>You could also use GLTF files to load an entire map/level. It works the same way.</p>
<p>The above example assumes that you have a simple GLTF file containing only
one &quot;default scene&quot;. GLTF is a very flexible file format. A single file can
contain many &quot;models&quot; or more complex &quot;scenes&quot;. To get a better understanding
of GLTF and possible workflows, read the rest of this page. :)</p>
<h2 id="introduction-to-gltf"><a class="header" href="#introduction-to-gltf">Introduction to GLTF</a></h2>
<p>GLTF is a modern open standard for exchanging 3D assets between different
3D software applications, like game engines and 3D modeling software.</p>
<p>The GLTF file format has two variants: human-readable ascii/text (<code>*.gltf</code>)
and binary (<code>*.glb</code>). The binary format is more compact and preferable
for packaging the assets with your game. The text format may be useful for
development, as it can be easier to manually inspect using a text editor.</p>
<p>A GLTF file can contain many objects (sub-assets): meshes, materials,
textures, scenes, animation clips. When loading a GLTF file, Bevy will load
all of the assets contained inside. They will be mapped to the <a href="3d//builtins.html#assets">appropriate
Bevy-internal asset types</a>.</p>
<h2 id="the-gltf-sub-assets"><a class="header" href="#the-gltf-sub-assets">The GLTF sub-assets</a></h2>
<p>GLTF terminology can be confusing, as it sometimes uses the same words to
refer to different things, compared to Bevy. This section will try explain
the various GLTF terms.</p>
<p>To understand everything, it helps to mentally consider how these concepts are
represented in different places: in your 3D modeling software (like Blender),
in the GLTF file itself, and in Bevy.</p>
<p>GLTF <strong>Scenes</strong> are what you spawn into your game world. This is typically
what you see on the screen in your 3D modeling software. Scenes combine
all of the data needed for the game engine to create all the needed
entities to represent what you want. Conceptually, think of a scene as one
&quot;unit&quot;. Depending on your use case, this could be one &quot;3d model&quot;,
or even a whole map or game level. In Bevy, these are represented as Bevy
Scenes with all the child ECS entities.</p>
<p>GLTF Scenes are composed of GLTF <strong>Nodes</strong>. These describe the &quot;objects&quot;
in the scene, typically GLTF Meshes, but can also be other things like
Cameras and Lights. Each GLTF Node has a transform for positioning it in
the scene. GLTF Nodes do not have a core Bevy equivalent; Bevy just uses
this data to create the ECS Entities inside of a Scene. Bevy has a special
<a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.GltfNode.html"><code>GltfNode</code></a> asset type, if you need access to this data.</p>
<p>GLTF <strong>Meshes</strong> represent one conceptual &quot;3D object&quot;. These correspond
to the &quot;objects&quot; in your 3D modeling software. GLTF Meshes may be complex
and composed of multiple smaller pieces, called GLTF Primitives, each of
which may use a different Material. GLTF Meshes do not have a core Bevy
equivalent, but there is a special <a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.GltfMesh.html"><code>GltfMesh</code></a> asset type,
which describes the primitives.</p>
<p>GLTF <strong>Primitives</strong> are individual &quot;units of 3D geometry&quot;, for the purposes of
rendering. They contain the actual geometry / vertex data, and reference the
Material to be used when drawing. In Bevy, each GLTF Primitive is represented
as a Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a> asset, and must be spawned as a separate ECS
Entity to be rendered.</p>
<p>GLTF <strong>Materials</strong> describe the shading parameters for the surfaces of
your 3D models. They have full support for Physically-Based Rendering
(PBR). They also reference the textures to use. In Bevy, they are represented
as <a href="https://docs.rs/bevy/0.9.1/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a> assets, as used by the Bevy
PBR 3D renderer.</p>
<p>GLTF <strong>Textures</strong> (images) can be embedded inside the GLTF file, or stored
externally in separate image files alongside it. For example, you can have
your textures as separate PNG/JPEG/KTX2 files for ease of development, or
package them all inside the GLTF file for ease of distribution. In Bevy,
GLTF textures are loaded as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/render/texture/struct.Image.html"><code>Image</code></a> assets.</p>
<p>GLTF <strong>Samplers</strong> describe the settings for how the GPU should use a
given Texture. Bevy does not keep these separate; this data is stored
inside the Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/render/texture/struct.Image.html"><code>Image</code></a> asset (the <code>sampler</code> field of type
<a href="https://docs.rs/bevy/0.9.1/bevy/render/render_resource/struct.SamplerDescriptor.html"><code>SamplerDescriptor</code></a>).</p>
<p>GLTF <strong>Animations</strong> describe animations that interpolate various values,
such as transforms or mesh skeletons, over time. In Bevy, these are loaded
as <a href="https://docs.rs/bevy/0.9.1/bevy/animation/struct.AnimationClip.html"><code>AnimationClip</code></a> assets.</p>
<h2 id="gltf-usage-patterns"><a class="header" href="#gltf-usage-patterns">GLTF Usage Patterns</a></h2>
<p>A single GLTF file can contain any number of sub-assets of any of the above
types, referring to each other however they like.</p>
<p>Because GLTF is so flexible, it is up to you how to structure your assets.</p>
<p>A single GLTF file might be used:</p>
<ul>
<li>To represent a single &quot;3D model&quot;, containing a single
GLTF Scene with the model, so you can spawn it into your game.</li>
<li>To represent a whole level, as a GLTF Scene, possibly also including
the camera. This lets you load and spawn a whole level/map at once.</li>
<li>To represent sections of a level/map, such as a rooms, as separate GLTF Scenes.
They can share meshes and textures if needed.</li>
<li>To contain a set of many different &quot;3D models&quot;, each as a separate GLTF Scene.
This lets you load and manage the whole collection at once and spawn them individually as needed.</li>
<li>‚Ä¶ others?</li>
</ul>
<h2 id="tools-for-creating-gltf-assets"><a class="header" href="#tools-for-creating-gltf-assets">Tools for Creating GLTF Assets</a></h2>
<p>If you are using a recent version of Blender (2.8+) for 3D modeling, GLTF
is supported out of the box. Just export and choose GLTF as the format.</p>
<p>For other tools, you can try these exporter plugins:</p>
<ul>
<li><a href="https://doc.babylonjs.com/extensions/Exporters/Blender_to_glTF">Old Blender (2.79)</a></li>
<li><a href="https://doc.babylonjs.com/extensions/Exporters/3DSMax_to_glTF">3DSMax</a></li>
<li><a href="https://doc.babylonjs.com/extensions/Exporters/Maya_to_glTF">Autodesk Maya</a>
<ul>
<li>(or this <a href="https://kashika.co.jp/product/gltfexporter/">alternative</a>)</li>
</ul>
</li>
</ul>
<p>Be sure to check your export settings to make sure the GLTF file contains
everything you expect.</p>
<p>If you need Tangents for normal maps, it is recommended that you include them
in your GLTF files. This avoids Bevy having to autogenerate them at runtime.
Many 3D editors do not enable this option by default.</p>
<h3 id="textures"><a class="header" href="#textures">Textures</a></h3>
<p>For your Textures / image data, the GLTF format specification officially
limits the supported formats to just PNG, JPEG, or Basis. However, Bevy does
not enforce such &quot;artificial limitations&quot;. You can use any <a href="3d//builtins.html#file-formats">image format
supported by Bevy</a>.</p>
<p>Your 3D editor will likely export your GLTF with PNG textures. This will
&quot;just work&quot; and is nice for simple use cases.</p>
<p>However, mipmaps and compressed textures are very important to get good GPU
performance, memory (VRAM) usage, and visual quality. You will only get these
benefits if you use a format like KTX2 or DDS, that supports these features.</p>
<p>We recommend that you use KTX2, which natively supports all GPU texture
functionality + additional <code>zstd</code> compression on top, to reduce file size.
If you do this, don't forget to enable the <code>ktx2</code> and <code>zstd</code> <a href="3d//setup/bevy-config.html">cargo
features</a> for Bevy.</p>
<p>You can use the <a href="https://github.com/superdump/klafsa"><code>klafsa</code></a> tool to convert all the textures
used in your GLTF files from PNG/JPEG into KTX2, with mipmaps and GPU texture
compression of your choice.</p>
<pre><code>TODO: show an example workflow for converting textures into the &quot;optimal&quot; format
</code></pre>
<h2 id="using-gltf-sub-assets-in-bevy"><a class="header" href="#using-gltf-sub-assets-in-bevy">Using GLTF Sub-Assets in Bevy</a></h2>
<p>The various sub-assets contained in a GLTF file can be addressed in two ways:</p>
<ul>
<li>by index (integer id, in the order they appear in the file)</li>
<li>by name (text string, the names you set in your 3D modeling software
when creating the asset, which can be exported into the GLTF)</li>
</ul>
<p>To get handles to the respective assets in Bevy, you can use the
<a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.Gltf.html"><code>Gltf</code></a> <a href="3d/gltf.html#gltf-master-asset">&quot;master asset&quot;</a>, or alternatively,
<a href="3d/gltf.html#assetpath-with-labels">AssetPath with Labels</a>.</p>
<h3 id="gltf-master-asset"><a class="header" href="#gltf-master-asset"><code>Gltf</code> master asset</a></h3>
<p>If you have a complex GLTF file, this is likely the most flexible and useful
way of navigating its contents and using the different things inside.</p>
<p>You have to wait for the GLTF file to load, and then use the <a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.Gltf.html"><code>Gltf</code></a> asset.</p>
<pre><code class="language-rust no_run noplayground">use bevy::gltf::Gltf;

/// Helper resource for tracking our asset
#[derive(Resource)]
struct MyAssetPack(Handle&lt;Gltf&gt;);

fn load_gltf(
    mut commands: Commands,
    ass: Res&lt;AssetServer&gt;,
) {
    let gltf = ass.load(&quot;my_asset_pack.glb&quot;);
    commands.insert_resource(MyAssetPack(gltf));
}

fn spawn_gltf_objects(
    mut commands: Commands,
    my: Res&lt;MyAssetPack&gt;,
    assets_gltf: Res&lt;Assets&lt;Gltf&gt;&gt;,
) {
    // if the GLTF has loaded, we can navigate its contents
    if let Some(gltf) = assets_gltf.get(&amp;my.0) {
        // spawn the first scene in the file
        commands.spawn(SceneBundle {
            scene: gltf.scenes[0].clone(),
            ..Default::default()
        });

        // spawn the scene named &quot;YellowCar&quot;
        commands.spawn(SceneBundle {
            scene: gltf.named_scenes[&quot;YellowCar&quot;].clone(),
            transform: Transform::from_xyz(1.0, 2.0, 3.0),
            ..Default::default()
        });

        // PERF: the `.clone()`s are just for asset handles, don't worry :)
    }
}</code></pre>
<p>For a more convoluted example, say we want to directly create a 3D PBR
entity, for whatever reason. (This is not recommended; you should probably
just use scenes)</p>
<pre><code class="language-rust no_run noplayground">use bevy::gltf::GltfMesh;

fn gltf_manual_entity(
    mut commands: Commands,
    my: Res&lt;MyAssetPack&gt;,
    assets_gltf: Res&lt;Assets&lt;Gltf&gt;&gt;,
    assets_gltfmesh: Res&lt;Assets&lt;GltfMesh&gt;&gt;,
) {
    if let Some(gltf) = assets_gltf.get(&amp;my.0) {
        // Get the GLTF Mesh named &quot;CarWheel&quot;
        // (unwrap safety: we know the GLTF has loaded already)
        let carwheel = assets_gltfmesh.get(&amp;gltf.named_meshes[&quot;CarWheel&quot;]).unwrap();

        // Spawn a PBR entity with the mesh and material of the first GLTF Primitive
        commands.spawn(PbrBundle {
            mesh: carwheel.primitives[0].mesh.clone(),
            // (unwrap: material is optional, we assume this primitive has one)
            material: carwheel.primitives[0].material.clone().unwrap(),
            ..Default::default()
        });
    }
}</code></pre>
<h3 id="assetpath-with-labels"><a class="header" href="#assetpath-with-labels">AssetPath with Labels</a></h3>
<p>This is another way to access specific sub-assets. It is less reliable,
but may be easier to use in some cases.</p>
<p>Use the <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a> to convert a path string into a
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.Handle.html"><code>Handle</code></a>.</p>
<p>The advantage is that you can get handles to your sub-assets immediately,
even if your GLTF file hasn't loaded yet.</p>
<p>The disadvantage is that it is more error-prone. If you specify a sub-asset
that doesn't actually exist in the file, or mis-type the label, or use the
wrong label, it will just silently not work. Also, currently only using a
numerial index is supported. You cannot address sub-assets by name.</p>
<pre><code class="language-rust no_run noplayground">fn use_gltf_things(
    mut commands: Commands,
    ass: Res&lt;AssetServer&gt;,
) {
    // spawn the first scene in the file
    let scene0 = ass.load(&quot;my_asset_pack.glb#Scene0&quot;);
    commands.spawn(SceneBundle {
        scene: scene0,
        ..Default::default()
    });

    // spawn the second scene
    let scene1 = ass.load(&quot;my_asset_pack.glb#Scene1&quot;);
    commands.spawn(SceneBundle {
        scene: scene1,
        transform: Transform::from_xyz(1.0, 2.0, 3.0),
        ..Default::default()
    });
}</code></pre>
<p>The following asset labels are supported (<code>{}</code> is the numerical index):</p>
<ul>
<li><code>Scene{}</code>: GLTF Scene as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/scene/struct.Scene.html"><code>Scene</code></a></li>
<li><code>Node{}</code>: GLTF Node as <a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.GltfNode.html"><code>GltfNode</code></a></li>
<li><code>Mesh{}</code>: GLTF Mesh as <a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.GltfMesh.html"><code>GltfMesh</code></a></li>
<li><code>Mesh{}/Primitive{}</code>: GLTF Primitive as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a></li>
<li><code>Mesh{}/Primitive{}/MorphTargets</code>: Morph target animation data for a GLTF Primitive</li>
<li><code>Texture{}</code>: GLTF Texture as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/render/texture/struct.Image.html"><code>Image</code></a></li>
<li><code>Material{}</code>: GLTF Material as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a></li>
<li><code>DefaultMaterial</code>: as above, if the GLTF file contains a default material with no index</li>
<li><code>Animation{}</code>: GLTF Animation as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/animation/struct.AnimationClip.html"><code>AnimationClip</code></a></li>
<li><code>Skin{}</code>: GLTF mesh skin as Bevy <a href="https://docs.rs/bevy/0.9.1/bevy/render/mesh/skinning/struct.SkinnedMeshInverseBindposes.html"><code>SkinnedMeshInverseBindposes</code></a></li>
</ul>
<p>The <a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.GltfNode.html"><code>GltfNode</code></a> and <a href="https://docs.rs/bevy/0.9.1/bevy/gltf/struct.GltfMesh.html"><code>GltfMesh</code></a>
asset types are only useful to help you navigate the contents of
your GLTF file. They are not core Bevy renderer types, and not used
by Bevy in any other way. The Bevy renderer expects Entities with
<a href="https://docs.rs/bevy/0.9.1/bevy/pbr/struct.MaterialMeshBundle.html"><code>MaterialMeshBundle</code></a>; for that you need the
<a href="https://docs.rs/bevy/0.9.1/bevy/render/mesh/struct.Mesh.html"><code>Mesh</code></a> and <a href="https://docs.rs/bevy/0.9.1/bevy/pbr/struct.StandardMaterial.html"><code>StandardMaterial</code></a>.</p>
<h2 id="bevy-limitations"><a class="header" href="#bevy-limitations">Bevy Limitations</a></h2>
<p>Bevy does not fully support all features of the GLTF format and has some
specific requirements about the data. Not all GLTF files can be loaded and
rendered in Bevy. Unfortunately, in many of these cases, you will not get
any error or diagnostic message.</p>
<p>Commonly-encountered limitations:</p>
<ul>
<li>Textures embedded in ascii (<code>*.gltf</code>) files (base64 encoding) cannot be loaded.
Put your textures in external files, or use the binary (<code>*.glb</code>) format.</li>
<li>Mipmaps are only supported if the texture files (in KTX2 or DDS format) contain them.
The GLTF spec requires missing mipmap data to be generated by the game engine, but Bevy
does not support this yet. If your assets are missing mipmaps, textures will look grainy/noisy.</li>
</ul>
<p>This list is not exhaustive. There may be other unsupported scenarios that I
did not know of or forgot to include here. :)</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-11">0.11</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="input-handling"><a class="header" href="#input-handling">Input Handling</a></h1>
<p>Bevy supports the following inputs:</p>
<ul>
<li><a href="/input/keyboard.html">Keyboard</a> (detect when keys are pressed or released)</li>
<li><a href="/input/char.html">Character</a> (for text input; keyboard layout handled by the OS)</li>
<li><a href="/input/mouse.html">Mouse</a> (relative motion, buttons, scrolling)
<ul>
<li><a href="/input/mouse.html#mouse-motion">Motion</a> (moving the mouse, not tied to OS cursor)</li>
<li><a href="/input/mouse.html#mouse-cursor-position">Cursor</a> (absolute pointer position)</li>
<li><a href="/input/mouse.html#mouse-buttons">Buttons</a></li>
<li><a href="/input/mouse.html#mouse-scrolling--wheel">Scrolling</a> (mouse wheel or touchpad gesture)</li>
<li><a href="/input/mouse.html#touchpad-gestures">Zoom/Rotate touchpad gestures</a></li>
</ul>
</li>
<li><a href="/input/touch.html">Touchscreen</a> (with multi-touch)</li>
<li><a href="/input/gamepad.html">Gamepad (Controller, Joystick)</a> (via the <a href="https://gitlab.com/gilrs-project/gilrs">gilrs</a> library)</li>
</ul>
<p>The following notable input devices are <em><strong>not</strong></em> supported:</p>
<ul>
<li>Accelerometers and gyroscopes for device tilt</li>
<li>Other sensors, like temperature sensors</li>
<li>Tracking individual fingers on a multi-touch trackpad, like on a touchscreen</li>
<li>Microphones and other audio input devices</li>
<li>MIDI (musical instruments), but there is an unofficial plugin: <a href="https://github.com/BlackPhlox/bevy_midi"><code>bevy_midi</code></a>.</li>
</ul>
<hr />
<p>For most input types (where it makes sense), Bevy provides two ways of
dealing with them:</p>
<ul>
<li>by checking the current state via <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/system/struct.Res.html">resources</a> (<a href="/builtins.html#input-handling-resources">input resources</a>),</li>
<li>or via <a href="/programming/events.html">events</a> (<a href="/builtins.html#input-events">input events</a>).</li>
</ul>
<p>Some inputs are only provided as events.</p>
<p>Checking state is done using <a href="/programming/res.html">resources</a> such as
<a href="https://docs.rs/bevy/0.11.0/bevy/input/struct.Input.html"><code>Input</code></a> (for binary inputs like keys or buttons),
<a href="https://docs.rs/bevy/0.11.0/bevy/input/struct.Axis.html"><code>Axis</code></a> (for analog inputs), <a href="https://docs.rs/bevy/0.11.0/bevy/input/touch/struct.Touches.html"><code>Touches</code></a>
(for fingers on a touchscreen), etc. This way of handling input is very
convenient for implementing game logic. In these scenarios, you typically
only care about the specific inputs mapped to actions in your game. You can
check specific buttons/keys to see when they get pressed/released, or what
their current state is.</p>
<p><a href="/programming/events.html">Events</a> (<a href="/builtins.html#input-events">input events</a>) are a lower-level,
more all-encompassing approach. Use them if you want to get all activity
from that class of input device, rather than only checking for specific inputs.</p>
<h2 id="input-mapping"><a class="header" href="#input-mapping">Input Mapping</a></h2>
<p>Bevy does not yet offer a built-in way to do input mapping (configure key
bindings, etc). You need to come up with your own way of translating the
inputs into logical actions in your game/app.</p>
<p>There are some community-made plugins that may help with that: <a href="https://bevyengine.org/assets/#input">see the
input-section on bevy-assets</a>. My personal recommendation:
<a href="https://github.com/leafwing-studios/leafwing-input-manager">Input Manager plugin by Leafwing Studios</a>.</p>
<p>It may be a good idea to build your own abstractions specific to your
game. For example, if you need to handle player movement, you might want to
have a system for reading inputs and converting them to your own internal
&quot;movement intent/action events&quot;, and then another system acting on those
internal events, to actually move the player. Make sure to use <a href="/programming/system-order.html">explicit
system ordering</a> to avoid lag / frame delays.</p>
<h2 id="run-conditions-1"><a class="header" href="#run-conditions-1">Run Conditions</a></h2>
<p>Bevy also provides <a href="/programming/run-criteria.html">run conditions</a> (<a href="https://docs.rs/bevy/0.11.0/bevy/input/common_conditions/index.html">see all of them
here</a>) that you can attach to your systems, if
you want a specific system to only run when a specific key or button is pressed.</p>
<p>This way, you can do input handling as part of the
<a href="/programming/intro-code.html">scheduling/configuration</a> of your <a href="/programming/systems.html">systems</a>, and
avoid running unnecessary code on the CPU.</p>
<p>Using these in real games is not recommended, because you have to hard-code the
keys, which makes it impossible to make user-configurable keybindings.</p>
<p>To support configurable keybindings, you can implement your own run conditions
that check your keybindings from the user settings.</p>
<p>If you are using the <a href="https://github.com/leafwing-studios/leafwing-input-manager">LWIM plugin</a>, it also provides support for
<a href="https://docs.rs/leafwing-input-manager/latest/leafwing_input_manager/common_conditions/index.html">a similar run-condition-based workflow</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="input//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="keyboard-input"><a class="header" href="#keyboard-input">Keyboard Input</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/input/keyboard_input.rs"><code>keyboard_input</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/input/keyboard_input_events.rs"><code>keyboard_input_events</code></a>.</p>
<hr />
<p>This page shows how to handle keyboard keys being pressed and released.</p>
<p>If you are interested in text input, see the <a href="input//input/char.html">Character Input</a> page instead.</p>
<p>Note: Command Key on Mac corresponds to the Super/Windows Key on PC.</p>
<h2 id="checking-key-state"><a class="header" href="#checking-key-state">Checking Key State</a></h2>
<p>Most commonly, you might be interested in specific known keys and detecting when
they are pressed or released. You can check specific <a href="input/keyboard.html#key-codes-and-scan-codes">Key Codes or Scan
Codes</a> using the
<a href="https://docs.rs/bevy/0.9.1/bevy/input/struct.Input.html"><code>Input&lt;KeyCode&gt;</code> / <code>Input&lt;ScanCode&gt;</code></a> <a href="input//programming/res.html">resources</a>.</p>
<pre><code class="language-rust no_run noplayground">fn keyboard_input(
    keys: Res&lt;Input&lt;KeyCode&gt;&gt;,
) {
    if keys.just_pressed(KeyCode::Space) {
        // Space was pressed
    }
    if keys.just_released(KeyCode::LControl) {
        // Left Ctrl was released
    }
    if keys.pressed(KeyCode::W) {
        // W is being held down
    }
    // we can check multiple at once with `.any_*`
    if keys.any_pressed([KeyCode::LShift, KeyCode::RShift]) {
        // Either the left or right shift are being held down
    }
    if keys.any_just_pressed([KeyCode::Delete, KeyCode::Back]) {
        // Either delete or backspace was just pressed
    }
}</code></pre>
<h2 id="keyboard-events"><a class="header" href="#keyboard-events">Keyboard Events</a></h2>
<p>To get all keyboard activity, you can use
<a href="https://docs.rs/bevy/0.9.1/bevy/input/keyboard/struct.KeyboardInput.html"><code>KeyboardInput</code></a> <a href="input//programming/events.html">events</a>:</p>
<pre><code class="language-rust no_run noplayground">fn keyboard_events(
    mut key_evr: EventReader&lt;KeyboardInput&gt;,
) {
    use bevy::input::ButtonState;

    for ev in key_evr.iter() {
        match ev.state {
            ButtonState::Pressed =&gt; {
                println!(&quot;Key press: {:?} ({})&quot;, ev.key_code, ev.scan_code);
            }
            ButtonState::Released =&gt; {
                println!(&quot;Key release: {:?} ({})&quot;, ev.key_code, ev.scan_code);
            }
        }
    }
}</code></pre>
<p>These events give you both the Key Code and Scan Code.</p>
<h2 id="key-codes-and-scan-codes"><a class="header" href="#key-codes-and-scan-codes">Key Codes and Scan Codes</a></h2>
<p>Keyboard keys can be identified by Key Code or Scan Code.</p>
<p>Key Codes represent the logical meaning of each key (usually the symbol/letter,
or function it performs). They are dependent on the keyboard layout currently
active in the user's OS. Bevy represents them with the <a href="https://docs.rs/bevy/0.9.1/bevy/input/keyboard/enum.KeyCode.html"><code>KeyCode</code></a> enum.</p>
<p>Scan Codes represent the physical key on the keyboard, regardless of the system
layout. Bevy represents them using <a href="https://docs.rs/bevy/0.9.1/bevy/input/keyboard/struct.ScanCode.html"><code>ScanCode</code></a>, which contains
an integer ID. The exact value of the integer is meaningless and OS-dependent,
but a given physical key on the keyboard will always produce the same value,
regardless of the user's language and keyboard layout settings.</p>
<h2 id="best-practices-for-key-bindings"><a class="header" href="#best-practices-for-key-bindings">Best Practices for Key Bindings</a></h2>
<p>Here is some advice for how to implement user-friendly remappable key-bindings
for your game, that can work well for international users or those with
non-QWERTY keyboard layouts.</p>
<p>This section assumes that you have implemented some sort of system to allow the
user to reconfigure their keybindings. You want to prompt the user to press
their preferred key for a given in-game action, so you can store/remember it
and later use it for gameplay.</p>
<p>The problem is that, if you simply use Key Codes, then users might accidentally
switch their OS keyboard layout mid-game and suddenly have their keyboard not
work as expected.</p>
<p>You should detect and store the user's chosen keys using Scan Codes, and use
Scan Codes for detecting keyboard input during gameplay.</p>
<p>Key Codes can still be used for UI purposes, like to display the chosen key
to the user.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="input//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-11">0.11</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="mouse"><a class="header" href="#mouse">Mouse</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.11.0/examples/input/mouse_input.rs"><code>mouse_input</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.11.0/examples/input/mouse_input_events.rs"><code>mouse_input_events</code></a>.</p>
<hr />
<h2 id="mouse-buttons"><a class="header" href="#mouse-buttons">Mouse Buttons</a></h2>
<p>Similar to <a href="input//input/keyboard.html">keyboard input</a>, mouse buttons are available as an
<a href="https://docs.rs/bevy/0.11.0/bevy/input/struct.Input.html"><code>Input</code></a> state <a href="input//programming/res.html">resource</a>, <a href="input//programming/events.html">events</a>, and <a href="input//programming/run-criteria.html">run
conditions</a> (<a href="https://docs.rs/bevy/0.11.0/bevy/input/common_conditions/index.html">see list</a>). Use whichever
pattern feels most appropriate to your use case.</p>
<p>You can check the state of specific mouse buttons using
<a href="https://docs.rs/bevy/0.11.0/bevy/input/mouse/enum.MouseButton.html"><code>Input&lt;MouseButton&gt;</code></a>:</p>
<pre><code class="language-rust no_run noplayground">fn mouse_button_input(
    buttons: Res&lt;Input&lt;MouseButton&gt;&gt;,
) {
    if buttons.just_pressed(MouseButton::Left) {
        // Left button was pressed
    }
    if buttons.just_released(MouseButton::Left) {
        // Left Button was released
    }
    if buttons.pressed(MouseButton::Right) {
        // Right Button is being held down
    }
    // we can check multiple at once with `.any_*`
    if buttons.any_just_pressed([MouseButton::Left, MouseButton::Right]) {
        // Either the left or the right button was just pressed
    }
}</code></pre>
<p>You can also iterate over any buttons that have been pressed or released:</p>
<pre><code class="language-rust no_run noplayground">fn mouse_button_iter(
    buttons: Res&lt;Input&lt;MouseButton&gt;&gt;,
) {
    for button in buttons.get_pressed() {
        println!(&quot;{:?} is currently held down&quot;, button);
    }
    for button in buttons.get_just_pressed() {
        println!(&quot;{:?} was pressed&quot;, button);
    }
    for button in buttons.get_just_released() {
        println!(&quot;{:?} was released&quot;, button);
    }
}</code></pre>
<p>Alternatively, you can use <a href="https://docs.rs/bevy/0.11.0/bevy/input/mouse/struct.MouseButtonInput.html"><code>MouseButtonInput</code></a>
<a href="input//programming/events.html">events</a> to get all activity:</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::mouse::MouseButtonInput;

fn mouse_button_events(
    mut mousebtn_evr: EventReader&lt;MouseButtonInput&gt;,
) {
    use bevy::input::ButtonState;

    for ev in mousebtn_evr.iter() {
        match ev.state {
            ButtonState::Pressed =&gt; {
                println!(&quot;Mouse button press: {:?}&quot;, ev.button);
            }
            ButtonState::Released =&gt; {
                println!(&quot;Mouse button release: {:?}&quot;, ev.button);
            }
        }
    }
}</code></pre>
<p>You can also use Bevy's built-in <a href="input//input.html#run-conditions">run conditions</a>, so your
<a href="input//programming/systems.html">systems</a> only run on mouse button input. Only recommended for
prototyping; for proper projects you might want to implement your own run
conditions, to support rebinding or other custom use cases.</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::common_conditions::*;

app.add_systems(Update, (
    handle_middleclick
        .run_if(input_just_pressed(MouseButton::Middle)),
    handle_drag
        .run_if(input_pressed(MouseButton::Left)),
));</code></pre>
<h2 id="mouse-scrolling--wheel"><a class="header" href="#mouse-scrolling--wheel">Mouse Scrolling / Wheel</a></h2>
<p>To detect scrolling input, use <a href="https://docs.rs/bevy/0.11.0/bevy/input/mouse/struct.MouseWheel.html"><code>MouseWheel</code></a> <a href="input//programming/events.html">events</a>:</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::mouse::MouseWheel;

fn scroll_events(
    mut scroll_evr: EventReader&lt;MouseWheel&gt;,
) {
    use bevy::input::mouse::MouseScrollUnit;
    for ev in scroll_evr.iter() {
        match ev.unit {
            MouseScrollUnit::Line =&gt; {
                println!(&quot;Scroll (line units): vertical: {}, horizontal: {}&quot;, ev.y, ev.x);
            }
            MouseScrollUnit::Pixel =&gt; {
                println!(&quot;Scroll (pixel units): vertical: {}, horizontal: {}&quot;, ev.y, ev.x);
            }
        }
    }
}</code></pre>
<p>The <a href="https://docs.rs/bevy/0.11.0/bevy/input/mouse/enum.MouseScrollUnit.html"><code>MouseScrollUnit</code></a> enum is important: it tells
you the type of scroll input. <code>Line</code> is for hardware with fixed steps, like
the wheel on desktop mice. <code>Pixel</code> is for hardware with smooth (fine-grained)
scrolling, like laptop touchpads.</p>
<p>You should probably handle each of these differently (with different
sensitivity settings), to provide a good experience on both types of hardware.</p>
<p><strong>Note:</strong> the <code>Line</code> unit is not guaranteed to have whole number values/steps!
At least <a href="input//platforms/macos.html">macOS</a> does non-linear scaling / acceleration of
scrolling at the OS level, meaning your app will get weird values for the number
of lines, even when using a regular PC mouse with a fixed-stepping scroll wheel.</p>
<h2 id="mouse-motion"><a class="header" href="#mouse-motion">Mouse Motion</a></h2>
<p>Use this if you don't care about the exact position of the mouse cursor,
but rather you just want to see how much it moved from frame to frame. This
is useful for things like controlling a 3D camera.</p>
<p>Use <a href="https://docs.rs/bevy/0.11.0/bevy/input/mouse/struct.MouseMotion.html"><code>MouseMotion</code></a> <a href="input//programming/events.html">events</a>. Whenever the
mouse is moved, you will get an event with the delta.</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::mouse::MouseMotion;

fn mouse_motion(
    mut motion_evr: EventReader&lt;MouseMotion&gt;,
) {
    for ev in motion_evr.iter() {
        println!(&quot;Mouse moved: X: {} px, Y: {} px&quot;, ev.delta.x, ev.delta.y);
    }
}</code></pre>
<p>You might want to <a href="input//window/mouse-grab.html">grab/lock the mouse inside the game
window</a>.</p>
<h2 id="mouse-cursor-position"><a class="header" href="#mouse-cursor-position">Mouse Cursor Position</a></h2>
<p>Use this if you want to accurately track the position pointer / cursor. This is
useful for things like clicking and hovering over objects in your game or UI.</p>
<p>You can get the current coordinates of the mouse pointer, from the respective
<a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.Window.html"><code>Window</code></a> (if the mouse is currently inside that window):</p>
<pre><code class="language-rust no_run noplayground">use bevy::window::PrimaryWindow;

fn cursor_position(
    q_windows: Query&lt;&amp;Window, With&lt;PrimaryWindow&gt;&gt;,
) {
    // Games typically only have one window (the primary window)
    if let Some(position) = q_windows.single().cursor_position() {
        println!(&quot;Cursor is inside the primary window, at {:?}&quot;, position);
    } else {
        println!(&quot;Cursor is not in the game window.&quot;);
    }
}</code></pre>
<p>To detect when the pointer is moved, use <a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.CursorMoved.html"><code>CursorMoved</code></a>
<a href="input//programming/events.html">events</a> to get the updated coordinates:</p>
<pre><code class="language-rust no_run noplayground">fn cursor_events(
    mut cursor_evr: EventReader&lt;CursorMoved&gt;,
) {
    for ev in cursor_evr.iter() {
        println!(
            &quot;New cursor position: X: {}, Y: {}, in Window ID: {:?}&quot;,
            ev.position.x, ev.position.y, ev.window
        );
    }
}</code></pre>
<p>Note that you can only get the position of the mouse inside a window;
you cannot get the global position of the mouse in the whole OS Desktop /
on the screen as a whole.</p>
<p>The coordinates you get are in &quot;window space&quot;. They represent window
pixels, and the origin is the bottom left corner of the window. They do not
relate to your camera or in-game coordinates in any way. <a href="input//cookbook/cursor2world.html">See this cookbook
example</a> for converting these window cursor coordinates
into world-space coordinates.</p>
<p>To track when the mouse cursor enters and leaves your window(s), use
<a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.CursorEntered.html"><code>CursorEntered</code></a> and <a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.CursorLeft.html"><code>CursorLeft</code></a>
<a href="input//programming/events.html">events</a>.</p>
<h2 id="touchpad-gestures"><a class="header" href="#touchpad-gestures">Touchpad Gestures</a></h2>
<p>Bevy supports the two-finger rotate and pinch-to-zoom gestures, but they
currently only work on macOS, where the OS provides special events for them.</p>
<p>If you are interested in supporting these gestures in your app, you can do so
using <a href="https://docs.rs/bevy/0.11.0/bevy/input/touchpad/struct.TouchpadRotate.html"><code>TouchpadRotate</code></a> and
<a href="https://docs.rs/bevy/0.11.0/bevy/input/touchpad/struct.TouchpadMagnify.html"><code>TouchpadMagnify</code></a> <a href="input//programming/events.html">events</a>:</p>
<pre><code class="language-rust no_run noplayground">use bevy::input::touchpad::{TouchpadMagnify, TouchpadRotate};

// these only work on macOS
fn touchpad_gestures(
    mut evr_touchpad_magnify: EventReader&lt;TouchpadMagnify&gt;,
    mut evr_touchpad_rotate: EventReader&lt;TouchpadRotate&gt;,
) {
    for ev_magnify in evr_touchpad_magnify.iter() {
        // Positive numbers are zooming in
        // Negative numbers are zooming out
        println!(&quot;Touchpad zoom by {}&quot;, ev_magnify.0);
    }
    for ev_rotate in evr_touchpad_rotate.iter() {
        // Positive numbers are anticlockwise
        // Negative numbers are clockwise
        println!(&quot;Touchpad rotate by {}&quot;, ev_rotate.0);
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="input//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-11">0.11</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="text--character-input"><a class="header" href="#text--character-input">Text / Character Input</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.11.0/examples/input/char_input_events.rs"><code>char_input_events</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.11.0/examples/input/text_input.rs"><code>text_input</code></a>.</p>
<hr />
<p>Use this (<em>not</em> <a href="input//input/keyboard.html">keyboard input</a>) if you want to implement
text input in a Bevy app. This way, everything works as the user expects
from their operating system, including Unicode support.</p>
<p>Bevy will produce a <a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.ReceivedCharacter.html"><code>ReceivedCharacter</code></a>
<a href="input//programming/events.html">event</a> for every Unicode code point coming from the OS.</p>
<p>This example shows how to let the user input text into a string (here stored
as a <a href="input//programming/local.html">local resource</a>).</p>
<pre><code class="language-rust no_run noplayground">fn text_input(
    mut evr_char: EventReader&lt;ReceivedCharacter&gt;,
    kbd: Res&lt;Input&lt;KeyCode&gt;&gt;,
    mut string: Local&lt;String&gt;,
) {
    if kbd.just_pressed(KeyCode::Return) {
        println!(&quot;Text input: {}&quot;, &amp;*string);
        string.clear();
    }
    if kbd.just_pressed(KeyCode::Back) {
        string.pop();
    }
    for ev in evr_char.iter() {
        // ignore control (special) characters
        if !ev.char.is_control() {
            string.push(ev.char);
        }
    }
}</code></pre>
<p>Note: we are using Bevy's regular <a href="input//input/keyboard.html">keyboard input</a> to handle
the pressing of the enter and backspace keys. Character events are also sent
when these keys are pressed (they produce special control characters, like
ASCII newlines <code>\n</code>), so, if we don't want these to be saved to our string,
we need to ignore them.</p>
<p>In your own application, you might also want to handle things like arrow keys in
a way that is appropriate to your UI.</p>
<h2 id="ime-support"><a class="header" href="#ime-support">IME support</a></h2>
<p>Bevy has support for IMEs (Input Method Editors), which is how people perform
text input in languages with more complex scripts, like East Asian languages. It
requires some special handling from you, however.</p>
<p>IMEs work by using a special &quot;buffer&quot;, which shows the current in-progress text
suggestions and allows users to select the correct characters before confirming
them. The text suggestions / autocompletion is provided by the OS, but your app
needs to display them for the user.</p>
<p>If you'd like all international users to be able to input text in their
language, the way they usually do in other GUI apps on their OS, you should
support IMEs.</p>
<p>To do this, you need to enable &quot;IME mode&quot; on the window, whenever you are
expecting users to type text, and disable it afterwards. For example, if
you prompt users to enter their name, before playing the game, you enable
IME mode while the prompt is active.</p>
<p>While &quot;IME mode&quot; is enabled, if the user is using an IME, you will receive
<a href="https://docs.rs/bevy/0.11.0/bevy/window/enum.Ime.html"><code>Ime</code></a> events, instead of <a href="https://docs.rs/bevy/0.11.0/bevy/window/struct.ReceivedCharacter.html"><code>ReceivedCharacter</code></a>
and regular keyboard input. However, if the user is not using an IME, then
everything will behave as normal, even when &quot;IME mode&quot; is enabled.</p>
<p>While the user has in-progress text, you will get <code>Ime::Preedit</code> events, to tell
you the current contents of the &quot;temporary buffer&quot; and information about the
cursor/highlight you need to show, so that users can see what they are doing.</p>
<p>When the user confirms their input, you will get a <code>Ime::Commit</code> event, to tell
you the text that the user wishes to insert into the app.</p>
<pre><code class="language-rust no_run noplayground">// for this simple example, we will just enable/disable IME mode on mouse click
fn ime_toggle(
    mousebtn: Res&lt;Input&lt;MouseButton&gt;&gt;,
    mut q_window: Query&lt;&amp;mut Window, With&lt;PrimaryWindow&gt;&gt;,
) {
    if mousebtn.just_pressed(MouseButton::Left) {
        let mut window = q_window.single_mut();

        // toggle &quot;IME mode&quot;
        window.ime_enabled = !window.ime_enabled;

        // We need to tell the OS the on-screen coordinates where the text will
        // be displayed; for this simple example, let's just use the mouse cursor.
        // In a real app, this might be the position of a UI text field, etc.
        window.ime_position = window.cursor_position().unwrap();
    }
}

fn ime_input(
    mut evr_ime: EventReader&lt;Ime&gt;,
) {
    for ev in evr_ime.iter() {
        match ev {
            Ime::Commit { value, .. } =&gt; {
                println!(&quot;IME confirmed text: {}&quot;, value);
            }
            Ime::Preedit { value, cursor, .. } =&gt; {
                println!(&quot;IME buffer: {:?}, cursor: {:?}&quot;, value, cursor);
            }
            Ime::Enabled { .. } =&gt; {
                println!(&quot;IME mode enabled!&quot;);
            }
            Ime::Disabled { .. } =&gt; {
                println!(&quot;IME mode disabled!&quot;);
            }
        }
    }
}</code></pre>
<p>For the sake of brevity, this example just prints the events to the console.</p>
<p>In a real app, you will want to display the &quot;pre-edit&quot; text on-screen, and use
different formatting to show the cursor. On &quot;commit&quot;, you can append the
provided text to the actual string where you normally accept text input.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="input//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="gamepad-controller-joystick"><a class="header" href="#gamepad-controller-joystick">Gamepad (Controller, Joystick)</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/input/gamepad_input.rs"><code>gamepad_input</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/input/gamepad_input_events.rs"><code>gamepad_input_events</code></a>.</p>
<hr />
<p>Bevy has support for gamepad input hardware: console controllers,
joysticks, etc. Many different kinds of hardware should work, but
if your device is not supported, you should file an issue with the
<a href="https://gitlab.com/gilrs-project/gilrs">gilrs</a> project.</p>
<h2 id="gamepad-ids"><a class="header" href="#gamepad-ids">Gamepad IDs</a></h2>
<p>Bevy assigns a unique ID (<a href="https://docs.rs/bevy/0.9.1/bevy/input/gamepad/struct.Gamepad.html"><code>Gamepad</code></a>) to each connected
gamepad. This lets you associate the device with a specific player and
distinguish which one your inputs are coming from.</p>
<p>You can use the <a href="https://docs.rs/bevy/0.9.1/bevy/input/gamepad/struct.Gamepads.html"><code>Gamepads</code></a> <a href="input//programming/res.html">resource</a> to list
the IDs of all the currently connected gamepad devices, or to check the
status of a specific one.</p>
<p>To detect when gamepads are connected or disconnected, you can use
<a href="https://docs.rs/bevy/0.9.1/bevy/input/gamepad/struct.GamepadEvent.html"><code>GamepadEvent</code></a> <a href="input//programming/events.html">events</a>.</p>
<p>Example showing how to remember the first connected gamepad ID:</p>
<pre><code class="language-rust no_run noplayground">/// Simple resource to store the ID of the connected gamepad.
/// We need to know which gamepad to use for player input.
#[derive(Resource)]
struct MyGamepad(Gamepad);

fn gamepad_connections(
    mut commands: Commands,
    my_gamepad: Option&lt;Res&lt;MyGamepad&gt;&gt;,
    mut gamepad_evr: EventReader&lt;GamepadEvent&gt;,
) {
    for ev in gamepad_evr.iter() {
        // the ID of the gamepad
        let id = ev.gamepad;
        match &amp;ev.event_type {
            GamepadEventType::Connected(info) =&gt; {
                println!(&quot;New gamepad connected with ID: {:?}, name: {}&quot;, id, info.name);

                // if we don't have any gamepad yet, use this one
                if my_gamepad.is_none() {
                    commands.insert_resource(MyGamepad(id));
                }
            }
            GamepadEventType::Disconnected =&gt; {
                println!(&quot;Lost gamepad connection with ID: {:?}&quot;, id);

                // if it's the one we previously associated with the player,
                // disassociate it:
                if let Some(MyGamepad(old_id)) = my_gamepad.as_deref() {
                    if *old_id == id {
                        commands.remove_resource::&lt;MyGamepad&gt;();
                    }
                }
            }
            // other events are irrelevant
            _ =&gt; {}
        }
    }
}</code></pre>
<h2 id="handling-gamepad-inputs"><a class="header" href="#handling-gamepad-inputs">Handling Gamepad Inputs</a></h2>
<p>You can handle the analog sticks and triggers with <code>Axis&lt;GamepadAxis&gt;</code>
(<a href="https://docs.rs/bevy/0.9.1/bevy/input/struct.Axis.html"><code>Axis</code></a>, <a href="https://docs.rs/bevy/0.9.1/bevy/input/gamepad/struct.GamepadAxis.html"><code>GamepadAxis</code></a>). Buttons
can be handled with <code>Input&lt;GamepadButton&gt;</code> (<a href="https://docs.rs/bevy/0.9.1/bevy/input/struct.Input.html"><code>Input</code></a>,
<a href="https://docs.rs/bevy/0.9.1/bevy/input/gamepad/struct.GamepadButton.html"><code>GamepadButton</code></a>), similar to <a href="input//input/mouse.html#mouse-buttons">mouse
buttons</a> or <a href="input//input/keyboard.html">keyboard keys</a>.</p>
<p>Notice that the names of buttons in the <a href="https://docs.rs/bevy/0.9.1/bevy/input/gamepad/struct.GamepadButton.html"><code>GamepadButton</code></a>
are vendor-neutral (like <code>South</code> and <code>East</code> instead of X/O or A/B).</p>
<pre><code class="language-rust no_run noplayground">fn gamepad_input(
    axes: Res&lt;Axis&lt;GamepadAxis&gt;&gt;,
    buttons: Res&lt;Input&lt;GamepadButton&gt;&gt;,
    my_gamepad: Option&lt;Res&lt;MyGamepad&gt;&gt;,
) {
    let gamepad = if let Some(gp) = my_gamepad {
        // a gamepad is connected, we have the id
        gp.0
    } else {
        // no gamepad is connected
        return;
    };

    // The joysticks are represented using a separate axis for X and Y
    let axis_lx = GamepadAxis {
        gamepad, axis_type: GamepadAxisType::LeftStickX
    };
    let axis_ly = GamepadAxis {
        gamepad, axis_type: GamepadAxisType::LeftStickY
    };

    if let (Some(x), Some(y)) = (axes.get(axis_lx), axes.get(axis_ly)) {
        // combine X and Y into one vector
        let left_stick_pos = Vec2::new(x, y);

        // Example: check if the stick is pushed up
        if left_stick_pos.length() &gt; 0.9 &amp;&amp; left_stick_pos.y &gt; 0.5 {
            // do something
        }
    }

    // In a real game, the buttons would be configurable, but here we hardcode them
    let jump_button = GamepadButton {
        gamepad, button_type: GamepadButtonType::South
    };
    let heal_button = GamepadButton {
        gamepad, button_type: GamepadButtonType::East
    };

    if buttons.just_pressed(jump_button) {
        // button just pressed: make the player jump
    }

    if buttons.pressed(heal_button) {
        // button being held down: heal the player
    }
}</code></pre>
<p>You can also handle gamepad inputs using <a href="https://docs.rs/bevy/0.9.1/bevy/input/gamepad/struct.GamepadEvent.html"><code>GamepadEvent</code></a> <a href="input//programming/events.html">events</a>:</p>
<pre><code class="language-rust no_run noplayground">fn gamepad_input_events(
    my_gamepad: Option&lt;Res&lt;MyGamepad&gt;&gt;,
    mut gamepad_evr: EventReader&lt;GamepadEvent&gt;,
) {
    let gamepad = if let Some(gp) = my_gamepad {
        // a gamepad is connected, we have the id
        gp.0
    } else {
        // no gamepad is connected
        return;
    };

    for ev in gamepad_evr.iter() {
        if ev.gamepad != gamepad {
            // event not from our gamepad
            continue;
        }

        use GamepadEventType::{AxisChanged, ButtonChanged};

        match ev.event_type {
            AxisChanged(GamepadAxisType::RightStickX, x) =&gt; {
                // Right Stick moved (X)
            }
            AxisChanged(GamepadAxisType::RightStickY, y) =&gt; {
                // Right Stick moved (Y)
            }
            ButtonChanged(GamepadButtonType::DPadDown, val) =&gt; {
                // buttons are also reported as analog, so use a threshold
                if val &gt; 0.5 {
                    // button pressed
                }
            }
            _ =&gt; {} // don't care about other inputs
        }
    }
}</code></pre>
<h2 id="gamepad-settings"><a class="header" href="#gamepad-settings">Gamepad Settings</a></h2>
<p>You can use the <a href="https://docs.rs/bevy/0.9.1/bevy/input/gamepad/struct.GamepadSettings.html"><code>GamepadSettings</code></a> <a href="input//programming/res.html">resource</a>
to configure dead-zones and other parameters of the various axes and
buttons. You can set the global defaults, as well as individually
per-axis/button.</p>
<p>Here is an example showing how to configure gamepads with custom settings
(not necessarily <em>good</em> settings, please don't copy these blindly):</p>
<pre><code class="language-rust no_run noplayground">// this should be run once, when the game is starting
// (transition entering your in-game state might be a good place to put it)
fn configure_gamepads(
    my_gamepad: Option&lt;Res&lt;MyGamepad&gt;&gt;,
    mut settings: ResMut&lt;GamepadSettings&gt;,
) {
    let gamepad = if let Some(gp) = my_gamepad {
        // a gamepad is connected, we have the id
        gp.0
    } else {
        // no gamepad is connected
        return;
    };

    // add a larger default dead-zone to all axes (ignore small inputs, round to zero)
    settings.default_axis_settings.set_deadzone_lowerbound(-0.1);
    settings.default_axis_settings.set_deadzone_upperbound(0.1);

    // make the right stick &quot;binary&quot;, squash higher values to 1.0 and lower values to 0.0
    let mut right_stick_settings = AxisSettings::default();
    right_stick_settings.set_deadzone_lowerbound(-0.5);
    right_stick_settings.set_deadzone_upperbound(0.5);
    right_stick_settings.set_livezone_lowerbound(-0.5);
    right_stick_settings.set_livezone_upperbound(0.5);
    // the raw value should change by at least this much,
    // for Bevy to register an input event:
    right_stick_settings.set_threshold(0.01);

    // make the triggers work in big/coarse steps, to get fewer events
    // reduces noise and precision
    let mut trigger_settings = AxisSettings::default();
    trigger_settings.set_threshold(0.25);

    // set these settings for the gamepad we use for our player
    settings.axis_settings.insert(
        GamepadAxis { gamepad, axis_type: GamepadAxisType::RightStickX },
        right_stick_settings.clone()
    );
    settings.axis_settings.insert(
        GamepadAxis { gamepad, axis_type: GamepadAxisType::RightStickY },
        right_stick_settings.clone()
    );
    settings.axis_settings.insert(
        GamepadAxis { gamepad, axis_type: GamepadAxisType::LeftZ },
        trigger_settings.clone()
    );
    settings.axis_settings.insert(
        GamepadAxis { gamepad, axis_type: GamepadAxisType::RightZ },
        trigger_settings.clone()
    );

    // for buttons (or axes treated as buttons):
    let mut button_settings = ButtonSettings::default();
    // require them to be pressed almost all the way, to count
    button_settings.set_press_threshold(0.9);
    // require them to be released almost all the way, to count
    button_settings.set_release_threshold(0.1);

    settings.default_button_settings = button_settings;
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="input//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="touchscreen"><a class="header" href="#touchscreen">Touchscreen</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/input/touch_input.rs"><code>touch_input</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/input/touch_input_events.rs"><code>touch_input_events</code></a>.</p>
<hr />
<p>Multi-touch touchscreens are supported. You can track multiple fingers on
the screen, with position and pressure/force information. Bevy does not
offer gesture recognition.</p>
<p>The <a href="https://docs.rs/bevy/0.9.1/bevy/input/touch/struct.Touches.html"><code>Touches</code></a> <a href="input//programming/res.html">resource</a> allows you to track any
fingers currently on the screen:</p>
<pre><code class="language-rust no_run noplayground">fn touches(
    touches: Res&lt;Touches&gt;,
) {
    // There is a lot more information available, see the API docs.
    // This example only shows some very basic things.

    for finger in touches.iter() {
        if touches.just_pressed(finger.id()) {
            println!(&quot;A new touch with ID {} just began.&quot;, finger.id());
        }
        println!(
            &quot;Finger {} is at position ({},{}), started from ({},{}).&quot;,
            finger.id(),
            finger.position().x,
            finger.position().y,
            finger.start_position().x,
            finger.start_position().y,
        );
    }
}</code></pre>
<p>Alternatively, you can use <a href="https://docs.rs/bevy/0.9.1/bevy/input/touch/struct.TouchInput.html"><code>TouchInput</code></a> <a href="input//programming/events.html">events</a>:</p>
<pre><code class="language-rust no_run noplayground">fn touch_events(
    mut touch_evr: EventReader&lt;TouchInput&gt;,
) {
    use bevy::input::touch::TouchPhase;
    for ev in touch_evr.iter() {
        // in real apps you probably want to store and track touch ids somewhere
        match ev.phase {
            TouchPhase::Started =&gt; {
                println!(&quot;Touch {} started at: {:?}&quot;, ev.id, ev.position);
            }
            TouchPhase::Moved =&gt; {
                println!(&quot;Touch {} moved to: {:?}&quot;, ev.id, ev.position);
            }
            TouchPhase::Ended =&gt; {
                println!(&quot;Touch {} ended at: {:?}&quot;, ev.id, ev.position);
            }
            TouchPhase::Cancelled =&gt; {
                println!(&quot;Touch {} cancelled at: {:?}&quot;, ev.id, ev.position);
            }
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="input//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="drag-and-drop-files"><a class="header" href="#drag-and-drop-files">Drag-and-Drop (Files)</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/app/drag_and_drop.rs"><code>drag_and_drop</code></a>.</p>
<hr />
<p>Bevy supports the Drag-and-Drop gesture common on most desktop operating
systems, but only for files, not arbitrary data / objects.</p>
<p>If you drag a file (say, from the file manager app) into a Bevy app, Bevy
will produce a <a href="https://docs.rs/bevy/0.9.1/bevy/window/enum.FileDragAndDrop.html"><code>FileDragAndDrop</code></a> <a href="input//programming/events.html">event</a>,
containing the path of the file that was dropped in.</p>
<pre><code class="language-rust no_run noplayground">fn file_drop(
    mut dnd_evr: EventReader&lt;FileDragAndDrop&gt;,
) {
    for ev in dnd_evr.iter() {
        println!(&quot;{:?}&quot;, ev);
        if let FileDragAndDrop::DroppedFile { id, path_buf } = ev {
            println!(&quot;Dropped file with path: {:?}, in window id: {:?}&quot;, path_buf, id);
        }
    }
}</code></pre>
<h2 id="detecting-the-position-of-the-drop"><a class="header" href="#detecting-the-position-of-the-drop">Detecting the Position of the Drop</a></h2>
<p>You may want to do different things depending on where the cursor was when the
drop gesture ended. For example, add the file to some collection, if it was
dropped over a specific UI element/panel.</p>
<p>Unfortunately, this is currently somewhat tricky to implement, due to <a href="https://github.com/rust-windowing/winit/issues/1550"><code>winit</code>
bug #1550</a>. Bevy does not get <a href="https://docs.rs/bevy/0.9.1/bevy/window/struct.CursorMoved.html"><code>CursorMoved</code></a>
<a href="input//programming/events.html">events</a> while the drag gesture is ongoing, and therefore does not
respond to the mouse cursor. Bevy completely loses track of the cursor position.</p>
<p>Checking the cursor position from the <a href="https://docs.rs/bevy/0.9.1/bevy/window/struct.Window.html"><code>Window</code></a> will also not work.</p>
<p>Systems that use cursor events to respond to cursor movements will not work
during a drag gesture. This includes Bevy UI's <a href="https://docs.rs/bevy/0.9.1/bevy/ui/enum.Interaction.html"><code>Interaction</code></a>
detection, which is the usual way of detecting when a UI element is hovered over.</p>
<h3 id="workaround"><a class="header" href="#workaround">Workaround</a></h3>
<p>The only way to workaround this issue is to store the file path somewhere
temporarily after receiving the drop event. Then, wait until the next
<a href="https://docs.rs/bevy/0.9.1/bevy/window/struct.CursorMoved.html"><code>CursorMoved</code></a> event, and then process the file.</p>
<p>Note that this might not even be on the next frame update. The next cursor
update will happen whenever the user moves the cursor. If the user does not
immediately move the mouse after dropping the file and leaves the cursor in the
same place for a while, there will be no events and your app will have no way of
knowing the cursor position.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="window-management"><a class="header" href="#window-management">Window Management</a></h1>
<p>This chapter covers topics related to working with the application's OS window.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="window//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="window-properties"><a class="header" href="#window-properties">Window Properties</a></h1>
<p>Page coming soon‚Ä¶</p>
<p>In the meantime, you can learn from Bevy's <a href="https://github.com/bevyengine/bevy/tree/latest/examples#examples">examples</a>.</p>
<p>See the <a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/window/window_settings.rs"><code>window_settings</code></a> example.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="window//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="changing-the-background-color"><a class="header" href="#changing-the-background-color">Changing the Background Color</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/window/clear_color.rs"><code>clear_color</code></a>.</p>
<hr />
<p>Use the <a href="https://docs.rs/bevy/0.9.1/bevy/core_pipeline/clear_color/struct.ClearColor.html"><code>ClearColor</code></a> <a href="window//programming/res.html">resource</a> to choose the
default background color. This color will be used as the default for all
<a href="window//graphics/camera.html">cameras</a>, unless overriden.</p>
<p>Note that the window will be black if no cameras exist. You must spawn at
least one camera.</p>
<pre><code class="language-rust no_run noplayground">fn setup(
    mut commands: Commands,
) {
    commands.spawn(Camera2dBundle::default());
}

fn main() {
    App::new()
        // set the global default
        .insert_resource(ClearColor(Color::rgb(0.9, 0.3, 0.6)))
        .add_plugins(DefaultPlugins)
        .add_startup_system(setup)
        .run();
}</code></pre>
<p>To override the default and use a different color for a specific
camera, you can set it using the <a href="https://docs.rs/bevy/0.9.1/bevy/core_pipeline/core_2d/struct.Camera2d.html"><code>Camera2d</code></a> or
<a href="https://docs.rs/bevy/0.9.1/bevy/core_pipeline/core_3d/struct.Camera3d.html"><code>Camera3d</code></a> components.</p>
<pre><code class="language-rust no_run noplayground">use bevy::core_pipeline::clear_color::ClearColorConfig;

// configure the background color (if any), for a specific camera (3D)
commands.spawn(Camera3dBundle {
    camera_3d: Camera3d {
        // clear the whole viewport with the given color
        clear_color: ClearColorConfig::Custom(Color::rgb(0.8, 0.4, 0.2)),
        ..Default::default()
    },
    ..Default::default()
});

// configure the background color (if any), for a specific camera (2D)
commands.spawn(Camera2dBundle {
    camera_2d: Camera2d {
        // disable clearing completely (pixels stay as they are)
        // (preserves output from previous frame or camera/pass)
        clear_color: ClearColorConfig::None,
    },
    ..Default::default()
});</code></pre>
<p>All of these locations (the components on specific cameras, the global
default resource) can be mutated at runtime, and bevy will use your new color.
Changing the default color using the resource will apply the new color to all
existing cameras that do not specify a custom color, not just newly-spawned
cameras.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="window//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="grabbing-the-mouse"><a class="header" href="#grabbing-the-mouse">Grabbing the Mouse</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/main/examples/input/mouse_grab.rs"><code>mouse_grab</code></a>.</p>
<hr />
<p>For some genres of games, you want to the mouse to be restricted to the window,
to prevent it from leaving the window during gameplay.</p>
<p>To grab the cursor:</p>
<pre><code class="language-rust no_run noplayground">{{#include ../code012/examples/mouse-grab.rs:grab}}</code></pre>
<p>To release the cursor:</p>
<pre><code class="language-rust no_run noplayground">{{#include ../code012/examples/mouse-grab.rs:ungrab}}</code></pre>
<p>You should grab the cursor during active gameplay and release it when
the player pauses the game / exits to menu / etc.</p>
<p>For relative mouse movement, you should use <a href="window//input/mouse.html#mouse-motion">mouse motion</a>
instead of <a href="window//input/mouse.html#mouse-cursor-position">cursor input</a> to implement your gameplay.</p>
<h2 id="platform-differences"><a class="header" href="#platform-differences">Platform Differences</a></h2>
<p>macOS does not natively support <code>Confined</code> mode. Bevy will fallback to <code>Locked</code>.
If you want to support macOS and you want to use <a href="window//input/mouse.html#mouse-cursor-position">cursor input</a>,
you might want to implement a &quot;virtual cursor&quot; instead.</p>
<p>Windows does not natively support <code>Locked</code> mode. Bevy will fallback to <code>Confined</code>.
You could emulate the locked behavior by re-centering the cursor every frame:</p>
<pre><code class="language-rust no_run noplayground">{{#include ../code012/examples/mouse-grab.rs:recenter}}</code></pre>
<pre><code class="language-rust no_run noplayground">{{#include ../code012/examples/mouse-grab.rs:recenter-app}}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="window//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="setting-the-window-icon"><a class="header" href="#setting-the-window-icon">Setting the Window Icon</a></h1>
<p>You might want to set a custom Window Icon. On Windows and Linux, this is
the icon image shown in the window title bar (if any) and task bar (if any).</p>
<p>Unfortunately, Bevy does not yet provide an easy and ergonomic built-in way
to do this. However, it can be done via the <code>winit</code> APIs.</p>
<p>The way shown here is quite hacky. To save on code complexity, instead of
using Bevy's asset system to load the image in the background, we bypass
the assets system and directly load the file using the <code>image</code> library.</p>
<p>There is some WIP on adding a proper API for this to Bevy; see PRs
<a href="https://github.com/bevyengine/bevy/issues/1163">#1163</a>, <a href="https://github.com/bevyengine/bevy/pull/2268">#2268</a>, <a href="https://github.com/bevyengine/bevy/issues/5488">#5488</a>,
<a href="https://github.com/bevyengine/bevy/issues/8130">#8130</a>, and <a href="https://github.com/bevyengine/bevy/issues/1031">Issue #1031</a>.</p>
<p>This example shows how to set the icon for the primary/main window, from
a Bevy startup system.</p>
<pre><code class="language-rust no_run noplayground">use bevy::winit::WinitWindows;
use winit::window::Icon;

fn set_window_icon(
    // we have to use `NonSend` here
    windows: NonSend&lt;WinitWindows&gt;,
) {
    // here we use the `image` crate to load our icon data from a png file
    // this is not a very bevy-native solution, but it will do
    let (icon_rgba, icon_width, icon_height) = {
        let image = image::open(&quot;my_icon.png&quot;)
            .expect(&quot;Failed to open icon path&quot;)
            .into_rgba8();
        let (width, height) = image.dimensions();
        let rgba = image.into_raw();
        (rgba, width, height)
    };
    let icon = Icon::from_rgba(icon_rgba, icon_width, icon_height).unwrap();

    // do it for all windows
    for window in windows.windows.values() {
        window.set_window_icon(Some(icon.clone()));
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_systems(Startup, set_window_icon)
        .run();
}</code></pre>
<p>Note: that <a href="https://docs.rs/bevy/0.12.0/bevy/winit/struct.WinitWindows.html"><code>WinitWindows</code></a> is a <a href="window//programming/non-send.html">non-send
resource</a>.</p>
<p>Note: you need to add <code>winit</code> to your project's dependencies, and it must
be the same version as the one used by Bevy. You can use <code>cargo tree</code> or
check <code>Cargo.lock</code> to see which is the correct version. As of Bevy 0.12,
that should be <code>winit = &quot;0.28&quot;</code>. You should also try to match the version
of the <code>image</code> library; Bevy uses <code>image = &quot;0.24&quot;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="bevy-asset-management"><a class="header" href="#bevy-asset-management">Bevy Asset Management</a></h1>
<p>Assets are the data that the game engine is working with: all of your images,
3D models, sounds, scenes, game-specific things like item descriptions,
and more!</p>
<p>Bevy has a flexible system for loading and managing your game assets
asynchronously (in the background, without causing lag spikes in your game).</p>
<p>In your code, you refer to individual assets using <a href="/assets/handles.html">handles</a>.</p>
<p>Asset data can be <a href="/assets/assetserver.html">loaded from files</a> and also <a href="/assets/data.html">accessed from
code</a>. <a href="/assets/hot-reload.html">Hot-reloading</a> is supported to
help you during development, by reloading asset files if they change while the
game is running.</p>
<p>If you want to write some code to do something when assets finish loading, get
modified, or are unloaded, you can use <a href="/assets/assetevent.html">asset events</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="handles"><a class="header" href="#handles">Handles</a></h1>
<p>Handles are lightweight IDs that refer to a specific asset. You need them
to use your assets, for example to <a href="assets//programming/commands.html">spawn entities</a> like
<a href="assets//2d/sprites.html">2D sprites</a> or <a href="assets//3d/gltf.html">3D models</a>, or to <a href="assets//assets/data.html">access the data
of the assets</a>.</p>
<p>Handles have the Rust type <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.Handle.html"><code>Handle&lt;T&gt;</code></a>, where <code>T</code> is the
<a href="assets//builtins.html#assets">asset type</a>.</p>
<p>You can store handles in your <a href="assets//programming/ec.html#components">entity components</a> or
<a href="assets//programming/res.html">resources</a>.</p>
<p>Handles can refer to not-yet-loaded assets, meaning you can just spawn your
entities anyway, using the handles, and the assets will just &quot;pop in&quot; when
they become ready.</p>
<h2 id="obtaining-handles"><a class="header" href="#obtaining-handles">Obtaining Handles</a></h2>
<p>If you are <a href="assets//assets/assetserver.html">loading an asset from a file</a>, the
<code>asset_server.load(‚Ä¶)</code> call will give you the handle. The loading of the
data happens in the background, meaning that the handle will initially refer
to an unavailable asset, and the actual data will become available later.</p>
<p>If you are <a href="assets//assets/data.html">creating your own asset data from code</a>,
the <code>assets.add(‚Ä¶)</code> call will give you the handle.</p>
<h2 id="reference-counting-strong-and-weak-handles"><a class="header" href="#reference-counting-strong-and-weak-handles">Reference Counting; Strong and Weak Handles</a></h2>
<p>Bevy keeps track of how many handles to a given asset exist at any time. Bevy
will automatically unload unused assets, after the last handle is dropped.</p>
<p>For this reason, creating additional handles to the same asset requires you
to call <code>handle.clone()</code>. This makes the operation explicit, to ensure you are
aware of all the places in your code where you create additional handles. The
<code>.clone()</code> operation is cheap, so don't worry about performance (in most cases).</p>
<p>There are two kinds of handles: &quot;strong&quot; and &quot;weak&quot;. Strong assets are
counted, weak handles are not. By default, handles are strong. If you want
to create a weak handle, use <code>.clone_weak()</code> (instead of <code>.clone()</code>) on an
existing handle. Bevy can unload the asset after all strong handles are gone,
even if you are still holding some weak handles.</p>
<h2 id="untyped-handles"><a class="header" href="#untyped-handles">Untyped Handles</a></h2>
<p>Bevy also has a <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.HandleUntyped.html"><code>HandleUntyped</code></a> type. Use this type
of handle if you need to be able to refer to any asset, regardless of the
asset type.</p>
<p>This allows you to store a collection (such as <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code>Vec</code></a> or
<a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code>HashMap</code></a>) containing assets of mixed types.</p>
<p>You can create an untyped handle using <code>.clone_untyped()</code> on an existing
handle.</p>
<p>Just like regular handles, untyped handles can be strong or weak.</p>
<p>You need to do this to <a href="assets//assets/data.html">access the asset data</a>.</p>
<p>You can convert an untyped handle into a typed handle with <code>.typed::&lt;T&gt;()</code>,
specifying the type to use. You need to do this to <a href="assets//assets/data.html">access the asset
data</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="load-assets-from-files-with-assetserver"><a class="header" href="#load-assets-from-files-with-assetserver">Load Assets from Files with AssetServer</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/asset/asset_loading.rs"><code>asset_loading</code></a>.</p>
<hr />
<p>To load assets from files, use the <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a>
<a href="assets//programming/res.html">resource</a>.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct UiFont(Handle&lt;Font&gt;);

fn load_ui_font(
    mut commands: Commands,
    server: Res&lt;AssetServer&gt;
) {
    let handle: Handle&lt;Font&gt; = server.load(&quot;font.ttf&quot;);

    // we can store the handle in a resource:
    //  - to prevent the asset from being unloaded
    //  - if we want to use it to access the asset later
    commands.insert_resource(UiFont(handle));
}</code></pre>
<p>This queues the asset loading to happen in the background, and return a
<a href="assets//assets/handles.html">handle</a>. The asset will take some time to become available. You
cannot access the actual data immediately in the same <a href="assets//programming/systems.html">system</a>,
but you can use the handle.</p>
<p>You can spawn entities like your 2D sprites, 3D models, and UI, using the
handle, even before the asset has loaded. They will just &quot;pop in&quot; later,
when the asset becomes ready.</p>
<p>Note that it is OK to call <code>asset_server.load(‚Ä¶)</code> as many times as you want,
even if the asset is currently loading, or already loaded. It will just
provide you with the same handle. Every time you call it, it will just check
the status of the asset, begin loading it if needed, and give you a handle.</p>
<p>Bevy supports loading <a href="assets//builtins.html#file-formats">a variety of asset file formats</a>,
and can be extended to support more. The asset loader implementation to use
is selected based on the file extension.</p>
<h2 id="untyped-loading"><a class="header" href="#untyped-loading">Untyped Loading</a></h2>
<p>If you want an <a href="assets//assets/handles.html#untyped-handles">untyped handle</a>, you can use
<code>asset_server.load_untyped(‚Ä¶)</code> instead.</p>
<p>Untyped loading is possible, because Bevy always detects the file type from
the file extension anyway.</p>
<h3 id="loading-folders"><a class="header" href="#loading-folders">Loading Folders</a></h3>
<p>You can also load an entire folder of assets, regardless of how many
files are inside, using <code>asset_server.load_folder(‚Ä¶)</code>. This gives you a
<code>Vec&lt;HandleUntyped&gt;</code> with all the <a href="assets//assets/handles.html#untyped-handles">untyped handles</a>.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct ExtraAssets(Vec&lt;HandleUntyped&gt;);

fn load_extra_assets(
    mut commands: Commands,
    server: Res&lt;AssetServer&gt;,
) {
    if let Ok(handles) = server.load_folder(&quot;extra&quot;) {
        commands.insert_resource(ExtraAssets(handles));
    }
}</code></pre>
<p>Loading folders is not supported by all I/O backends. Notably, it does not
work on WASM/Web.</p>
<h2 id="assetpath-and-labels"><a class="header" href="#assetpath-and-labels">AssetPath and Labels</a></h2>
<p>The asset path you use to identify an asset from the filesystem is actually
a special <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.AssetPath.html"><code>AssetPath</code></a>, which consists of the file path +
a label. Labels are used in situations where multiple assets are contained
in the same file. An example of this are <a href="assets//3d/gltf.html">GLTF files</a>, which can
contain meshes, scenes, textures, materials, etc.</p>
<p>Asset paths can be created from a string, with the label (if any) attached
after a <code>#</code> symbol.</p>
<pre><code class="language-rust no_run noplayground">fn load_gltf_things(
    mut commands: Commands,
    server: Res&lt;AssetServer&gt;
) {
    // get a specific mesh
    let my_mesh: Handle&lt;Mesh&gt; = server.load(&quot;my_scene.gltf#Mesh0/Primitive0&quot;);

    // spawn a whole scene
    let my_scene: Handle&lt;Scene&gt; = server.load(&quot;my_scene.gltf#Scene0&quot;);
    commands.spawn(SceneBundle {
        scene: my_scene,
        ..Default::default()
    });
}</code></pre>
<p>See the <a href="assets//3d/gltf.html">GLTF page</a> for more info about working with 3D models.</p>
<h2 id="where-are-assets-loaded-from"><a class="header" href="#where-are-assets-loaded-from">Where are assets loaded from?</a></h2>
<p>The asset server internally relies on an implementation of the
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/trait.AssetIo.html"><code>AssetIo</code></a> Rust trait, which is Bevy's way of providing
&quot;backends&quot; for fetching data from different types of storage.</p>
<p>Bevy provides its own default built-in I/O backends for each <a href="assets//platforms.html">supported
platform</a>.</p>
<p>On desktop platforms, it treats asset paths as relative to a folder called
<code>assets</code>, that must be placed at one of the following locations:</p>
<ul>
<li>Alongside the game's executable file, for distribution</li>
<li>In your Cargo project folder, when running your game using <code>cargo</code> during development
<ul>
<li>This is identified by the <code>CARGO_MANIFEST_DIR</code> environment variable</li>
</ul>
</li>
</ul>
<p>On the web, it fetches assets using HTTP URLs pointing within an <code>assets</code>
folder located alongside the game's <code>.wasm</code> file.</p>
<p>There are <a href="assets//setup/unofficial-plugins.html">unofficial plugins</a> available that provide alternative
I/O backend implementations, such as for loading assets from inside archive
files (<code>.zip</code>), embedded inside the game executable, using a network protocol,
‚Ä¶ many other possibilities.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="access-the-asset-data"><a class="header" href="#access-the-asset-data">Access the Asset Data</a></h1>
<p>To access the actual asset data from systems, use the
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.Assets.html"><code>Assets&lt;T&gt;</code></a> <a href="assets//programming/res.html">resource</a>.</p>
<p>You can identify your desired asset using the <a href="assets//assets/handles.html">handle</a>.</p>
<p><a href="assets//assets/handles.html#untyped-handles">untyped handles</a> need to be &quot;upgraded&quot; into typed handles.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct SpriteSheets {
    map_tiles: Handle&lt;TextureAtlas&gt;,
}

fn use_sprites(
    handles: Res&lt;SpriteSheets&gt;,
    atlases: Res&lt;Assets&lt;TextureAtlas&gt;&gt;,
    images: Res&lt;Assets&lt;Image&gt;&gt;,
) {
    // Could be `None` if the asset isn't loaded yet
    if let Some(atlas) = atlases.get(&amp;handles.map_tiles) {
        // do something with the texture atlas
    }
}</code></pre>
<h2 id="creating-assets-from-code"><a class="header" href="#creating-assets-from-code">Creating Assets from Code</a></h2>
<p>You can also add assets to <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.Assets.html"><code>Assets&lt;T&gt;</code></a> manually.</p>
<p>Sometimes you need to create assets from code, rather than <a href="assets//assets/assetserver.html">loading them
from files</a>. Some common examples of such use-cases are:</p>
<ul>
<li>creating texture atlases</li>
<li>creating 3D or 2D materials</li>
<li>procedurally-generating assets like images or 3D meshes</li>
</ul>
<p>To do this, first create the data for the asset (an instance of the
<a href="assets//builtins.html#assets">asset type</a>), and then add it <code>.add(‚Ä¶)</code> it to the
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.Assets.html"><code>Assets&lt;T&gt;</code></a> resource, for it to be stored and tracked by
Bevy. You will get a <a href="assets//assets/handles.html">handle</a> to use to refer to it, just like
any other asset.</p>
<pre><code class="language-rust no_run noplayground">fn add_material(
    mut materials: ResMut&lt;Assets&lt;StandardMaterial&gt;&gt;,
) {
    let new_mat = StandardMaterial {
        base_color: Color::rgba(0.25, 0.50, 0.75, 1.0),
        unlit: true,
        ..Default::default()
    };

    let handle = materials.add(new_mat);

    // do something with the handle
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="react-to-changes-with-asset-events"><a class="header" href="#react-to-changes-with-asset-events">React to Changes with Asset Events</a></h1>
<p>If you need to perform specific actions when an asset is created,
modified, or removed, you can make a <a href="assets//programming/systems.html">system</a> that reacts to
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/enum.AssetEvent.html"><code>AssetEvent</code></a> <a href="assets//programming/events.html">events</a>.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct MyMapImage {
    handle: Handle&lt;Image&gt;,
}

fn fixup_images(
    mut ev_asset: EventReader&lt;AssetEvent&lt;Image&gt;&gt;,
    mut assets: ResMut&lt;Assets&lt;Image&gt;&gt;,
    map_img: Res&lt;MyMapImage&gt;,
) {
    for ev in ev_asset.iter() {
        match ev {
            AssetEvent::Created { handle } =&gt; {
                // a texture was just loaded or changed!

                // WARNING: this mutable access will cause another
                // AssetEvent (Modified) to be emitted!
                let texture = assets.get_mut(handle).unwrap();
                // ^ unwrap is OK, because we know it is loaded now

                if *handle == map_img.handle {
                    // it is our special map image!
                } else {
                    // it is some other image
                }
            }
            AssetEvent::Modified { handle } =&gt; {
                // an image was modified
            }
            AssetEvent::Removed { handle } =&gt; {
                // an image was unloaded
            }
        }
    }
}</code></pre>
<p><strong>Note:</strong> If you are handling <code>Modified</code> events and doing a mutable access to
the data, the <code>.get_mut</code> will trigger another <code>Modified</code> event for the same
asset. If you are not careful, this could result in an infinite loop! (from
events caused by your own system)</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="track-loading-progress"><a class="header" href="#track-loading-progress">Track Loading Progress</a></h1>
<p>There are good community plugins that can help with this. Otherwise, this page
shows you how to do it yourself.</p>
<hr />
<p>If you want to check the status of various <a href="assets//assets/assetserver.html">asset files</a>,
you can poll it from the <a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a>. It will tell you
whether the asset(s) are loaded, still loading, not loaded, or encountered
an error.</p>
<p>To check an individual asset, you can use <code>asset_server.get_load_state(‚Ä¶)</code> with
a handle or path to refer to the asset.</p>
<p>To check a group of many assets, you can add them to a single collection
(such as a <code>Vec&lt;HandleUntyped&gt;</code>; <a href="assets//assets/handles.html#untyped-handles">untyped handles</a> are very
useful for this) and use <code>asset_server.get_group_load_state(‚Ä¶)</code>.</p>
<hr />
<p>Here is a more complete code example:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct AssetsLoading(Vec&lt;HandleUntyped&gt;);

fn setup(server: Res&lt;AssetServer&gt;, mut loading: ResMut&lt;AssetsLoading&gt;) {
    // we can have different asset types
    let font: Handle&lt;Font&gt; = server.load(&quot;my_font.ttf&quot;);
    let menu_bg: Handle&lt;Image&gt; = server.load(&quot;menu.png&quot;);
    let scene: Handle&lt;Scene&gt; = server.load(&quot;level01.gltf#Scene0&quot;);

    // add them all to our collection for tracking
    loading.0.push(font.clone_untyped());
    loading.0.push(menu_bg.clone_untyped());
    loading.0.push(scene.clone_untyped());
}

fn check_assets_ready(
    mut commands: Commands,
    server: Res&lt;AssetServer&gt;,
    loading: Res&lt;AssetsLoading&gt;
) {
    use bevy::asset::LoadState;

    match server.get_group_load_state(loading.0.iter().map(|h| h.id)) {
        LoadState::Failed =&gt; {
            // one of our assets had an error
        }
        LoadState::Loaded =&gt; {
            // all assets are now ready

            // this might be a good place to transition into your in-game state

            // remove the resource to drop the tracking handles
            commands.remove_resource::&lt;AssetsLoading&gt;();
            // (note: if you don't have any other handles to the assets
            // elsewhere, they will get unloaded after this)
        }
        _ =&gt; {
            // NotLoaded/Loading: not fully ready yet
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="hot-reloading-assets"><a class="header" href="#hot-reloading-assets">Hot-Reloading Assets</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/asset/hot_asset_reloading.rs"><code>hot_asset_reloading</code></a>.</p>
<hr />
<p>At runtime, if you modify the file of an <a href="assets//assets.html">asset</a>
that is <a href="assets//assets/assetserver.html">loaded</a> into the game (via the
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a>), Bevy can detect that and reload the
asset automatically. This is very useful for quick iteration. You can edit
your assets while the game is running and see the changes instantly in-game.</p>
<p>Not all <a href="assets//builtins.html#file-formats">file formats</a> and use cases are supported
equally well. Typical asset types like textures / images should work without
issues, but complex GLTF or scene files, or assets involving custom logic,
might not.</p>
<p>If you need to run custom logic as part of your hot-reloading
workflow, you could implement it in a <a href="assets//programming/systems.html">system</a>, using
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/enum.AssetEvent.html"><code>AssetEvent</code></a> (<a href="assets//assets/assetevent.html">learn more</a>).</p>
<p>Hot reloading is opt-in and has to be enabled in order to work:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins(DefaultPlugins.set(AssetPlugin {
            watch_for_changes: true,
            ..Default::default()
        }))
        .run();
}</code></pre>
<p>Note that this requires the <code>filesystem_watcher</code> <a href="assets//setup/bevy-config.html">Bevy cargo
feature</a>. It is enabled by default, but if you have disabled
default features to customize Bevy, be sure to include it if you need it.</p>
<h2 id="shaders"><a class="header" href="#shaders">Shaders</a></h2>
<p>Bevy also supports hot-reloading for shaders. You can edit your custom shader
code and see the changes immediately.</p>
<p>This works for any shader loaded from a file path, such as shaders specified
in your Materials definitions, or shaders <a href="assets//assets/assetserver.html">loaded</a> via the
<a href="https://docs.rs/bevy/0.9.1/bevy/asset/struct.AssetServer.html"><code>AssetServer</code></a>.</p>
<p>Shader code that does not come from asset files, such as if you include it
as a static string in your source code, cannot be hot-reloaded (for obvious
reasons).</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="assets//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="processing-assets"><a class="header" href="#processing-assets">Processing Assets</a></h1>
<p>TODO / WIP</p>
<p>Coming soon...</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="audio"><a class="header" href="#audio">Audio</a></h1>
<p>Bevy offers a (somewhat barebones, but still useful) ECS-based Audio framework.
This chapter will teach you how to use it.</p>
<p>You can <a href="/audio/basic.html">play sound effects and music</a> from your game, with
volume control. There is a rudimentary <a href="/audio/spatial.html">&quot;spatial audio&quot;</a>
implementation, which can pan sounds left/right in stereo, based on the
<a href="/fundamentals/transforms.html">transforms</a> of <a href="/programming/intro-data.html#entities--components">entities</a>. You can also implement your
own <a href="/audio/custom.html">custom sources of audio data</a>, if you want to synthesize
sound from code, stream data from somewhere, or any other custom use case.</p>
<p>There are also 3rd-party alternatives to Bevy's audio support:</p>
<ul>
<li><a href="https://github.com/NiklasEi/bevy_kira_audio"><code>bevy_kira_audio</code></a>: uses <a href="https://github.com/tesselode/kira"><code>kira</code></a>; provides a richer set of features and playback controls</li>
<li><a href="https://github.com/harudagondi/bevy_oddio"><code>bevy_oddio</code></a>: uses <a href="https://github.com/Ralith/oddio"><code>oddio</code></a>; seems to offer more advanced 3D spatial sound</li>
<li><a href="https://github.com/harudagondi/bevy_fundsp"><code>bevy_fundsp</code></a>: uses <a href="https://github.com/SamiPerttu/fundsp"><code>fundsp</code></a>; for advanced sound synthesis and effects</li>
</ul>
<p>(Bevy's official audio is based on the <a href="https://github.com/RustAudio/rodio"><code>rodio</code></a> library.)</p>
<p>As you can see, the Rust audio ecosystem is quite fragmented. There are
many backend libraries, all offering a different mix of features, none of
them particularly exhaustive. All of them are somewhat immature. You have
to pick your poison.</p>
<p>Audio is an area sorely in need of improvement. If you are an enthusiastic
audio developer, consider joining <a href="https://discord.gg/bevy">Discord</a> and helping
with development!</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="audio//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="playing-sounds"><a class="header" href="#playing-sounds">Playing Sounds</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/main/examples/audio/audio.rs"><code>audio</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/main/examples/audio/audio_control.rs"><code>audio_control</code></a>.</p>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="audio//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="spatial-audio"><a class="header" href="#spatial-audio">Spatial Audio</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/main/examples/audio/spatial_audio_2d.rs"><code>spatial_audio_2d</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/main/examples/audio/spatial_audio_3d.rs"><code>spatial_audio_3d</code></a>.</p>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="audio//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="custom-audio-streams"><a class="header" href="#custom-audio-streams">Custom Audio Streams</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/main/examples/audio/decodable.rs"><code>decodable</code></a>.</p>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bevy-ui-framework"><a class="header" href="#bevy-ui-framework">Bevy UI Framework</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="bevy-programming-framework"><a class="header" href="#bevy-programming-framework">Bevy Programming Framework</a></h1>
<p>This chapter presents the features of the Bevy core programming framework. This
covers the ECS (Entity Component System), App and Scheduling.</p>
<p>All the knowledge of this chapter is useful even if you want to use Bevy as
something other than a game engine. For example: using just the ECS for a
scientific simulation.</p>
<p>Hence, this chapter does not cover the game-engine parts of Bevy. Those
features are covered in other chapters of the book. You can start with
<a href="/fundamentals.html">Game Engine Fundamentals</a> chapter.</p>
<p>For additional of programming patterns and idioms, see the <a href="/patterns.html">Programming
Patterns</a> chapter.</p>
<p>If you are also interested in GPU programming, see the <a href="/gpu.html">Bevy GPU
Framework</a> chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="ecs-programming-introduction"><a class="header" href="#ecs-programming-introduction">ECS Programming Introduction</a></h1>
<p>This page will try to teach you the general ECS mindset/paradigm.</p>
<hr />
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/main/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<p>Also check out the complete game examples:
<a href="https://github.com/bevyengine/bevy/blob/main/examples/games/alien_cake_addict.rs"><code>alien_cake_addict</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/main/examples/games/breakout.rs"><code>breakout</code></a>.</p>
<hr />
<p>ECS is a programming paradigm that separates data and behavior. Bevy will store
all of <a href="programming//programming/intro-data.html">your data</a> and manage all of <a href="programming//programming/intro-code.html">your individual pieces
of functionality</a> for you. The code will run when
appropriate. Your code can get access to whatever data it needs to do its thing.</p>
<p>This makes it easy to write game logic (<a href="programming//programming/systems.html">Systems</a>) in a way that
is flexible and reusable. For example, you can implement:</p>
<ul>
<li>health and damage that works the same way for anything in the game,
regardless of whether that's the player, an NPC, or a monster, or a vehicle</li>
<li>gravity and collisions for anything that should have physics</li>
<li>an animation or sound effect for all buttons in your UI</li>
</ul>
<p>Of course, when you need specialized behavior only for specific entities (say,
player movement, which only applies to the player), that is naturally easy to
express, too.</p>
<p><a href="programming//programming/intro-data.html">Read more about how to represent your data.</a></p>
<p><a href="programming//programming/intro-code.html">Read more about how to represent your functionality.</a></p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="intro-your-data"><a class="header" href="#intro-your-data">Intro: Your Data</a></h1>
<p>This page is an overview, to give you an idea of the big picture of how Bevy
works. Click on the various links to be taken to dedicated pages where you can
learn more about each concept.</p>
<hr />
<p>As mentioned in <a href="programming//programming/ecs-intro.html">the ECS Intro</a>, Bevy stores all your data for
you and allows you easy and flexible access to whatever you need, wherever you
need it.</p>
<p>The ECS's data structure is called the <a href="https://docs.rs/bevy/0.12.0/bevy/ecs/world/struct.World.html"><code>World</code></a>. That is what
stores and manages all of the data. For advanced scenarios, is possible to have
<a href="programming//programming/sub-apps.html">multiple worlds</a>, and then each one will behave as its own
separate ECS. However, normally, you just work with the main World that Bevy
sets up for your <a href="programming//programming/app-builder.html">App</a>.</p>
<p>You can represent your data in two different ways:
<a href="programming/intro-data.html#entities--components">Entities/Components</a>, and <a href="programming/intro-data.html#resources">Resources</a>.</p>
<h2 id="entities--components"><a class="header" href="#entities--components">Entities / Components</a></h2>
<p>Conceptually, you can think of it by analogy with tables, like in a database or
spreadsheet. Your different data types (<a href="programming//programming/ec.html#components">Components</a>) are like
the &quot;columns&quot; of a table, and there can be arbitrarily many &quot;rows&quot;
(<a href="programming//programming/ec.html#entities">Entities</a>) containing values / instances of various components.
The <a href="https://docs.rs/bevy/0.12.0/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> ID is like the row number. It's an integer index
that lets you find specific component values.</p>
<p>Component types that are empty <code>struct</code>s (contain no data) are called <a href="programming//programming/ec.html#components">marker
components</a>. They are useful as &quot;tags&quot; to identify
specific entities, or enable certain behaviors. For example, you could use them
to identify the player entity, to mark enemies that are currently chasing the
player, to select entities to be despawned at the end of the level, etc.</p>
<p>Here is an illustration to help you visualize the logical structure. The
checkmarks show what component types are present on each entity. Empty cells
mean that the component is not present. In this example, we have a player,
a camera, and several enemies.</p>
<div class="table-wrapper"><table><thead><tr><th><a href="https://docs.rs/bevy/0.12.0/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> (ID)</th><th><a href="https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a></th><th><code>Player</code></th><th><code>Enemy</code></th><th><a href="https://docs.rs/bevy/0.12.0/bevy/render/camera/struct.Camera.html"><code>Camera</code></a></th><th><code>Health</code></th><th>...</th></tr></thead><tbody>
<tr><td>...</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>107</td><td>‚úì <code>&lt;translation&gt;</code> <code>&lt;rotation&gt;</code> <code>&lt;scale&gt;</code></td><td>‚úì</td><td></td><td></td><td>‚úì <code>50.0</code></td><td></td></tr>
<tr><td>108</td><td>‚úì <code>&lt;translation&gt;</code> <code>&lt;rotation&gt;</code> <code>&lt;scale&gt;</code></td><td></td><td>‚úì</td><td></td><td>‚úì <code>25.0</code></td><td></td></tr>
<tr><td>109</td><td>‚úì <code>&lt;translation&gt;</code> <code>&lt;rotation&gt;</code> <code>&lt;scale&gt;</code></td><td></td><td></td><td>‚úì <code>&lt;camera data&gt;</code></td><td></td><td></td></tr>
<tr><td>110</td><td>‚úì <code>&lt;translation&gt;</code> <code>&lt;rotation&gt;</code> <code>&lt;scale&gt;</code></td><td></td><td>‚úì</td><td></td><td>‚úì <code>10.0</code></td><td></td></tr>
<tr><td>111</td><td>‚úì <code>&lt;translation&gt;</code> <code>&lt;rotation&gt;</code> <code>&lt;scale&gt;</code></td><td></td><td>‚úì</td><td></td><td>‚úì <code>25.0</code></td><td></td></tr>
<tr><td>...</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p>Representing things this way gives you flexibility. For example, you could
create a <code>Health</code> component for your game. You could then have many entities
representing different things in your game, such as the player, NPCs, or
monsters, all of which can have a <code>Health</code> value (as well as other relevant
components).</p>
<p>The typical and obvious pattern is to use entities to represent &quot;objects in the
game/scene&quot;, such as the camera, the player, enemies, lights, props, UI
elements, and other things. However, you are not limited to that. The ECS is a
general-purpose data structure. You can create entities and components to store
any data. For example, you could create an entity to store a bunch of settings
or configuration parameters, or other abstract things.</p>
<p>Data stored using Entities and Components is accessed using <a href="programming//programming/queries.html">queries</a>.
For example, if you want to implement a game mechanic, write a <a href="programming//programming/systems.html">system</a>,
specify what component types you want to access, and do your thing. You can either
iterate through all entities that match your specification, or access specific
ones (if you know their <a href="https://docs.rs/bevy/0.12.0/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> ID).</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct Xp(u32);

#[derive(Component)]
struct Health {
    current: u32,
    max: u32,
}

fn level_up(
    // operate on anything that has Xp and Health
    mut query: Query&lt;(&amp;mut Xp, &amp;mut Health)&gt;,
) {
    for (mut xp, mut health) in query.iter_mut() {
        if xp.0 &gt; 1000 {
            xp.0 -= 1000;
            health.max += 25;
            health.current = health.max;
        }
    }
}</code></pre>
<p>Bevy can automatically keep track of what data your <a href="programming//programming/systems.html">systems</a> have
access to and <a href="programming//programming/system-order.html">run them in parallel</a> on multiple CPU
cores. This way, you get multithreading with no extra effort from you!</p>
<p>If you want to modify the data structure itself (as opposed to just accessing
existing data), such as to create or remove entities and components, that
requires special consideration. Bevy cannot change the memory layout while other
systems might be running. These operations can be buffered/deferred using
<a href="programming//programming/commands.html">Commands</a>, to be applied later when it is safe to do so. You can
also get <a href="programming//programming/world.html">direct World access</a> using <a href="programming//programming/exclusive.html">exclusive
systems</a>, if you want to perform such operations
immediately (but without multithreading).</p>
<p><a href="programming//programming/bundle.html">Bundles</a> serve as &quot;templates&quot; for common sets of components, to
help you when you spawn new entities, so you don't accidentally forget anything.</p>
<pre><code class="language-rust no_run noplayground">// Marker for the player
#[derive(Component)]
struct Player;

fn spawn_player(
    // needed for creating/removing data in the ECS World
    mut commands: Commands,
    // needed for loading assets
    asset_server: Res&lt;AssetServer&gt;,
) {
    // create a new entity with whatever components we want
    commands.spawn((
        // give it a marker
        Player,
        // give it health and xp
        Health {
            current: 100,
            max: 125,
        },
        Xp(0),
        // give it a 2D sprite to render on-screen
        // (Bevy's SpriteBundle lets us add everything necessary)
        SpriteBundle {
            texture: asset_server.load(&quot;player.png&quot;),
            transform: Transform::from_xyz(25.0, 50.0, 0.0),
            // use the default values for all other components in the bundle
            ..Default::default()
        },
    ));
}</code></pre>
<h3 id="comparison-with-object-oriented-programming"><a class="header" href="#comparison-with-object-oriented-programming">Comparison with Object-Oriented Programming</a></h3>
<p>Object-Oriented programming teaches you to think of everything as &quot;objects&quot;,
where each object is an instance of a &quot;class&quot;. The class specifies the data
and functionality for all objects of that type, in one place. Every object
of that class has the same data (with different values) and the same
associated functionality.</p>
<p>This is the opposite of the ECS mentality. In ECS, any <a href="programming//programming/ec.html#entities">entity</a> can
have any data (any combination of <a href="programming//programming/ec.html#components">components</a>). The purpose of
entities is to identify that data. Your <a href="programming//programming/systems.html">systems</a> are loose pieces
of functionality that can operate on any data. They can easily find what they
are looking for, and implement the desired behavior.</p>
<p>If you are an object-oriented programmer, you might be tempted to define a big
monolithic <code>struct Player</code> containing all the fields / properties of the player.
In Bevy, this is considered bad practice, because doing it that way can make it
more difficult to work with your data and limit performance. Instead, you should
make things granular, when different pieces of data may be accessed independently.</p>
<p>For example, represent the player in your game as an entity, composed
of separate component types (separate <code>struct</code>s) for things like the
health, XP, or whatever is relevant to your game. You can also attach
standard Bevy components like <a href="https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> (<a href="programming//fundamentals/transforms.html">transforms
explained</a>) to it.</p>
<p>Then, each piece of functionality (each <a href="programming//programming/systems.html">system</a>) can just
<a href="programming//programming/queries.html">query</a> for the data it needs. Common functionality (like a
health/damage system) can be applied to any entity with the matching components,
regardless of whether that's the player or something else in the game.</p>
<p>However, if some data always makes sense to be accessed together, then you
should put it in a single <code>struct</code>. For example, Bevy's
<a href="https://docs.rs/bevy/0.12.0/bevy/transform/components/struct.Transform.html"><code>Transform</code></a> or <a href="https://docs.rs/bevy/0.12.0/bevy/render/color/enum.Color.html"><code>Color</code></a>. With these types, the
fields are not likely to be useful independently.</p>
<h3 id="additional-internal-details"><a class="header" href="#additional-internal-details">Additional Internal Details</a></h3>
<p>The set / combination of components that a given entity has, is called the
entity's Archetype. Bevy keeps track of that internally, to organize the data in
RAM. Entities of the same Archetype have their data stored together, which
allows the CPU to access and cache it efficiently.</p>
<p>If you add/remove component types on existing entities, you are changing the
Archetype, which may require Bevy to copy the data to a different location.</p>
<p><a href="programming//patterns/component-storage.html">Learn more about Bevy's component storage.</a></p>
<p>Entity IDs can also be reused. The <a href="https://docs.rs/bevy/0.12.0/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> type is actually two
integers: the ID and a &quot;generation&quot;. After you despawn some entities, their IDs can
be reused for newly-spawned entities, but Bevy will increase the generation value.</p>
<h2 id="resources-1"><a class="header" href="#resources-1">Resources</a></h2>
<p>If there is only one global instance (singleton) of something, and it is
standalone (not associated with other data), create a <a href="programming//programming/res.html">Resource</a>.</p>
<p>For example, you could create a resource to store your game's graphics
settings, or the data for the currently active game mode or session.</p>
<p>This is a simple way of storing data, when you know you don't need the
flexibility of Entities/Components.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct GameSettings {
    current_level: u32,
    difficulty: u32,
    max_time_seconds: u32,
}

fn setup_game(
    mut commands: Commands,
) {
    // Add the GameSettings resource to the ECS
    // (if one already exists, it will be overwritten)
    commands.insert_resource(GameSettings {
        current_level: 1,
        difficulty: 100,
        max_time_seconds: 60,
    });
}

fn spawn_extra_enemies(
    mut commands: Commands,
    // we can easily access our resource from any system
    game_settings: Res&lt;GameSettings&gt;,
) {
    if game_settings.difficulty &gt; 50 {
        commands.spawn((
            // ...
        ));
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="intro-your-code"><a class="header" href="#intro-your-code">Intro: Your Code</a></h1>
<p>This page is an overview, to give you an idea of the big picture of how Bevy
works. Click on the various links to be taken to dedicated pages where you can
learn more about each concept.</p>
<hr />
<p>As mentioned in <a href="programming//programming/ecs-intro.html">the ECS Intro</a>, Bevy manages all of your
functionality/behaviors for you, running them when appropriate and giving them
access to whatever parts of <a href="programming//programming/intro-data.html">your data</a> they need.</p>
<p>Individual pieces of functionality are called <a href="programming//programming/systems.html">systems</a>. Each system
is a Rust function (<code>fn</code>) you write, which accepts <a href="programming//builtins.html#systemparams">special parameter
types</a> to indicate what <a href="programming//programming/intro-data.html">data</a> it needs to
access. Think of the function signature as a &quot;specification&quot; for what to fetch
from the ECS <a href="https://docs.rs/bevy/0.12.0/bevy/ecs/world/struct.World.html"><code>World</code></a>.</p>
<p>Here is what a <a href="programming//programming/systems.html">system</a> might look like. Note how, just by looking
at the function parameters, we know <em>exactly</em> what <a href="programming//programming/intro-data.html">data</a>
can be accessed.</p>
<pre><code class="language-rust no_run noplayground">fn enemy_detect_player(
    // access data from resources
    mut ai_settings: ResMut&lt;EnemyAiSettings&gt;,
    gamemode: Res&lt;GameModeData&gt;,
    // access data from entities/components
    query_player: Query&lt;&amp;Transform, With&lt;Player&gt;&gt;,
    query_enemies: Query&lt;&amp;mut Transform, (With&lt;Enemy&gt;, Without&lt;Player&gt;)&gt;,
    // in case we want to spawn/despawn entities, etc.
    mut commands: Commands,
) {
    // ... implement your behavior here ...
}</code></pre>
<p>(learn more about: <a href="programming//programming/systems.html">systems</a>, <a href="programming//programming/queries.html">queries</a>, <a href="programming//programming/commands.html">commands</a>, <a href="programming//programming/res.html">resources</a>, <a href="programming//programming/ec.html#entities">entities</a>, <a href="programming//programming/ec.html#components">components</a>)</p>
<h2 id="parallel-systems"><a class="header" href="#parallel-systems">Parallel Systems</a></h2>
<p>Based on the <a href="programming//builtins.html#systemparams">parameter</a> types of the <a href="programming//programming/systems.html">systems</a>
you write, Bevy knows what data each system can access and whether it conflicts
with any other systems.  Systems that do not conflict (don't access any of the
same data mutably) will be automatically <a href="programming//programming/system-order.html">run in parallel</a>
on different CPU threads. This way, you get multithreading, utilizing modern
multi-core CPU hardware effectively, with no extra effort from you!</p>
<p>For best parallelism performance, it is recommended that you keep your
functionality and <a href="programming//programming/intro-data.html">your data</a> granular. Create many small
systems, each one with a narrowly-scoped purpose and accessing only the data it
needs. This gives Bevy more opportunities for parallelism. Putting too much
functionality in one system, or too much data in a single
<a href="programming//programming/ec.html#components">component</a> or <a href="programming//programming/res.html">resource</a> <code>struct</code>, limits parallelism.</p>
<p>Bevy's parallelism is non-deterministic by default. Your systems might run in a
different and unpredictable order relative to one another, unless you add
<a href="programming//programming/system-order.html">ordering</a> dependencies to constrain it.</p>
<h2 id="exclusive-systems"><a class="header" href="#exclusive-systems">Exclusive Systems</a></h2>
<p><a href="programming//programming/exclusive.html">Exclusive</a> systems provide you with a way to get <a href="programming//programming/world.html">full direct
access</a> to the ECS <a href="programming//programming/world.html"><code>World</code></a>. They cannot run in parallel
with other systems, because they can access anything and do anything. Sometimes,
you might need this additonal power.</p>
<pre><code class="language-rust no_run noplayground">fn save_game(
    // get full access to the World, so we can access all data and do anything
    world: &amp;mut World,
) {
    // ... save game data to disk, or something ...
}</code></pre>
<h2 id="schedules-1"><a class="header" href="#schedules-1">Schedules</a></h2>
<p>Bevy stores systems inside of <a href="programming//programming/schedules.html">schedules</a>
(<a href="https://docs.rs/bevy/0.12.0/bevy/ecs/schedule/struct.Schedule.html"><code>Schedule</code></a>). The schedule contains the systems and all
relevant metadata to organize them, telling Bevy when and how to run them. Bevy
<a href="programming//programming/app-builder.html">Apps</a> typically contain many schedules. Each one is a collection of
systems to be invoked in different scenarios (every frame update, <a href="programming//fundamentals/fixed-timestep.html">fixed
timestep</a> update, at app startup, on <a href="programming//programming/states.html">state</a>
transitions, etc.).</p>
<p>The metadata stored in schedules allows you to control how systems run:</p>
<ul>
<li>Add <a href="programming//programming/run-criteria.html">run conditions</a> to control if systems should run during an
invocation of the schedule. You can disable systems if you only need them
to run sometimes.</li>
<li>Add <a href="programming//programming/system-order.html">ordering</a> constraints, if one system depends on
another system completing before it.</li>
</ul>
<p>Within schedules, systems can be grouped into <a href="programming//programming/system-sets.html">sets</a>. Sets
allow multiple systems to share common configuration/metadata. Systems
inherit configuration from all sets they belong to. Sets can also inherit
configuration from other sets.</p>
<p>Here is an illustration to help you visualize the logical structure of a
schedule. Let's look at how a hypothetical &quot;Update&quot; (run every frame) schedule of a
game might be organized.</p>
<p>List of <a href="programming//programming/systems.html">systems</a>:</p>
<div class="table-wrapper"><table><thead><tr><th><a href="programming//programming/systems.html">System</a> name</th><th><a href="programming//programming/system-sets.html">Sets</a> it belongs to</th><th><a href="programming//programming/run-criteria.html">Run conditions</a></th><th><a href="programming//programming/system-order.html">Ordering constraints</a></th></tr></thead><tbody>
<tr><td><code>footstep_sound</code></td><td><code>AudioSet</code> <code>GameplaySet</code></td><td></td><td><code>after(player_movement)</code> <code>after(enemy_movement)</code></td></tr>
<tr><td><code>player_movement</code></td><td><code>GameplaySet</code></td><td><code>player_alive</code> <code>not(cutscene)</code></td><td><code>after(InputSet)</code></td></tr>
<tr><td><code>camera_movement</code></td><td><code>GameplaySet</code></td><td></td><td><code>after(InputSet)</code></td></tr>
<tr><td><code>enemy_movement</code></td><td><code>EnemyAiSet</code></td><td></td><td></td></tr>
<tr><td><code>enemy_spawn</code></td><td><code>EnemyAiSet</code></td><td></td><td></td></tr>
<tr><td><code>enemy_despawn</code></td><td><code>EnemyAiSet</code></td><td></td><td><code>before(enemy_spawn)</code></td></tr>
<tr><td><code>mouse_input</code></td><td><code>InputSet</code></td><td><code>mouse_enabled</code></td><td></td></tr>
<tr><td><code>controller_input</code></td><td><code>InputSet</code></td><td><code>gamepad_enabled</code></td><td></td></tr>
<tr><td><code>background_music</code></td><td><code>AudioSet</code></td><td></td><td></td></tr>
<tr><td><code>ui_button_animate</code></td><td></td><td></td><td></td></tr>
<tr><td><code>menu_logo_animate</code></td><td><code>MainMenuSet</code></td><td></td><td></td></tr>
<tr><td><code>menu_button_sound</code></td><td><code>MainMenuSet</code> <code>AudioSet</code></td><td></td><td></td></tr>
<tr><td>...</td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p>List of <a href="programming//programming/system-sets.html">sets</a>:</p>
<div class="table-wrapper"><table><thead><tr><th><a href="programming//programming/system-sets.html">Set</a> name</th><th>Parent Sets</th><th><a href="programming//programming/run-criteria.html">Run conditions</a></th><th><a href="programming//programming/system-order.html">Ordering constraints</a></th></tr></thead><tbody>
<tr><td><code>MainMenuSet</code></td><td></td><td><code>in_state(MainMenu)</code></td><td></td></tr>
<tr><td><code>GameplaySet</code></td><td></td><td><code>in_state(InGame)</code></td><td></td></tr>
<tr><td><code>InputSet</code></td><td><code>GameplaySet</code></td><td></td><td></td></tr>
<tr><td><code>EnemyAiSet</code></td><td><code>GameplaySet</code></td><td><code>not(cutscene)</code></td><td><code>after(player_movement)</code></td></tr>
<tr><td><code>AudioSet</code></td><td></td><td><code>not(audio_muted)</code></td><td></td></tr>
</tbody></table>
</div>
<p>Note that it doesn't matter in what order systems are listed in the schedule.
Their <a href="programming//programming/system-order.html">order</a> of execution is determined by the metadata. Bevy
will respect those constraints, but otherwise run systems in parallel as much as
it can, depending on what CPU threads are available.</p>
<p>Also note how our hypothetical game is implemented using many individually-small
systems. For example, instead of playing audio inside of the <code>player_movement</code>
system, we made a separate <code>play_footstep_sounds</code> system. These two pieces of
functionality probably need to access different <a href="programming//programming/intro-data.html">data</a>, so
putting them in separate systems allows Bevy more opportunities for parallelism.
By being separate systems, they can also have different configuration. The
<code>play_footstep_sounds</code> system can be added to an <code>AudioSet</code>
<a href="programming//programming/system-sets.html">set</a>, from which it inherits a <code>not(audio_muted)</code> <a href="programming//programming/run-criteria.html">run
condition</a>.</p>
<p>Similarly, we put mouse and controller input in separate systems. The <code>InputSet</code>
set allows systems like <code>player_movement</code> to share an ordering dependency
on all of them at once.</p>
<p>You can see how Bevy's scheduling APIs give you a lot of flexibility to organize
all the functionality in your game. What will you do with all this power? ;)</p>
<hr />
<p>Here is how <a href="programming//programming/schedules.html">schedule</a> that was illustrated above could be
created in code:</p>
<pre><code class="language-rust no_run noplayground">// Set configuration is per-schedule. Here we do it for `Update`
app.configure_sets(Update, (
    MainMenuSet
        .run_if(in_state(MainMenu)),
    GameplaySet
        .run_if(in_state(InGame)),
    InputSet
        .in_set(GameplaySet),
    EnemyAiSet
        .in_set(GameplaySet)
        .run_if(not(cutscene))
        .after(player_movement),
    AudioSet
        .run_if(not(audio_muted)),
));
app.add_systems(Update, (
    (
        ui_button_animate,
        menu_logo_animate.in_set(MainMenuSet),
    ),
    (
        enemy_movement,
        enemy_spawn,
        enemy_despawn.before(enemy_spawn),
    ).in_set(EnemyAiSet),
    (
        mouse_input.run_if(mouse_enabled),
        controller_input.run_if(gamepad_enabled),
    ).in_set(InputSet),
    (
        footstep_sound.in_set(GameplaySet),
        menu_button_sound.in_set(MainMenuSet),
        background_music,
    ).in_set(AudioSet),
    (
        player_movement
            .run_if(player_alive)
            .run_if(not(cutscene)),
        camera_movement,
    ).in_set(GameplaySet).after(InputSet),
));</code></pre>
<p>(learn more about: <a href="programming//programming/schedules.html">schedules</a>, <a href="programming//programming/system-sets.html">system sets</a>, <a href="programming//programming/states.html">states</a>, <a href="programming//programming/run-criteria.html">run conditions</a>, <a href="programming//programming/system-order.html">system ordering</a>)</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="the-app"><a class="header" href="#the-app">The App</a></h1>
<p>Relevant official examples: All of them ;)</p>
<p>In particular, check out the complete game examples:
<a href="https://github.com/bevyengine/bevy/blob/main/examples/games/alien_cake_addict.rs"><code>alien_cake_addict</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/main/examples/games/breakout.rs"><code>breakout</code></a>.</p>
<hr />
<p>To enter the Bevy runtime, you need to configure an <a href="https://docs.rs/bevy/0.12.0/bevy/app/struct.App.html"><code>App</code></a>. The app
is how you define the structure of all the things that make up your project:
<a href="programming//programming/plugins.html">plugins</a>, <a href="programming//programming/systems.html">systems</a> (and their configuration/metadata:
<a href="programming//programming/run-criteria.html">run conditions</a>, <a href="programming//programming/system-order.html">ordering</a>, <a href="programming//programming/system-sets.html">sets</a>),
<a href="programming//programming/events.html">event</a> types, <a href="programming//programming/states.html">states</a>, <a href="programming//programming/schedules.html">schedules</a>‚Ä¶</p>
<p>You typically create your <a href="https://docs.rs/bevy/0.12.0/bevy/app/struct.App.html"><code>App</code></a> in your project's <code>main</code> function.
However, you don't have to add everything from there. If you want to add things
to your app from multiple places (like other Rust files or crates), use
<a href="programming//programming/plugins.html">plugins</a>. As your project grows, you will need to do that to keep
everything organized.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        // Bevy itself:
        .add_plugins(DefaultPlugins)

        // events:
        .add_event::&lt;LevelUpEvent&gt;()

        // systems to run once at startup:
        .add_systems(Startup, spawn_things)

        // systems to run each frame:
        .add_systems(Update, (
            player_level_up,
            debug_levelups,
            debug_stats_change,
        ))
        // ...

        // launch the app!
        .run();
}</code></pre>
<p>Note: use tuples with <code>add_systems</code>/<code>add_plugins</code>/<code>configure_sets</code> to add
multiple things at once.</p>
<p><a href="programming//programming/ec.html#components">Component</a> types do not need to be registered.</p>
<p>Schedules cannot <a href="https://github.com/bevyengine/bevy/issues/279">(yet)</a> be modified at runtime; all
<a href="programming//programming/systems.html">systems</a> you want to run must be added/configured in the
<a href="https://docs.rs/bevy/0.12.0/bevy/app/struct.App.html"><code>App</code></a> ahead of time. You can control individual systems using <a href="programming//programming/run-criteria.html">run
conditions</a>. You can also <a href="programming//patterns/schedule-dynamic.html">dynamically enable/disable entire
schedules</a> using the
<a href="https://docs.rs/bevy/0.12.0/bevy/app/struct.MainScheduleOrder.html"><code>MainScheduleOrder</code></a> <a href="programming//programming/res.html">resource</a>.</p>
<h2 id="builtin-bevy-functionality"><a class="header" href="#builtin-bevy-functionality">Builtin Bevy Functionality</a></h2>
<p>The Bevy game engine's own functionality is represented as a <a href="programming//programming/plugins.html#plugin-groups">plugin group</a>.
Every typical Bevy app must first add it, using either:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.12.0/bevy/struct.DefaultPlugins.html"><code>DefaultPlugins</code></a> if you are making a full game/app</li>
<li><a href="https://docs.rs/bevy/0.12.0/bevy/struct.MinimalPlugins.html"><code>MinimalPlugins</code></a> for something like a headless server.</li>
</ul>
<h2 id="setting-up-data"><a class="header" href="#setting-up-data">Setting up data</a></h2>
<p>Normally, you can set up <a href="programming//programming/intro-data.html">your data</a> from
<a href="programming//programming/systems.html">systems</a>. Use <a href="programming//programming/commands.html">Commands</a> from regular systems, or
use <a href="programming//programming/exclusive.html">exclusive systems</a> to get <a href="programming//programming/world.html">full World access</a>.</p>
<p>Add your setup systems as startup systems for things you want to initialize
at launch, or use <a href="programming//programming/states.html">state</a> enter/exit systems to do things when
transitioning between menus, game modes, levels, etc.</p>
<p>However, you can also initialize data directly from the app builder. This
is common for <a href="programming//programming/res.html">resources</a>, if they need to be present at all
times. You can also get <a href="programming//programming/world.html">direct World access</a>.</p>
<pre><code class="language-rust no_run noplayground">// Create (or overwrite) resource with specific value
app.insert_resource(StartingLevel(3));

// Ensure resource exists; if not, create it
// (using `Default` or `FromWorld`)
app.init_resource::&lt;MyFancyResource&gt;();

// We can also access/manipulate the World directly
// (in this example, to spawn an entity, but you can do anything)
app.world.spawn(SomeBundle::default());</code></pre>
<h2 id="quitting-the-app"><a class="header" href="#quitting-the-app">Quitting the App</a></h2>
<p>To cleanly shut down bevy, send an <a href="https://docs.rs/bevy/0.12.0/bevy/app/struct.AppExit.html"><code>AppExit</code></a>
<a href="programming//programming/events.html">event</a> from any <a href="programming//programming/systems.html">system</a>:</p>
<pre><code class="language-rust no_run noplayground">use bevy::app::AppExit;

fn exit_system(mut exit: EventWriter&lt;AppExit&gt;) {
    exit.send(AppExit);
}</code></pre>
<p>For prototyping, Bevy provides a convenient system you can add, to close the
focused window on pressing the <code>Esc</code> key. When all windows are closed, Bevy will
quit automatically.</p>
<pre><code class="language-rust no_run noplayground">app.add_systems(Update, bevy::window::close_on_esc);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="systems"><a class="header" href="#systems">Systems</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/main/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/main/examples/ecs/startup_system.rs"><code>startup_system</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/main/examples/ecs/system_param.rs"><code>system_param</code></a>.</p>
<hr />
<p>Systems are pieces of functionality, which are run by Bevy. They are typically
implemented using regular Rust functions.</p>
<p>This is how you implement all your game logic. Each system specifies what data
it needs to access to do its thing, and Bevy will run them in parallel when
possible.</p>
<p>These functions can only take <a href="programming//builtins.html#systemparams">special parameter types</a>,
to specify what <a href="programming//programming/intro-data.html">data</a> you need access to. If you use
unsupported parameter types in your function, <a href="programming//pitfalls/into-system.html">you will get confusing compiler
errors!</a></p>
<p>Some of the possibilities are:</p>
<ul>
<li>accessing <a href="programming//programming/res.html">resources</a> using <a href="https://docs.rs/bevy/0.12.0/bevy/ecs/system/struct.Res.html"><code>Res</code></a>/<a href="https://docs.rs/bevy/0.12.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut</code></a></li>
<li>accessing <a href="programming//programming/ec.html#components">components of entities</a> using <a href="programming//programming/queries.html">queries</a> (<a href="https://docs.rs/bevy/0.12.0/bevy/ecs/system/struct.Query.html"><code>Query</code></a>)</li>
<li>creating/destroying entities, components, and resources using <a href="programming//programming/commands.html">Commands</a> (<a href="https://docs.rs/bevy/0.12.0/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>)</li>
<li>sending/receiving <a href="programming//programming/events.html">events</a> using <a href="https://docs.rs/bevy/0.12.0/bevy/ecs/event/struct.EventWriter.html"><code>EventWriter</code></a>/<a href="https://docs.rs/bevy/0.12.0/bevy/ecs/event/struct.EventReader.html"><code>EventReader</code></a></li>
</ul>
<p><a href="programming//builtins.html#systemparams">See here for a full list!</a></p>
<pre><code class="language-rust no_run noplayground">fn debug_start(
    // access resource
    start: Res&lt;StartingLevel&gt;
) {
    eprintln!(&quot;Starting on level {:?}&quot;, *start);
}</code></pre>
<p>System parameters can be grouped into tuples (which can be nested). This is
useful for organization.</p>
<pre><code class="language-rust no_run noplayground">fn complex_system(
    (a, mut b): (Res&lt;ResourceA&gt;, ResMut&lt;ResourceB&gt;),
    (q0, q1, q2): (Query&lt;(/* ‚Ä¶ */)&gt;, Query&lt;(/* ‚Ä¶ */)&gt;, Query&lt;(/* ‚Ä¶ */)&gt;),
) {
    // ‚Ä¶
}</code></pre>
<p>Your function can have a maximum of 16 total parameters. If you need more,
group them into tuples to work around the limit. Tuples can contain up to
16 members, but can be nested indefinitely.</p>
<p>There is also a different kind of systems: <a href="programming//programming/exclusive.html">exclusive systems</a>.
They have <a href="programming//programming/world.html">full direct access to the ECS World</a>, so you can access
any data you want and do anything, but cannot run in parallel. For most use
cases, you should use regular parallel systems.</p>
<pre><code class="language-rust no_run noplayground">fn reload_game(world: &amp;mut World) {
    // ... access whatever we want from the World
}</code></pre>
<h2 id="runtime"><a class="header" href="#runtime">Runtime</a></h2>
<p>To run your systems, you need to add them to Bevy via the <a href="programming//programming/app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        // run these only once at launch
        .add_systems(Startup, (setup_camera, debug_start))
        // run these every frame update
        .add_systems(Update, (move_player, enemies_ai))
        // ...
        .run();
}</code></pre>
<p>Be careful: writing a new system <code>fn</code> and forgetting to add it to your app is a
common mistake! If you run your project and your new code doesn't seem to be
running, make sure you added the system!</p>
<p>The above is enough for simple projects.</p>
<p>Systems are contained in <a href="programming//programming/schedules.html">schedules</a>. <a href="https://docs.rs/bevy/0.12.0/bevy/app/struct.Update.html"><code>Update</code></a> is the
schedule where you typically add any systems you want to run every frame.
<a href="https://docs.rs/bevy/0.12.0/bevy/app/struct.Startup.html"><code>Startup</code></a> is where you typically add systems that should run
only once on app startup. There are also <a href="programming//builtins.html#schedules">other possibilities</a>.</p>
<p>As your project grows more complex, you might want to make use of some of the
powerful tools that Bevy offers for managing when/how your systems run, such as:
<a href="programming//programming/system-order.html">explicit ordering</a>, <a href="programming//programming/run-criteria.html">run conditions</a>, <a href="programming//programming/system-sets.html">system
sets</a>, <a href="programming//programming/states.html">states</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="resources-2"><a class="header" href="#resources-2">Resources</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/main/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p>Resources allow you to store a single global instance of some data type,
independently of <a href="programming//programming/intro-data.html#entities--components">entities</a>.</p>
<p>Use them for <a href="programming//programming/intro-data.html">data</a> that is truly global for your app, such
as configuration / settings. Resources make it easy for you to access such data
from anywhere.</p>
<hr />
<p>To create a new resource type, simply define a Rust <code>struct</code> or <code>enum</code>, and
derive the <a href="https://docs.rs/bevy/0.12.0/bevy/ecs/system/trait.Resource.html"><code>Resource</code></a> trait, similar to
<a href="programming//programming/ec.html#components">components</a> and <a href="programming//programming/events.html">events</a>.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct GoalsReached {
    main_goal: bool,
    bonus: u32,
}</code></pre>
<p>Types must be unique; there can only be at most one instance of a given type. If
you might need multiple, consider using <a href="programming//programming/intro-data.html#entities--components">entities and components</a> instead.</p>
<p>Bevy <a href="programming//builtins.html#resources">uses resources for many things</a>. You can use these builtin
resources to access various features of the engine. They work just like your own
custom types.</p>
<h2 id="accessing-resources"><a class="header" href="#accessing-resources">Accessing Resources</a></h2>
<p>To access the value of a resource from <a href="programming//programming/systems.html">systems</a>, use <code>Res</code>/<code>ResMut</code>:</p>
<pre><code class="language-rust no_run noplayground">fn my_system(
    // these will panic if the resources don't exist
    mut goals: ResMut&lt;GoalsReached&gt;,
    other: Res&lt;MyOtherResource&gt;,
    // use Option if a resource might not exist
    mut fancy: Option&lt;ResMut&lt;MyFancyResource&gt;&gt;,
) {
    if let Some(fancy) = &amp;mut fancy {
        // TODO: do things with `fancy`
    }
    // TODO: do things with `goals` and `other`
}</code></pre>
<h2 id="managing-resources"><a class="header" href="#managing-resources">Managing Resources</a></h2>
<p>If you need to create/remove resources at runtime, you can do so using
<a href="programming//programming/commands.html">commands</a> (<a href="https://docs.rs/bevy/0.12.0/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>):</p>
<pre><code class="language-rust no_run noplayground">fn my_setup(mut commands: Commands, /* ... */) {
    // add (or overwrite) resource, using the provided data
    commands.insert_resource(GoalsReached { main_goal: false, bonus: 100 });
    // ensure resource exists (creating if necessary)
    commands.init_resource::&lt;MyFancyResource&gt;();
    // remove a resource (if it exists)
    commands.remove_resource::&lt;MyOtherResource&gt;();
}</code></pre>
<p>Alternatively, using <a href="programming//programming/world.html">direct World access</a> from an <a href="programming//programming/exclusive.html">exclusive
system</a>:</p>
<pre><code class="language-rust no_run noplayground">fn my_setup2(world: &amp;mut World) {
    // The same methods as with Commands are also available here,
    // but we can also do fancier things:

    // Check if resource exists
    if !world.contains_resource::&lt;MyFancyResource&gt;() {
        // Get access to a resource, inserting a custom value if unavailable
        let _bonus = world.get_resource_or_insert_with(
            || GoalsReached { main_goal: false, bonus: 100 }
        ).bonus;
    }
}</code></pre>
<p>Resources can also be set up from the <a href="programming//programming/app-builder.html">app builder</a>. Do this for
resources that are meant to always exist from the start.</p>
<pre><code class="language-rust no_run noplayground">App::new()
    .add_plugins(DefaultPlugins)
    .insert_resource(StartingLevel(3))
    .init_resource::&lt;MyFancyResource&gt;()
    // ...</code></pre>
<h2 id="resource-initialization"><a class="header" href="#resource-initialization">Resource Initialization</a></h2>
<p>Implement <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>Default</code></a> for simple resources:</p>
<pre><code class="language-rust no_run noplayground">// simple derive, to set all fields to their defaults
#[derive(Resource, Default)]
struct GameProgress {
    game_completed: bool,
    secrets_unlocked: u32,
}

#[derive(Resource)]
struct StartingLevel(usize);

// custom implementation for unusual values
impl Default for StartingLevel {
    fn default() -&gt; Self {
        StartingLevel(1)
    }
}

// on enums, you can specify the default variant
#[derive(Resource, Default)]
enum GameMode {
    Tutorial,
    #[default]
    Singleplayer,
    Multiplayer,
}</code></pre>
<p>For resources that need complex initialization, implement <a href="https://docs.rs/bevy/0.12.0/bevy/ecs/world/trait.FromWorld.html"><code>FromWorld</code></a>:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Resource)]
struct MyFancyResource { /* stuff */ }

impl FromWorld for MyFancyResource {
    fn from_world(world: &amp;mut World) -&gt; Self {
        // You have full access to anything in the ECS World from here.
        // For example, you can access (and mutate!) other resources:
        let mut x = world.resource_mut::&lt;MyOtherResource&gt;();
        x.do_mut_stuff();

        MyFancyResource { /* stuff */ }
    }
}</code></pre>
<p>Beware: it can be easy to get yourself into a mess of unmaintainable code
if you overuse <a href="https://docs.rs/bevy/0.12.0/bevy/ecs/world/trait.FromWorld.html"><code>FromWorld</code></a> to do complex things.</p>
<h2 id="usage-advice"><a class="header" href="#usage-advice">Usage Advice</a></h2>
<p>The choice of when to use <a href="programming//programming/intro-data.html#entities--components">entities/components</a> vs. resources is
typically about how you want to access the <a href="programming//programming/intro-data.html">data</a>: globally
from anywhere (resources), or using ECS patterns (entities/components).</p>
<p>Even if there is only one of a certain thing in your game (such as the
player in a single-player game), it can be a good fit to use an entity
instead of resources, because entities are composed of multiple components,
some of which can be common with other entities. This can make your game
logic more flexible. For example, you could have a &quot;health/damage system&quot;
that works with both the player and enemies.</p>
<h3 id="settings"><a class="header" href="#settings">Settings</a></h3>
<p>One common usage of resources is for storing settings and configuration.</p>
<p>However, if it is something that cannot be changed at runtime and only used when
initializing a <a href="programming//programming/plugins.html">plugin</a>, consider putting that inside the plugin's
<code>struct</code>, instead of a resource.</p>
<h3 id="caches"><a class="header" href="#caches">Caches</a></h3>
<p>Resources are also useful if you want to store some data in a way that is easier
or more efficient for you to access. For example, keeping a collection of <a href="programming//assets/handles.html">asset
handles</a>, or using a custom datastructure for representing a game
map more efficiently than using entities and components, etc.</p>
<p><a href="programming//programming/intro-data.html#entities--components">Entities and Components</a>, as flexible as they are, are not necessarily
the best fit for all use cases. If you want to represent your data some other
way, feel free to do so. Simply create a resource and put it there.</p>
<h3 id="interfacing-with-external-libraries"><a class="header" href="#interfacing-with-external-libraries">Interfacing with external libraries</a></h3>
<p>If you want to integrate some external non-Bevy software into a Bevy app,
it can be very convenient to create a resource to hold onto its state/data.</p>
<p>For example, if you wanted to use an external physics or audio engine, you
could put all its data in a resource, and write some systems to call its
functions. That can give you an easy way to interface with it from Bevy code.</p>
<p>If the external code is not thread-safe (<code>!Send</code> in Rust parlance), which is
common for non-Rust (e.g C++ and OS-level) libraries, you should use a
<a href="programming//programming/non-send.html">Non-Send</a> Bevy resource instead. This will make sure any Bevy
system that touches it will run on the main thread.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/main/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<h1 id="entities"><a class="header" href="#entities">Entities</a></h1>
<p><a href="programming//programming/intro-data.html">See here for more explanation on how storing data in the ECS works.</a></p>
<p>Conceptually, an entity represents a set of values for different components.
Each component is a Rust type (<code>struct</code> or <code>enum</code>) and an entity can be used to
store a value of that type.</p>
<p>Technically, an entity is just a simple integer ID (imagine the &quot;row number&quot; in
a table/spreadsheet) that can be used to find related data values (in different
&quot;columns&quot; of that table).</p>
<p>In Bevy, <a href="https://docs.rs/bevy/0.12.0/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> is this value. It consists of two integers:
the ID and the &quot;generation&quot; (allowing IDs to be reused, after you despawn old
entities).</p>
<p>You can create (&quot;spawn&quot;) new entities and destroy (&quot;despawn&quot;) entities using
<a href="programming//programming/commands.html"><code>Commands</code></a> or <a href="programming//programming/world.html">exclusive <code>World</code> access</a>.</p>
<pre><code class="language-rust no_run noplayground">fn setup(mut commands: Commands) {
    // create a new entity
    commands.spawn((
        // Initialize all your components and bundles here
        Enemy,
        Health {
            hp: 100.0,
            extra: 25.0,
        },
        AiMode::Passive,
        // ...
    ));

    // If you want to get the Entity ID, just call `.id()` after spawn
    let my_entity = commands.spawn((/* ... */)).id();

    // destroy an entity, removing all data associated with it
    commands.entity(my_entity).despawn();
}</code></pre>
<p>Many of your entities might need to have the same common components. You can use
<a href="programming//programming/bundle.html">Bundles</a> to make it easier to spawn your entities.</p>
<h1 id="components-1"><a class="header" href="#components-1">Components</a></h1>
<p>Components are the data associated with entities.</p>
<p>To create a new component type, simply define a Rust <code>struct</code> or <code>enum</code>, and
derive the <a href="https://docs.rs/bevy/0.12.0/bevy/ecs/component/trait.Component.html"><code>Component</code></a> trait.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct Health {
    hp: f32,
    extra: f32,
}

#[derive(Component)]
enum AiMode {
    Passive,
    ChasingPlayer,
}</code></pre>
<p>Types must be unique ‚Äì an entity can only have one component per Rust type.</p>
<h2 id="newtype-components"><a class="header" href="#newtype-components">Newtype Components</a></h2>
<p>Use wrapper (newtype) structs to make unique components out of simpler types:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Component)]
struct PlayerXp(u32);

#[derive(Component)]
struct PlayerName(String);</code></pre>
<h2 id="marker-components"><a class="header" href="#marker-components">Marker Components</a></h2>
<p>You can use empty structs to help you identify specific entities. These are
known as &quot;marker components&quot;. Useful with <a href="programming//programming/queries.html#query-filters">query filters</a>.</p>
<pre><code class="language-rust no_run noplayground">/// Add this to all menu ui entities to help identify them
#[derive(Component)]
struct MainMenuUI;

/// Marker for hostile game units
#[derive(Component)]
struct Enemy;

/// This will be used to identify the main player entity
#[derive(Component)]
struct Player;

/// Tag all creatures that are currently friendly towards the player
#[derive(Component)]
struct Friendly;</code></pre>
<h2 id="accessing-components"><a class="header" href="#accessing-components">Accessing Components</a></h2>
<p>Components can be accessed from <a href="programming//programming/systems.html">systems</a>, using <a href="programming//programming/queries.html">queries</a>.</p>
<p>You can think of the query as the &quot;specification&quot; for the data you want to access.
It will search for entities that match and give you access to the data.</p>
<pre><code class="language-rust no_run noplayground">fn level_up_player(
    // get the relevant data. some components read-only, some mutable
    mut query_player: Query&lt;(&amp;PlayerName, &amp;mut PlayerXp, &amp;mut Health), With&lt;Player&gt;&gt;,
) {
    // `single` assumes only one entity exists that matches the query
    let (name, mut xp, mut health) = query_player.single_mut();
    if xp.0 &gt; 1000 {
        xp.0 = 0;
        health.hp = 100.0;
        health.extra += 25.0;
        info!(&quot;Player {} leveled up!&quot;, name.0);
    }
}

fn die(
    // `Entity` can be used to get the ID of things that match the query
    query_health: Query&lt;(Entity, &amp;Health)&gt;,
    // we also need Commands, so we can despawn entities if we have to
    mut commands: Commands,
) {
    // we can have many such entities (enemies, player, whatever)
    // so we loop to check all of them
    for (entity_id, health) in query_health.iter() {
        if health.hp &lt;= 0.0 {
            commands.entity(entity_id).despawn();
        }
    }
}</code></pre>
<h2 id="addingremoving-components"><a class="header" href="#addingremoving-components">Adding/removing Components</a></h2>
<p>You can add/remove components on existing entities, using <a href="programming//programming/commands.html"><code>Commands</code></a> or
<a href="programming//programming/world.html">exclusive <code>World</code> access</a>.</p>
<pre><code class="language-rust no_run noplayground">fn make_enemies_friendly(
    query_enemy: Query&lt;Entity, With&lt;Enemy&gt;&gt;,
    mut commands: Commands,
) {
    for entity_id in query_enemy.iter() {
        commands.entity(entity_id)
            .remove::&lt;Enemy&gt;()
            .insert(Friendly);
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/main/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<h1 id="bundles-1"><a class="header" href="#bundles-1">Bundles</a></h1>
<p>You can think of Bundles like &quot;templates&quot; or &quot;blueprints&quot; for creating entities.
They make it easy to create <a href="programming//programming/ec.html#entities">entities</a> with a common set of
<a href="programming//programming/ec.html#components">components</a>.</p>
<p>By creating a bundle type, instead of adding your components one by one, you
can make sure that you will never accidentally forget some important component
on your entities. The Rust compiler will give an error if you do not set all
the fields of a struct, thus helping you make sure your code is correct.</p>
<p>Bevy provides many <a href="programming//builtins.html#bundles">built-in bundle types</a> that you can use
to spawn common kinds of entities.</p>
<p>Here is how to create your own bundle:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Bundle)]
struct PlayerBundle {
    xp: PlayerXp,
    name: PlayerName,
    health: Health,
    marker: Player,

    // We can nest/include another bundle.
    // Add the components for a standard Bevy Sprite:
    sprite: SpriteSheetBundle,
}</code></pre>
<p>You can then use your bundle when you spawn your entities:</p>
<pre><code class="language-rust no_run noplayground">commands.spawn(PlayerBundle {
    xp: PlayerXp(0),
    name: PlayerName(&quot;Player 1&quot;.into()),
    health: Health {
        hp: 100.0,
        extra: 0.0,
    },
    marker: Player,
    sprite: SpriteSheetBundle {
        // TODO
        ..Default::default()
    },
});</code></pre>
<p>If you want to have default values (similar to Bevy's bundles):</p>
<pre><code class="language-rust no_run noplayground">impl Default for PlayerBundle {
    fn default() -&gt; Self {
        Self {
            xp: PlayerXp(0),
            name: PlayerName(&quot;Player&quot;.into()),
            health: Health {
                hp: 100.0,
                extra: 0.0,
            },
            marker: Player,
            sprite: Default::default(),
        }
    }
}</code></pre>
<p>Now you can do this:</p>
<pre><code class="language-rust no_run noplayground">commands.spawn(PlayerBundle {
    name: PlayerName(&quot;Player 1&quot;.into()),
    ..Default::default()
});</code></pre>
<h2 id="loose-components-as-bundles"><a class="header" href="#loose-components-as-bundles">Loose components as bundles</a></h2>
<p>Technically, Bevy also considers arbitrary tuples of components as bundles:</p>
<pre><code>(ComponentA, ComponentB, ComponentC)
</code></pre>
<p>This allows you to easily spawn an entity using a loose bunch of components (or
bundles), or add more arbitrary components when you spawn entities. However,
this way you don't have the compile-time correctness advantages that a
well-defined <code>struct</code> gives you.</p>
<pre><code class="language-rust no_run noplayground">commands.spawn((
    SpriteBundle {
        // ...
        ..default()
    },
    Health {
        hp: 50.0,
        extra: 0.0,
    },
    Enemy,
    // ...
));</code></pre>
<p>You should strongly consider creating proper <code>struct</code>s, especially if you are
likely to spawn many similar entities. It will make your code easier to maintain.</p>
<h2 id="querying"><a class="header" href="#querying">Querying</a></h2>
<p>Note that you cannot <a href="programming//programming/queries.html">query</a> for a whole bundle. Bundles are just a
convenience when creating the entities. Query for the individual component types
that your <a href="programming//programming/systems.html">system</a> needs to access.</p>
<p>This is <em>wrong</em>:</p>
<pre><code class="language-rust no_run noplayground">fn my_system(query: Query&lt;&amp;SpriteBundle&gt;) {
  // ...
}</code></pre>
<p>Instead, do this:</p>
<pre><code class="language-rust no_run noplayground">fn my_system(query: Query&lt;(&amp;Transform, &amp;Handle&lt;Image&gt;)&gt;) {
  // ...
}</code></pre>
<p>(or whatever specific components you need in that system)</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="queries"><a class="header" href="#queries">Queries</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p>Queries let you access <a href="programming//programming/ecs-intro.html">components of entities</a>.</p>
<p>Use the <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.Query.html"><code>Query</code></a> <a href="programming//programming/systems.html">system parameter</a>, where you can
specify the data you want to access, and optionally additional
<a href="programming//programming/queries.html#query-filters">filters</a> for selecting entities.</p>
<p>Think of the types you put in your <code>Query</code> as a &quot;specification&quot; for selecting
what entities you want to access. Queries will match only those entities in the
ECS World that fit your specification. You are then able to access the relevant
data from individual such entities (using an <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> ID), or
iterate to access all entities that qualify.</p>
<p>The first type parameter for a query is the data you want to access. Use <code>&amp;</code> for
shared/readonly access and <code>&amp;mut</code> for exclusive/mutable access. Use <code>Option</code> if
the component is not required (you want to find entities with or without that
component. If you want multiple components, put them in a tuple.</p>
<pre><code class="language-rust no_run noplayground">fn check_zero_health(
    // access entities that have `Health` and `Transform` components
    // get read-only access to `Health` and mutable access to `Transform`
    // optional component: get access to `Player` if it exists
    mut query: Query&lt;(&amp;Health, &amp;mut Transform, Option&lt;&amp;Player&gt;)&gt;,
) {
    // get all matching entities
    for (health, mut transform, player) in query.iter_mut() {
        eprintln!(&quot;Entity at {} has {} HP.&quot;, transform.translation, health.hp);

        // center if hp is zero
        if health.hp &lt;= 0.0 {
            transform.translation = Vec3::ZERO;
        }

        if let Some(player) = player {
            // the current entity is the player!
            // do something special!
        }
    }
}</code></pre>
<p>The above example used iteration to access all entities that the query could find.</p>
<p>To access the <a href="programming//programming/ec.html#components">components</a> from specific <a href="programming//programming/ec.html#entities">entity</a>
only:</p>
<pre><code class="language-rust no_run noplayground">    if let Ok((health, mut transform)) = query.get_mut(entity) {
        // do something with the components
    } else {
        // the entity does not have the components from the query
    }</code></pre>
<p>If you want to know the entity IDs of the entities you are accessing, you can
put the special <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> type in your query. This is useful
together with iteration, so you can identify the entities that the query found:</p>
<pre><code class="language-rust no_run noplayground">// add `Entity` to `Query` to get Entity IDs
fn query_entities(q: Query&lt;(Entity, /* ... */)&gt;) {
    for (e, /* ... */) in q.iter() {
        // `e` is the Entity ID of the entity we are accessing
    }
}</code></pre>
<p>If you know that the query is expected to only ever match a single entity, you
can use <code>single</code>/<code>single_mut</code> (panic on error) or <code>get_single</code>/<code>get_single_mut</code>
(return <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code>Result</code></a>). These methods ensure that there exists exactly
one candidate entity that can match your query, and will produce an error
otherwise.</p>
<pre><code class="language-rust no_run noplayground">fn query_player(mut q: Query&lt;(&amp;Player, &amp;mut Transform)&gt;) {
    let (player, mut transform) = q.single_mut();

    // do something with the player and its transform
}</code></pre>
<h2 id="bundles-2"><a class="header" href="#bundles-2">Bundles</a></h2>
<p>Queries work with individual components. If you created an entity using a
<a href="programming//programming/bundle.html">bundle</a>, you need to query for the specific components from
that bundle that you care about.</p>
<p>A common beginner mistake is to query for the bundle type!</p>
<h2 id="query-filters"><a class="header" href="#query-filters">Query Filters</a></h2>
<p>Add query filters to narrow down the entities you get from the query.</p>
<p>This is done using the second (optional) generic type parameter of the
<a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.Query.html"><code>Query</code></a> type.</p>
<p>Note the syntax of the query: first you specify the data you want to access
(using a tuple to access multiple things), and then you add any additional
filters (can also be a tuple, to add multiple).</p>
<p>Use <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/query/struct.With.html"><code>With</code></a>/<a href="https://docs.rs/bevy/0.9.1/bevy/ecs/query/struct.Without.html"><code>Without</code></a> to only get entities
that have specific components.</p>
<pre><code class="language-rust no_run noplayground">fn debug_player_hp(
    // access the health (and optionally the PlayerName, if present), only for friendly players
    query: Query&lt;(&amp;Health, Option&lt;&amp;PlayerName&gt;), (With&lt;Player&gt;, Without&lt;Enemy&gt;)&gt;,
) {
    // get all matching entities
    for (health, name) in query.iter() {
        if let Some(name) = name {
            eprintln!(&quot;Player {} has {} HP.&quot;, name.0, health.hp);
        } else {
            eprintln!(&quot;Unknown player has {} HP.&quot;, health.hp);
        }
    }
}</code></pre>
<p>This is useful if you don't actually care about the data stored inside these
components, but you want to make sure that your query only looks for entities
that have (or not have) them. If you want the data, then put the component in
the first part of the query (as shown previously), instead of using a filter.</p>
<p>Multiple filters can be combined:</p>
<ul>
<li>in a tuple to apply all of them (AND logic)</li>
<li>using the <code>Or&lt;(‚Ä¶)&gt;</code> wrapper to detect any of them (OR logic).
<ul>
<li>(note the tuple inside)</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p>Use <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a> to spawn/despawn entities, add/remove
components on existing entities, manage resources.</p>
<p>These actions do not take effect immediately; they are queued to be performed
later when it is safe to do so. See: <a href="programming//programming/schedules.html">stages</a>.</p>
<p>(if you are not using stages, that means your other <a href="programming//programming/systems.html">systems</a>
will see them on the next frame update)</p>
<pre><code class="language-rust no_run noplayground">fn spawn_things(
    mut commands: Commands,
) {
    // manage resources
    commands.insert_resource(MyResource);
    commands.remove_resource::&lt;MyResource&gt;();

    // create a new entity using `spawn`,
    // providing the data for the components it should have
    // (typically using a Bundle)
    commands.spawn(PlayerBundle {
        name: PlayerName(&quot;Henry&quot;.into()),
        xp: PlayerXp(1000),
        health: Health {
            hp: 100.0, extra: 20.0
        },
        _p: Player,
        sprite: Default::default(),
    });

    // you can use a tuple if you need additional components or bundles
    // (tuples of component and bundle types are considered bundles)
    // (note the extra parentheses)
    let my_entity_id = commands.spawn((
        // add some components
        ComponentA,
        ComponentB::default(),
        // add some bundles
        MyBundle::default(),
        TransformBundle::default(),
    )).id(); // get the Entity (id) by calling `.id()` at the end

    // add/remove components of an existing entity
    commands.entity(my_entity_id)
        .insert(ComponentC::default())
        .remove::&lt;ComponentA&gt;()
        .remove::&lt;(ComponentB, MyBundle)&gt;();
}

fn make_all_players_hostile(
    mut commands: Commands,
    // we need the Entity id, to perform commands on specific entities
    query: Query&lt;Entity, With&lt;Player&gt;&gt;,
) {
    for entity in query.iter() {
        commands.entity(entity)
            // add an `Enemy` component to the entity
            .insert(Enemy)
            // remove the `Friendly` component
            .remove::&lt;Friendly&gt;();
    }
}

fn despawn_all_enemies(
    mut commands: Commands,
    query: Query&lt;Entity, With&lt;Enemy&gt;&gt;,
) {
    for entity in query.iter() {
        commands.entity(entity).despawn();
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-11">0.11</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="events-1"><a class="header" href="#events-1">Events</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.11.0/examples/ecs/event.rs"><code>event</code></a>.</p>
<hr />
<p>Send data between systems! Let your <a href="programming//programming/systems.html">systems</a> communicate with each other!</p>
<p>Like <a href="programming//programming/res.html">resources</a> or <a href="programming//programming/ec.html#components">components</a>, events are
simple Rust <code>struct</code>s or <code>enum</code>s. When creating a new event type, derive
the <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/event/trait.Event.html"><code>Event</code></a> trait.</p>
<p>Then, any <a href="programming//programming/systems.html">system</a> can send (broadcast) values of that type,
and any system can receive those events.</p>
<ul>
<li>To send events, use an <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/event/struct.EventWriter.html"><code>EventWriter&lt;T&gt;</code></a>.</li>
<li>To receive events, use an <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/event/struct.EventReader.html"><code>EventReader&lt;T&gt;</code></a>.</li>
</ul>
<p>Every reader tracks the events it has read independently, so you can handle
the same events from multiple <a href="programming//programming/systems.html">systems</a>.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Event)]
struct LevelUpEvent(Entity);

fn player_level_up(
    mut ev_levelup: EventWriter&lt;LevelUpEvent&gt;,
    query: Query&lt;(Entity, &amp;PlayerXp)&gt;,
) {
    for (entity, xp) in query.iter() {
        if xp.0 &gt; 1000 {
            ev_levelup.send(LevelUpEvent(entity));
        }
    }
}

fn debug_levelups(
    mut ev_levelup: EventReader&lt;LevelUpEvent&gt;,
) {
    for ev in ev_levelup.iter() {
        eprintln!(&quot;Entity {:?} leveled up!&quot;, ev.0);
    }
}</code></pre>
<p>You need to register your custom event types via the <a href="programming//programming/app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">app.add_event::&lt;LevelUpEvent&gt;();</code></pre>
<h2 id="usage-advice-1"><a class="header" href="#usage-advice-1">Usage Advice</a></h2>
<p>Events should be your go-to data flow tool. As events can be sent from any
<a href="programming//programming/systems.html">system</a> and received by multiple systems, they are <em>extremely</em>
versatile.</p>
<p>Events can be a very useful layer of abstraction. They allow you to decouple
things, so you can separate different functionality and more easily reason
about which <a href="programming//programming/systems.html">system</a> is responsible for what.</p>
<p>You can imagine how, even in the simple &quot;player level up&quot; example shown above,
using events would allow us to easily extend our hypothetical game with more
functionality. If we wanted to display a fancy level-up effect or animation,
update UI, or anything else, we can just add more systems that read the events
and do their respective things. If the <code>player_level_up</code> system had simply
checked the player XP and managed the player level directly, without going via
events, it would be unwieldy for future development of the game.</p>
<h2 id="how-it-all-works"><a class="header" href="#how-it-all-works">How it all works</a></h2>
<p>When you register an event type, Bevy will create an <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/event/struct.Events.html"><code>Events&lt;T&gt;</code></a>
<a href="programming//programming/res.html">resource</a>, which acts as the backing storage for the event queue. Bevy
also adds an &quot;event maintenance&quot; <a href="programming//programming/systems.html">system</a> to clear events every
frame, preventing them from accumulating and using up memory.</p>
<p>The events storage is double-buffered, meaning that events stay for one extra
frame after the frame when they were sent. This gives your systems a chance to
read the events on the next frame, if they did not get a chance during the
current frame.</p>
<p>If you don't like this, <a href="programming//patterns/manual-event-clear.html">you can have manual control over when events are
cleared</a> (at the risk of leaking / wasting memory if you
forget to clear them).</p>
<p>The <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/event/struct.EventWriter.html"><code>EventWriter&lt;T&gt;</code></a> system parameter is just syntax sugar
for mutably accessing the <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/event/struct.Events.html"><code>Events&lt;T&gt;</code></a> <a href="programming//programming/res.html">resource</a> to
add events to the queue. The <a href="https://docs.rs/bevy/0.11.0/bevy/ecs/event/struct.EventReader.html"><code>EventReader&lt;T&gt;</code></a> is a little
more complex: it accesses the events storage immutably, but also stores an
integer counter to keep track of how many events you have read. This is why it
also needs the <code>mut</code> keyword.</p>
<h2 id="possible-pitfalls"><a class="header" href="#possible-pitfalls">Possible Pitfalls</a></h2>
<p>Beware of frame delay / 1-frame-lag. This can occur if Bevy runs the receiving
system before the sending system. The receiving system will only get a chance
to receive the events on the next frame update. If you need to ensure that
events are handled immediately / during the same frame, you can use <a href="programming//programming/system-order.html">explicit
system ordering</a>.</p>
<p>Beware of lost events if you do not read events every frame, or at least once
every other frame update. A common situation where this can occur is when
using a <a href="programming//fundamentals/fixed-timestep.html">fixed timestep</a> or <a href="programming//programming/run-criteria.html">run conditions</a>.</p>
<p>If you want events to persist for longer than two frames, you can <a href="programming//patterns/manual-event-clear.html">implement a
custom cleanup/management strategy</a>. However, you can only do
this for your own event types. There is no solution for Bevy's
<a href="programming//builtins.html#events">built-in</a> types.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="local-resources"><a class="header" href="#local-resources">Local Resources</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/ecs/ecs_guide.rs"><code>ecs_guide</code></a>.</p>
<hr />
<p>Local resources allow you to have per-<a href="programming//programming/systems.html">system</a> data. This data
is not stored in the ECS World, but rather together with your system.</p>
<p><a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a> is a system parameter similar to
<a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a>, which gives you full mutable access to an
instance of some data type, that is independent from entities and components.</p>
<p><a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.Res.html"><code>Res&lt;T&gt;</code></a>/<a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a> refer to a single global
instance of the type, shared between all systems. On the other hand, every
<a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a> parameter is a separate instance, exclusively for
that system.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Default)]
struct MyState;

fn my_system1(mut local: Local&lt;MyState&gt;) {
    // you can do anything you want with the local here
}

fn my_system2(mut local: Local&lt;MyState&gt;) {
    // the local in this system is a different instance
}</code></pre>
<p>The type must implement <a href="https://doc.rust-lang.org/stable/std/default/trait.Default.html"><code>Default</code></a> or
<a href="https://docs.rs/bevy/0.9.1/bevy/ecs/world/trait.FromWorld.html"><code>FromWorld</code></a>. It is automatically initialized.</p>
<p>A system can have multiple <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.Local.html"><code>Local</code></a>s of the same type.</p>
<h2 id="specify-an-initial-value"><a class="header" href="#specify-an-initial-value">Specify an initial value</a></h2>
<p><a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a> is always automatically initialized using the
default value for the type.</p>
<p>If you need specific data, you can use a closure instead. Rust closures
that take system parameters are valid Bevy systems, just like standalone
functions. Using a closure allows you to &quot;move data into the function&quot;.</p>
<p>This example shows how to initialize some data to configure a system,
without using <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.Local.html"><code>Local&lt;T&gt;</code></a>:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Default)]
struct MyConfig {
    magic: usize,
}

fn my_system(
    mut cmd: Commands,
    my_res: Res&lt;MyStuff&gt;,
    // note this isn't a valid system parameter
    config: &amp;MyConfig,
) {
    // TODO: do stuff
}

fn main() {
    let config = MyConfig {
        magic: 420,
    };

    App::new()
        .add_plugins(DefaultPlugins)
        // create a &quot;move closure&quot;, so we can use the `config`
        // variable that we created above
        .add_system(move |cmd: Commands, res: Res&lt;MyStuff&gt;| {
            // call our function from inside the closure
            my_system(cmd, res, &amp;config);
        })
        .run();
}</code></pre>
<p>Another way to accomplish the same thing is to &quot;return&quot; the system
from &quot;constructor&quot; helper, that creates it:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Default)]
struct MyConfig {
    magic: usize,
}

fn main() {
    // create a &quot;constructor&quot; closure, which can initialize
    // our data and move it into a closure that bevy can run as a system
    let constructor = || {
        // create the `MyConfig`
        let config = MyConfig {
            magic: 420,
        };

        // this is the actual system that bevy will run
        move |mut commands: Commands, res: Res&lt;MyStuff&gt;| {
            // we can use `config` here, the value from above will be &quot;moved in&quot;
            // we can also use our system params: `commands`, `res`
        }
    };

    App::new()
        .add_plugins(DefaultPlugins)
        // note the parentheses `()`
        // we are calling the &quot;constructor&quot; we made above,
        // which will return the actual system that gets added to bevy
        .add_system(constructor())
        .run();
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="exclusive-systems-1"><a class="header" href="#exclusive-systems-1">Exclusive Systems</a></h1>
<p>Exclusive systems are <a href="programming//programming/systems.html">systems</a> that Bevy will not run in parallel
with any other system. They can have <a href="programming//programming/world.html">full unrestricted access</a>
to the whole ECS <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/world/struct.World.html"><code>World</code></a>, by taking a <code>&amp;mut World</code> parameter.</p>
<p>Inside of an exclusive system, you have full control over all data stored
in the ECS. You can do whatever you want.</p>
<p>Note that exclusive systems can limit performance, as they prevent
multi-threading (nothing else runs at the same time).</p>
<p>Some example situations where exclusive systems are useful:</p>
<ul>
<li>Dump various entities and components to a file, to implement things like
saving and loading of game save files, or scene export from an editor</li>
<li>Directly spawn/despawn <a href="programming//programming/intro-data.html#entities--components">entities</a>, or create/remove <a href="programming//programming/res.html">resources</a>,
immediately with no delay (unlike when using <a href="programming//programming/commands.html"><code>Commands</code></a>
from a regular system)</li>
<li>Run arbitrary systems with your own scheduling algorithm</li>
<li>‚Ä¶</li>
</ul>
<p>See the <a href="programming//programming/world.html">direct World access page</a> to learn more about how to do
such things.</p>
<pre><code class="language-rust no_run noplayground">fn do_crazy_things(world: &amp;mut World) {
    // we can do anything with any data in the Bevy ECS here!
}</code></pre>
<p>You need to add exclusive systems to the <a href="programming//programming/app-builder.html">App</a>, just like
regular systems, but you must call <code>.exclusive_system()</code> on them.</p>
<p>They cannot be ordered in-between regular parallel systems. Exclusive systems
always run at one of the following places:</p>
<ul>
<li><code>.at_start()</code>: at the beginning of a <a href="programming//programming/schedules.html">stage</a></li>
<li><code>.at_end()</code>: at the end of a <a href="programming//programming/schedules.html">stage</a>,
after <a href="programming//programming/commands.html">commands</a> from regular systems have been applied</li>
<li><code>.before_commands()</code>: after all the regular systems in a <a href="programming//programming/schedules.html">stage</a>,
but before <a href="programming//programming/commands.html">commands</a> are applied</li>
</ul>
<p>(if you don't specify anything, the default is assumed <code>.at_start()</code>)</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // this will run at the start of CoreStage::Update (the default stage)
        .add_system(do_crazy_things)

        // this will run at the end of CoreStage::PostUpdate
        .add_system_to_stage(
            CoreStage::PostUpdate,
            some_more_things
                .at_end()
        )

        .run();
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="direct-world-access"><a class="header" href="#direct-world-access">Direct World Access</a></h1>
<p>The <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/world/struct.World.html"><code>World</code></a> is where Bevy ECS stores all data and
associated metadata. It keeps track of <a href="programming//programming/res.html">resources</a>, <a href="programming//programming/intro-data.html#entities--components">entities and
components</a>.</p>
<p>Typically, the <a href="https://docs.rs/bevy/0.9.1/bevy/app/struct.App.html"><code>App</code></a>'s schedule runner will run all
<a href="programming//programming/schedules.html">stages</a> (which, in turn, run their <a href="programming//programming/systems.html">systems</a>)
on the main world. Regular <a href="programming//programming/systems.html">systems</a> are limited in
what data they can access from the world, by their <a href="programming//builtins.html#systemparams">system parameter
types</a>. Operations that manipulate the world itself
are only done indirectly using <a href="programming//programming/commands.html"><code>Commands</code></a>. This is how most
typical Bevy user code behaves.</p>
<p>However, there are also ways you can get full direct access to the world,
which gives you full control and freedom to do anything with any data stored
in the Bevy ECS:</p>
<ul>
<li><a href="programming//programming/exclusive.html">Exclusive systems</a></li>
<li><a href="https://docs.rs/bevy/0.9.1/bevy/ecs/world/trait.FromWorld.html"><code>FromWorld</code></a> impls</li>
<li>Via the <a href="https://docs.rs/bevy/0.9.1/bevy/app/struct.App.html"><code>App</code></a> <a href="programming//programming/app-builder.html">builder</a></li>
<li>Manually created <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/world/struct.World.html"><code>World</code></a>s for purposes like <a href="programming//patterns/system-tests.html">tests</a> or scenes</li>
<li>Custom Commands</li>
<li>Custom <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/schedule/trait.Stage.html"><code>Stage</code></a> impls (not recommended, prefer exclusive systems)</li>
</ul>
<p>Direct world access lets you do things like:</p>
<ul>
<li>Freely spawn/despawn entities, insert/remove resources, etc., taking effect immediately
(no delay like when using <a href="programming//programming/commands.html"><code>Commands</code></a> from a regular <a href="programming//programming/systems.html">system</a>)</li>
<li>Access any component, entities, and resources you want</li>
<li>Manually run arbitrary systems or stages</li>
</ul>
<p>This is especially useful if you want to do things that do not fit within
Bevy's typical execution model/flow of just running systems once every frame
(organized with <a href="programming//programming/schedules.html">stages</a> and <a href="programming//programming/system-order.html#labels">labels</a>).</p>
<p>With direct world access, you can implement custom control flow, like
looping some systems multiple times, selecting different systems to run in
different circumstances, exporting/importing data from files like scenes or
game saves, ‚Ä¶</p>
<h2 id="working-with-the-world"><a class="header" href="#working-with-the-world">Working with the <code>World</code></a></h2>
<p>Here are some ways that you can make use of the direct world access APIs.</p>
<h3 id="systemstate"><a class="header" href="#systemstate"><code>SystemState</code></a></h3>
<p>The easiest way to do things is using a <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.SystemState.html"><code>SystemState</code></a>.</p>
<p>This is a type that &quot;imitates a system&quot;, behaving the same way as a
<a href="programming//programming/systems.html">system</a> with various parameters would. All the same behaviors
like <a href="programming//programming/queries.html">queries</a>, <a href="programming//programming/change-detection.html">change detection</a>, and
even <a href="programming//programming/commands.html"><code>Commands</code></a> are available. You can use any <a href="programming//builtins.html#systemparams">system
params</a>.</p>
<p>It also tracks any persistent state, used for things like <a href="programming//programming/change-detection.html">change
detection</a> or caching to improve performance. Therefore,
if you plan on reusing the same <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.SystemState.html"><code>SystemState</code></a> multiple
times, you should store it somewhere, rather than creating a new one every
time. Every time you call <code>.get(world)</code>, it behaves like another &quot;run&quot;
of a system.</p>
<p>If you are using <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>, you can choose when you
want to apply them to the world. You need to manually call <code>.apply(world)</code>
on the <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.SystemState.html"><code>SystemState</code></a>, to apply them.</p>
<pre><code class="language-rust no_run noplayground">// TODO: write code example</code></pre>
<h3 id="running-a-stage"><a class="header" href="#running-a-stage">Running a Stage</a></h3>
<p>If you want to run some systems (a common use-case is
<a href="programming//patterns/system-tests.html">testing</a>), the easiest way is to construct an impromptu
<a href="https://docs.rs/bevy/0.9.1/bevy/ecs/schedule/struct.SystemStage.html"><code>SystemStage</code></a> (<a href="programming//programming/schedules.html">stages</a>). This way you reuse
all the scheduling logic that Bevy normally does when running systems.</p>
<pre><code class="language-rust no_run noplayground">// TODO: write code example</code></pre>
<h3 id="navigating-by-metadata"><a class="header" href="#navigating-by-metadata">Navigating by Metadata</a></h3>
<p>The world contains a lot of metadata that allows navigating all the data
efficiently, such as information about all the stored components, entities,
archeypes.</p>
<pre><code class="language-rust no_run noplayground">// TODO: write code example</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="stages"><a class="header" href="#stages">Stages</a></h1>
<p>All <a href="programming//programming/systems.html">systems</a> to be run by Bevy are contained in stages. Every
frame update, Bevy executes each stage, in order. Within each stage, Bevy's
scheduling algorithm can run many systems in parallel, using multiple CPU
cores for good performance.</p>
<p>The boundaries between stages are effectively hard synchronization points.
They ensure that all systems of the previous stage have completed before any
systems of the next stage begin, and that there is a moment in time when no
systems are in-progress.</p>
<p>This makes it possible/safe to apply <a href="programming//programming/commands.html">Commands</a>. Any operations
performed by systems using <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a> are applied at the
end of that stage.</p>
<p>By default, when you add your systems, they are added to
<a href="https://docs.rs/bevy/0.9.1/bevy/app/enum.CoreStage.html"><code>CoreStage::Update</code></a>. Startup systems are added to
<a href="https://docs.rs/bevy/0.9.1/bevy/app/enum.StartupStage.html"><code>StartupStage::Startup</code></a>.</p>
<p>Bevy's internal systems are in the other stages, to ensure they are ordered
correctly relative to your game logic.</p>
<p>If you want to add your own systems to any of Bevy's internal stages, you
need to beware of potential unexpected interactions with Bevy's own internal
systems. Remember: Bevy's internals are implemented using ordinary systems
and ECS, just like your own stuff!</p>
<p>You can add your own additional stages. For example, if we want our debug
systems to run after our game logic:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    // label for our debug stage
    static DEBUG: &amp;str = &quot;debug&quot;;

    App::new()
        .add_plugins(DefaultPlugins)

        // add DEBUG stage after Bevy's Update
        // also make it single-threaded
        .add_stage_after(CoreStage::Update, DEBUG, SystemStage::single_threaded())

        // systems are added to the `CoreStage::Update` stage by default
        .add_system(player_gather_xp)
        .add_system(player_take_damage)

        // add our debug systems
        .add_system_to_stage(DEBUG, debug_player_hp)
        .add_system_to_stage(DEBUG, debug_stats_change)
        .add_system_to_stage(DEBUG, debug_new_hostiles)

        .run();
}</code></pre>
<p>If you need to manage when your systems run, relative to one another, it
is generally preferable to avoid using stages, and to use <a href="programming//programming/system-order.html">explicit system
ordering</a> instead. Stages limit parallel execution and
the performance of your game.</p>
<p>However, stages can make it easier to organize things, when you really want
to be sure that all previous systems have completed. Stages are also the
only way to apply <a href="programming//programming/commands.html">Commands</a>.</p>
<p>If you have systems that need to rely on the actions that other systems have
performed by using <a href="programming//programming/commands.html">Commands</a>, and need to do so during the
same frame, placing those systems into separate stages is the only way to
accomplish that.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="system-order-of-execution"><a class="header" href="#system-order-of-execution">System Order of Execution</a></h1>
<p>Bevy's scheduling algorithm is designed to deliver maximum performance
by running as many systems as possible in parallel across the available
CPU threads.</p>
<p>This is possible when the systems do not conflict over the data they need
to access. However, when a system needs to have mutable (exclusive) access
to a piece of data, other systems that need to access the same data cannot
be run at the same time. Bevy determines all of this information from the
system's function signature (the types of the parameters it takes).</p>
<p>In such situations, the order is <em>nondeterministic</em> by default. Bevy takes
no regard for when each system will run, and the order could even change
every frame!</p>
<h2 id="does-it-even-matter"><a class="header" href="#does-it-even-matter">Does it even matter?</a></h2>
<p>In many cases, you don't need to worry about this.</p>
<p>However, sometimes you need to rely on specific systems to run in a particular
order. For example:</p>
<ul>
<li>Maybe the logic you wrote in one of your systems needs any modifications
done to that data by another system to always happen first?</li>
<li>One system needs to receive <a href="programming//programming/events.html">events</a> sent by another system.</li>
<li>You are using <a href="programming//programming/change-detection.html">change detection</a>.</li>
</ul>
<p>In such situations, systems running in the wrong order typically causes
their behavior to be delayed until the next frame. In rare cases, depending
on your game logic, it may even result in more serious logic bugs!</p>
<p>It is up to you to decide if this is important.</p>
<p>With many things in typical games, such as juicy visual effects, it probably
doesn't matter if they get delayed by a frame. It might not be worthwhile
to bother with it. If you don't care, leaving the order ambiguous may also
result in better performance.</p>
<p>On the other hand, for things like handling the player input controls,
this would result in annoying lag, so you should probably fix it.</p>
<h2 id="explicit-system-ordering"><a class="header" href="#explicit-system-ordering">Explicit System Ordering</a></h2>
<p>If a specific system must always run before or after some other systems,
you can add ordering constraints:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // order doesn't matter for these systems:
        .add_system(particle_effects)
        .add_system(npc_behaviors)
        .add_system(enemy_movement)

        .add_system(input_handling)

        .add_system(
            player_movement
                // `player_movement` must always run before `enemy_movement`
                .before(enemy_movement)
                // `player_movement` must always run after `input_handling`
                .after(input_handling)
        )
        .run();
}</code></pre>
<p><code>.before</code>/<code>.after</code> may be used as many times as you need on one system.</p>
<h2 id="labels"><a class="header" href="#labels">Labels</a></h2>
<p>For more advanced use cases, you can use <a href="programming//programming/labels.html">labels</a>. Labels can
either be strings, or custom types (like <code>enum</code>s) that derive <code>SystemLabel</code>.</p>
<p>This allows you to affect multiple systems at once, with the same constraints. 
You can place multiple labels on one system. You can also use the same label
on multiple systems.</p>
<p>Each label is a reference point that other systems can be ordered around.</p>
<pre><code class="language-rust no_run noplayground">
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[derive(SystemLabel)]
enum MyLabel {
    /// everything that handles input
    Input,
    /// everything that updates player state
    Player,
    /// everything that moves things (works with transforms)
    Movement,
    /// systems that update the world map
    Map,
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // use labels, because we want to have multiple affected systems
        .add_system(input_joystick.label(MyLabel::Input))
        .add_system(input_keyboard.label(MyLabel::Input))
        .add_system(input_touch.label(MyLabel::Input))

        .add_system(input_parameters.before(MyLabel::Input))

        .add_system(
            player_movement
                .before(MyLabel::Map)
                .after(MyLabel::Input)
                // we can have multiple labels on this system
                .label(MyLabel::Player)
                .label(MyLabel::Movement)
                // can also use loose strings as labels
                .label(&quot;player_movement&quot;)
        )

        // ‚Ä¶ and so on ‚Ä¶

        .run();
}</code></pre>
<p>When you have multiple systems with common labels or ordering, it may be
convenient to use <a href="programming//programming/system-sets.html">system sets</a>.</p>
<h2 id="circular-dependencies"><a class="header" href="#circular-dependencies">Circular Dependencies</a></h2>
<p>If you have multiple systems mutually depending on each other, then it is
clearly impossible to resolve the situation completely like that.</p>
<p>You should try to redesign your game to avoid such situations, or just accept
the consequences. You can at least make it behave predictably, using explicit
ordering to specify the order you prefer.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="run-criteria"><a class="header" href="#run-criteria">Run Criteria</a></h1>
<p>Run Criteria are a mechanism for controlling if Bevy should run specific
<a href="programming//programming/systems.html">systems</a>, at runtime. This is how you can make functionality
that only runs under certain conditions.</p>
<p>Run Criteria can be applied to individual <a href="programming//programming/systems.html">systems</a>, <a href="programming//programming/system-sets.html">system
sets</a>, and <a href="programming//programming/schedules.html">stages</a>.</p>
<p>Run Criteria are Bevy systems that return a value of type <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/schedule/enum.ShouldRun.html"><code>enum ShouldRun</code></a>. They can accept any <a href="programming//builtins.html#systemparams">system
parameters</a>, like a normal system.</p>
<p>This example shows how run criteria might be used to implement different
multiplayer modes:</p>
<pre><code class="language-rust no_run noplayground">use bevy::ecs::schedule::ShouldRun;

#[derive(Debug, PartialEq, Eq)]
#[derive(Resource)]
enum MultiplayerKind {
    Client,
    Host,
    Local,
}

fn run_if_connected(
    mode: Res&lt;MultiplayerKind&gt;,
    session: Res&lt;MyNetworkSession&gt;,
) -&gt; ShouldRun
{
    if *mode == MultiplayerKind::Client &amp;&amp; session.is_connected() {
        ShouldRun::Yes
    } else {
        ShouldRun::No
    }
}

fn run_if_host(
    mode: Res&lt;MultiplayerKind&gt;,
) -&gt; ShouldRun
{
    if *mode == MultiplayerKind::Host || *mode == MultiplayerKind::Local {
        ShouldRun::Yes
    } else {
        ShouldRun::No
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // if we are currently connected to a server,
        // activate our client systems
        .add_system_set(
            SystemSet::new()
                .with_run_criteria(run_if_connected)
                .before(&quot;input&quot;)
                .with_system(server_session)
                .with_system(fetch_server_updates)
        )

        // if we are hosting the game,
        // activate our game hosting systems
        .add_system_set(
            SystemSet::new()
                .with_run_criteria(run_if_host)
                .before(&quot;input&quot;)
                .with_system(host_session)
                .with_system(host_player_movement)
                .with_system(host_enemy_ai)
        )

        // other systems in our game
        .add_system(smoke_particles)
        .add_system(water_animation)
        .add_system_set(
            SystemSet::new()
                .label(&quot;input&quot;)
                .with_system(keyboard_input)
                .with_system(gamepad_input)
        )
        .run();
}</code></pre>
<h2 id="known-pitfalls-1"><a class="header" href="#known-pitfalls-1">Known Pitfalls</a></h2>
<h3 id="combining-multiple-run-criteria"><a class="header" href="#combining-multiple-run-criteria">Combining Multiple Run Criteria</a></h3>
<p>It is not possible to make a system that is conditional on multiple run
criteria. Bevy has a <code>.pipe</code> method that allows you to &quot;chain&quot; run criteria,
which could let you modify the output of a run criteria, but this is very
limiting in practice.</p>
<p>Consider using <a href="https://github.com/IyesGames/iyes_loopless"><code>iyes_loopless</code></a>. It allows you to
use any number of run conditions to control your systems, and does not prevent
you from using <a href="programming//programming/states.html">states</a> or <a href="programming//fundamentals/fixed-timestep.html">fixed timestep</a>.</p>
<h3 id="events-2"><a class="header" href="#events-2">Events</a></h3>
<p>When receiving <a href="programming//programming/events.html">events</a> in systems that don't run every frame,
you will miss any events that are sent during the frames when the receiving
systems are not running!</p>
<p>To mitigate this, you could implement a <a href="programming//patterns/manual-event-clear.html">custom cleanup
strategy</a>, to manually manage the lifetime of the relevant
event types.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="system-sets"><a class="header" href="#system-sets">System Sets</a></h1>
<p>System Sets allow you to easily apply common properties to multiple systems,
for purposes such as <a href="programming//programming/labels.html">labeling</a>, <a href="programming//programming/system-order.html">ordering</a>,
<a href="programming//programming/run-criteria.html">run criteria</a>, and <a href="programming//programming/states.html">states</a>.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // group our input handling systems into a set
        .add_system_set(
            SystemSet::new()
                .label(&quot;input&quot;)
                .with_system(keyboard_input)
                .with_system(gamepad_input)
        )

        // our &quot;net&quot; systems should run before &quot;input&quot;
        .add_system_set(
            SystemSet::new()
                .label(&quot;net&quot;)
                .before(&quot;input&quot;)
                // individual systems can still have
                // their own labels (and ordering)
                .with_system(server_session.label(&quot;session&quot;))
                .with_system(server_updates.after(&quot;session&quot;))
        )

        // some ungrouped systems
        .add_system(player_movement.after(&quot;input&quot;))
        .add_system(session_ui.after(&quot;session&quot;))
        .add_system(smoke_particles)

        .run();
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="states"><a class="header" href="#states">States</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/ecs/state.rs"><code>state</code></a>.</p>
<hr />
<p>States allow you to structure the runtime &quot;flow&quot; of your app.</p>
<p>This is how you can implement things like:</p>
<ul>
<li>A menu screen or a loading screen</li>
<li>Pausing / unpausing the game</li>
<li>Different game modes</li>
<li>‚Ä¶</li>
</ul>
<p>In every state, you can have different <a href="programming//programming/systems.html">systems</a> running. You
can also add one-shot setup and cleanup systems to run when entering or
exiting a state.</p>
<p>To use states, define an enum type and add <a href="programming//programming/system-sets.html">system sets</a>
to your <a href="programming//programming/app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Clone, Eq, PartialEq, Hash)]
enum AppState {
    MainMenu,
    InGame,
    Paused,
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // add the app state type
        .add_state(AppState::MainMenu)

        // add systems to run regardless of state, as usual
        .add_system(play_music)

        // systems to run only in the main menu
        .add_system_set(
            SystemSet::on_update(AppState::MainMenu)
                .with_system(handle_ui_buttons)
        )

        // setup when entering the state
        .add_system_set(
            SystemSet::on_enter(AppState::MainMenu)
                .with_system(setup_menu)
        )

        // cleanup when exiting the state
        .add_system_set(
            SystemSet::on_exit(AppState::MainMenu)
                .with_system(close_menu)
        )
        .run();
}</code></pre>
<p>It is OK to have multiple system sets for the same state.</p>
<p>This is useful when you want to place <a href="programming//programming/labels.html">labels</a> and use <a href="programming//programming/system-order.html">explicit
system ordering</a>.</p>
<p>This can also be useful with <a href="programming//programming/plugins.html">Plugins</a>. Each plugin can add
its own set of systems to the same state.</p>
<p>States are implemented using <a href="programming//programming/run-criteria.html">run criteria</a> under the hood.
These special system set constructors are really just helpers to automatically
add the state management run criteria.</p>
<h2 id="controlling-states"><a class="header" href="#controlling-states">Controlling States</a></h2>
<p>Inside of systems, you can check and control the state using the
<a href="https://docs.rs/bevy/0.9.1/bevy/ecs/schedule/struct.State.html"><code>State&lt;T&gt;</code></a> resource:</p>
<pre><code class="language-rust no_run noplayground">fn play_music(
    app_state: Res&lt;State&lt;AppState&gt;&gt;,
    // ...
) {
    match app_state.current() {
        AppState::MainMenu =&gt; {
            // TODO: play menu music
        }
        AppState::InGame =&gt; {
            // TODO: play game music
        }
        AppState::Paused =&gt; {
            // TODO: play pause screen music
        }
    }
}</code></pre>
<p>To change to another state:</p>
<pre><code class="language-rust no_run noplayground">fn enter_game(mut app_state: ResMut&lt;State&lt;AppState&gt;&gt;) {
    app_state.set(AppState::InGame).unwrap();
    // ^ this can fail if we are already in the target state
    // or if another state change is already queued
}</code></pre>
<p>After the systems of the current state complete, Bevy will transition to
the next state you set.</p>
<p>You can do arbitrarily many state transitions in a single frame update. Bevy
will handle all of them and execute all the relevant systems (before moving
on to the next <a href="programming//programming/schedules.html">stage</a>).</p>
<h2 id="state-stack"><a class="header" href="#state-stack">State Stack</a></h2>
<p>Instead of completely transitioning from one state to another, you can also
overlay states, forming a stack.</p>
<p>This is how you can implement things like a &quot;game paused&quot; screen, or an
overlay menu, with the game world still visible / running in the background.</p>
<p>You can have some systems that are still running even when the state is
&quot;inactive&quot; (that is, in the background, with other states running on top). You
can also add one-shot systems to run when &quot;pausing&quot; or &quot;resuming&quot; the state.</p>
<p>In your <a href="programming//programming/app-builder.html">app builder</a>:</p>
<pre><code class="language-rust no_run noplayground">        // player movement only when actively playing
        .add_system_set(
            SystemSet::on_update(AppState::InGame)
                .with_system(player_movement)
        )
        // player idle animation while paused
        .add_system_set(
            SystemSet::on_inactive_update(AppState::InGame)
                .with_system(player_idle)
        )
        // animations both while paused and while active
        .add_system_set(
            SystemSet::on_in_stack_update(AppState::InGame)
                .with_system(animate_trees)
                .with_system(animate_water)
        )
        // things to do when becoming inactive
        .add_system_set(
            SystemSet::on_pause(AppState::InGame)
                .with_system(hide_enemies)
        )
        // things to do when becoming active again
        .add_system_set(
            SystemSet::on_resume(AppState::InGame)
                .with_system(reset_player)
        )
        // setup when first entering the game
        .add_system_set(
            SystemSet::on_enter(AppState::InGame)
                .with_system(setup_player)
                .with_system(setup_map)
        )
        // cleanup when finally exiting the game
        .add_system_set(
            SystemSet::on_exit(AppState::InGame)
                .with_system(despawn_player)
                .with_system(despawn_map)
        )</code></pre>
<p>To manage states like this, use <code>push</code>/<code>pop</code>:</p>
<pre><code class="language-rust no_run noplayground">    // to go into the pause screen
    app_state.push(AppState::Paused).unwrap();
    // to go back into the game
    app_state.pop().unwrap();</code></pre>
<p>(using <code>.set</code> as shown before replaces the active state at the top of the stack)</p>
<h2 id="known-pitfalls-and-limitations"><a class="header" href="#known-pitfalls-and-limitations">Known Pitfalls and Limitations</a></h2>
<h3 id="combining-with-other-run-criteria"><a class="header" href="#combining-with-other-run-criteria">Combining with Other Run Criteria</a></h3>
<p>Because states are implemented using <a href="programming//programming/run-criteria.html">run criteria</a>,
they cannot be combined with other uses of run criteria, such as <a href="programming//fundamentals/fixed-timestep.html">fixed
timestep</a>.</p>
<p>If you try to add another run criteria to your system set, it would replace
Bevy's state-management run criteria! This would make the system set no
longer constrained to run as part of a state!</p>
<p>Consider using <a href="https://github.com/IyesGames/iyes_loopless"><code>iyes_loopless</code></a>, which does not
have such limitations.</p>
<h3 id="multiple-stages"><a class="header" href="#multiple-stages">Multiple Stages</a></h3>
<p>Bevy states cannot work across multiple <a href="programming//programming/schedules.html">stages</a>. Workarounds
are available, but they are broken and buggy.</p>
<p>This is a huge limitation in practice, as it greatly limits how you can use
<a href="programming//programming/commands.html">commands</a>. Not being able to use Commands is a big deal,
as you cannot do things like spawn entities and operate on them during the
same frame, among other important use cases.</p>
<p>Consider using <a href="https://github.com/IyesGames/iyes_loopless"><code>iyes_loopless</code></a>, which does not
have such limitations.</p>
<h3 id="with-input"><a class="header" href="#with-input">With Input</a></h3>
<p>If you want to use <a href="https://docs.rs/bevy/0.9.1/bevy/input/struct.Input.html"><code>Input&lt;T&gt;</code></a> to trigger state transitions using
a button/key press, you need to clear the input manually by calling <code>.reset</code>:</p>
<pre><code class="language-rust no_run noplayground">fn esc_to_menu(
    mut keys: ResMut&lt;Input&lt;KeyCode&gt;&gt;,
    mut app_state: ResMut&lt;State&lt;AppState&gt;&gt;,
) {
    if keys.just_pressed(KeyCode::Escape) {
        app_state.set(AppState::MainMenu).unwrap();
        keys.reset(KeyCode::Escape);
    }
}</code></pre>
<p>(note that this requires <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.ResMut.html"><code>ResMut</code></a>)</p>
<p>Not doing this can cause <a href="https://github.com/bevyengine/bevy/issues/1700">issues</a>.</p>
<p><a href="https://github.com/IyesGames/iyes_loopless"><code>iyes_loopless</code></a> does not have this issue.</p>
<h3 id="events-3"><a class="header" href="#events-3">Events</a></h3>
<p>When receiving <a href="programming//programming/events.html">events</a> in systems that don't run all the time, such
as during a pause state, you will miss any events that are sent during the frames
when the receiving systems are not running!</p>
<p>To mitigate this, you could implement a <a href="programming//patterns/manual-event-clear.html">custom cleanup
strategy</a>, to manually manage the lifetime of the relevant
event types.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="plugins-1"><a class="header" href="#plugins-1">Plugins</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/app/plugin.rs"><code>plugin</code></a>,
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/app/plugin_group.rs"><code>plugin_group</code></a>.</p>
<hr />
<p>As your project grows, it can be useful to make it more modular. You can
split it into &quot;plugins&quot;.</p>
<p>Plugins are simply collections of things to be added to the <a href="programming//programming/app-builder.html">App
Builder</a>. Think of this as a way to add things to the app from
multiple places, like different Rust files/modules or crates.</p>
<pre><code class="language-rust no_run noplayground">struct MyPlugin;

impl Plugin for MyPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        app
            .init_resource::&lt;MyOtherResource&gt;()
            .add_event::&lt;MyEvent&gt;()
            .add_startup_system(plugin_init)
            .add_system(my_system);
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugin(MyPlugin)
        .run();
}</code></pre>
<p>Note how you get <code>&amp;mut</code> access to the <a href="https://docs.rs/bevy/0.9.1/bevy/app/struct.App.html"><code>App</code></a>, so you can
add whatever you want to it, just like you can do from your <code>fn main</code>.</p>
<p>For internal organization in your own project, the main value of plugins
comes from not having to declare all your Rust types and functions as
<code>pub</code>, just so they can be accessible from <code>fn main</code> to be added to the
app builder. Plugins let you add things to your <a href="programming//programming/app-builder.html">app</a> from multiple
different places, like separate Rust files / modules.</p>
<p>You can decide how plugins fit into the architecture of your game.</p>
<p>Some suggestions:</p>
<ul>
<li>Create plugins for different <a href="programming//programming/states.html">states</a>.</li>
<li>Create plugins for various sub-systems, like physics or input handling.</li>
</ul>
<h2 id="plugin-groups"><a class="header" href="#plugin-groups">Plugin groups</a></h2>
<p>Plugin groups register multiple plugins at once.
Bevy's <a href="https://docs.rs/bevy/0.9.1/bevy/struct.DefaultPlugins.html"><code>DefaultPlugins</code></a> and
<a href="https://docs.rs/bevy/0.9.1/bevy/struct.MinimalPlugins.html"><code>MinimalPlugins</code></a> are examples of this.
To create your own plugin group:</p>
<pre><code class="language-rust no_run noplayground">struct MyPluginGroup;

impl PluginGroup for MyPluginGroup {
    fn build(self) -&gt; PluginGroupBuilder {
        PluginGroupBuilder::start::&lt;Self&gt;()
            .add(FooPlugin)
            .add(BarPlugin)
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(MyPluginGroup)
        .run();
}</code></pre>
<p>When adding a plugin group to the <a href="programming//programming/app-builder.html">app</a>, you can disable some
plugins while keeping the rest.</p>
<p>For example, if you want to manually set up logging (with your own <code>tracing</code>
subscriber), you can disable Bevy's <a href="https://docs.rs/bevy/0.9.1/bevy/log/struct.LogPlugin.html"><code>LogPlugin</code></a>:</p>
<pre><code class="language-rust no_run noplayground">App::new()
    .add_plugins(
        DefaultPlugins.build()
            .disable::&lt;LogPlugin&gt;()
    )
    .run();</code></pre>
<p>Note that this simply disables the functionality, but it cannot actually
remove the code to avoid binary bloat. The disabled plugins still have to
be compiled into your program.</p>
<p>If you want to slim down your build, you should look at disabling Bevy's
default <a href="programming//setup/bevy-config.html">cargo features</a>, or depending on the various Bevy
sub-crates individually.</p>
<h2 id="plugin-configuration"><a class="header" href="#plugin-configuration">Plugin Configuration</a></h2>
<p>Plugins are also a convenient place to store settings/configuration that are
used during initialization/startup. For settings that can be changed at runtime,
it is recommended that you put them in <a href="programming//programming/res.html">resources</a> instead.</p>
<pre><code class="language-rust no_run noplayground">
struct MyGameplayPlugin {
    /// Should we enable dev hacks?
    enable_dev_hacks: bool,
}

impl Plugin for MyGameplayPlugin {
    fn build(&amp;self, app: &amp;mut App) {
        // add our gameplay systems
        app.add_system(health_system);
        app.add_system(movement_system);
        // ...

        // if &quot;dev mode&quot; is enabled, add some hacks
        if self.enable_dev_hacks {
            app.add_system(player_invincibility);
            app.add_system(free_camera);
        }
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugin(MyGameplayPlugin {
            enable_dev_hacks: false, // change to true for dev testing builds
        })
        .run();
}</code></pre>
<p>Plugins that are added using <a href="programming//programming/plugins.html#plugin-groups">Plugin Groups</a> can also be
configured. Many of Bevy's <a href="https://docs.rs/bevy/0.9.1/bevy/struct.DefaultPlugins.html"><code>DefaultPlugins</code></a> work
this way.</p>
<pre><code class="language-rust no_run noplayground">App::new()
    .add_plugins(DefaultPlugins.set(
        // here we configure the main window
        WindowPlugin {
            window: WindowDescriptor {
                width: 800.0,
                height: 600.0,
                // ...
                ..Default::default()
            },
            ..Default::default()
        }
    ))
    .run();</code></pre>
<h2 id="publishing-crates"><a class="header" href="#publishing-crates">Publishing Crates</a></h2>
<p>Plugins give you a nice way to publish Bevy-based libraries for other people
to easily include into their projects.</p>
<p>If you intend to publish plugins as crates for public use, you should read
<a href="https://github.com/bevyengine/bevy/blob/main/docs/plugins_guidelines.md">the official guidelines for plugin authors</a>.</p>
<p>Don't forget to submit an entry to <a href="https://bevyengine.org/assets">Bevy Assets</a> on the official
website, so that people can find your plugin more easily. You can do this
by making a PR in <a href="https://github.com/bevyengine/bevy-assets">the Github repo</a>.</p>
<p>If you are interested in supporting bleeding-edge Bevy (main), <a href="programming//setup/bevy-git.html#advice-for-plugin-authors">see here
for advice</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="change-detection"><a class="header" href="#change-detection">Change Detection</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/ecs/component_change_detection.rs"><code>component_change_detection</code></a>.</p>
<hr />
<p>Bevy allows you to easily detect when data is changed. You can use this to
perform actions in response to changes.</p>
<p>One of the main use cases is optimization ‚Äì avoiding unnecessary work by
only doing it if the relevant data has changed. Another use case is triggering
special actions to occur on changes, like configuring something or sending
the data somewhere.</p>
<h2 id="components-2"><a class="header" href="#components-2">Components</a></h2>
<h3 id="filtering"><a class="header" href="#filtering">Filtering</a></h3>
<p>You can make a <a href="programming//programming/queries.html">query</a> that only yields entities if specific
<a href="programming//programming/ec.html#components">components</a> on them have been modified.</p>
<p>Use <a href="programming//programming/queries.html#query-filters">query filters</a>:</p>
<ul>
<li><a href="https://docs.rs/bevy/0.9.1/bevy/ecs/query/struct.Added.html"><code>Added&lt;T&gt;</code></a>: detect new component instances
<ul>
<li>if the component was added to an existing entity</li>
<li>if a new entity with the component was spawned</li>
</ul>
</li>
<li><a href="https://docs.rs/bevy/0.9.1/bevy/ecs/query/struct.Changed.html"><code>Changed&lt;T&gt;</code></a>: detect component instances that have been changed
<ul>
<li>triggers when the component is accessed mutably</li>
<li>also triggers if the component is newly-added (as per <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/query/struct.Added.html"><code>Added</code></a>)</li>
</ul>
</li>
</ul>
<p>(If you want to react to removals, see the page on <a href="programming//programming/change-detection.html#removal-detection">removal
detection</a>. It works differently and is much
trickier to use.)</p>
<pre><code class="language-rust no_run noplayground">/// Print the stats of friendly players when they change
fn debug_stats_change(
    query: Query&lt;
        // components
        (&amp;Health, &amp;PlayerXp),
        // filters
        (Without&lt;Enemy&gt;, Or&lt;(Changed&lt;Health&gt;, Changed&lt;PlayerXp&gt;)&gt;), 
    &gt;,
) {
    for (health, xp) in query.iter() {
        eprintln!(
            &quot;hp: {}+{}, xp: {}&quot;,
            health.hp, health.extra, xp.0
        );
    }
}

/// detect new enemies and print their health
fn debug_new_hostiles(
    query: Query&lt;(Entity, &amp;Health), Added&lt;Enemy&gt;&gt;,
) {
    for (entity, health) in query.iter() {
        eprintln!(&quot;Entity {:?} is now an enemy! HP: {}&quot;, entity, health.hp);
    }
}</code></pre>
<h3 id="checking"><a class="header" href="#checking">Checking</a></h3>
<p>If you want to access all the entities, as normal, regardless of if they have
been modified, but you just want to check the status, you can use the special
<a href="https://docs.rs/bevy/0.9.1/bevy/ecs/query/struct.ChangeTrackers.html"><code>ChangeTrackers&lt;T&gt;</code></a> query parameter.</p>
<pre><code class="language-rust no_run noplayground">/// Make sprites flash red on frames when the Health changes
fn debug_damage(
    mut query: Query&lt;(&amp;mut Sprite, ChangeTrackers&lt;Health&gt;)&gt;,
) {
    for (mut sprite, tracker) in query.iter_mut() {
        // detect if the Health changed this frame
        if tracker.is_changed() {
            sprite.color = Color::RED;
        } else {
            // extra check so we don't mutate on every frame without changes
            if sprite.color != Color::WHITE {
                sprite.color = Color::WHITE;
            }
        }
    }
}</code></pre>
<p>This is useful for processing all entities, but doing different things
depending on if they have been modified.</p>
<h2 id="resources-3"><a class="header" href="#resources-3">Resources</a></h2>
<p>For <a href="programming//programming/res.html">resources</a>, change detection is provided via methods on the
<a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.Res.html"><code>Res</code></a>/<a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.ResMut.html"><code>ResMut</code></a> system parameters.</p>
<pre><code class="language-rust no_run noplayground">fn check_res_changed(
    my_res: Res&lt;MyResource&gt;,
) {
    if my_res.is_changed() {
        // do something
    }
}

fn check_res_added(
    // use Option, not to panic if the resource doesn't exist yet
    my_res: Option&lt;Res&lt;MyResource&gt;&gt;,
) {
    if let Some(my_res) = my_res {
        // the resource exists

        if my_res.is_added() {
            // it was just added
            // do something
        }
    }
}</code></pre>
<p>Note that change detection cannot currently be used to detect
<a href="programming//programming/states.html">states</a> changes (via the <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/schedule/struct.State.html"><code>State</code></a>
<a href="programming//programming/res.html">resource</a>) (<a href="https://github.com/bevyengine/bevy/issues/2343">bug</a>).</p>
<h2 id="what-gets-detected"><a class="header" href="#what-gets-detected">What gets detected?</a></h2>
<p><a href="https://docs.rs/bevy/0.9.1/bevy/ecs/query/struct.Changed.html"><code>Changed</code></a> detection is triggered by
<a href="https://doc.rust-lang.org/stable/std/ops/trait.DerefMut.html"><code>DerefMut</code></a>. Simply accessing components via a mutable query,
without actually performing a <code>&amp;mut</code> access, will <em>not</em> trigger it.</p>
<p>This makes change detection quite accurate. You can rely on it to optimize
your game's performance, or to otherwise trigger things to happen.</p>
<p>Also note that when you mutate a component, Bevy does not track if the new
value is actually different from the old value. It will always trigger the
change detection. If you want to avoid that, simply check it yourself:</p>
<pre><code class="language-rust no_run noplayground">fn update_player_xp(
    mut query: Query&lt;&amp;mut PlayerXp&gt;,
) {
    for mut xp in query.iter_mut() {
        let new_xp = maybe_lvl_up(&amp;xp);

        // avoid triggering change detection if the value is the same
        if new_xp != *xp {
            *xp = new_xp;
        }
    }
}</code></pre>
<p>Change detection works on a per-<a href="programming//programming/systems.html">system</a> granularity, and is
reliable. A system will not detect changes that it made itself, only those
done by other systems, and only if it has not seen them before (the changes
happened since the last time it ran). If your system only runs sometimes
(such as with <a href="programming//programming/states.html">states</a> or <a href="programming//programming/run-criteria.html">run criteria</a>),
you do <em>not</em> have to worry about missing changes.</p>
<h2 id="possible-pitfalls-1"><a class="header" href="#possible-pitfalls-1">Possible Pitfalls</a></h2>
<p>Beware of frame delay / 1-frame-lag. This can occur if Bevy runs the detecting
system before the changing system. The detecting system will see the change
the next time it runs, typically on the next frame update.</p>
<p>If you need to ensure that changes are handled immediately / during the same
frame, you can use <a href="programming//programming/system-order.html">explicit system ordering</a>.</p>
<p>However, when detecting component additions with <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/query/struct.Added.html"><code>Added&lt;T&gt;</code></a>
(which are typically done using <a href="programming//programming/commands.html"><code>Commands</code></a>), this is not
enough; you need <a href="programming//programming/schedules.html">stages</a>.</p>
<h1 id="removal-detection"><a class="header" href="#removal-detection">Removal Detection</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/ecs/removal_detection.rs"><code>removal_detection</code></a>.</p>
<hr />
<p>Removal detection is special. This is because, unlike with <a href="programming//programming/change-detection.html">change
detection</a>, the data does not exist in the ECS anymore
(obviously), so Bevy cannot keep tracking metadata for it.</p>
<p>Nevertheless, being able to respond to removals is important for some
applications, so Bevy offers a limited form of it.</p>
<h2 id="components-3"><a class="header" href="#components-3">Components</a></h2>
<p>You can check for <a href="programming//programming/ec.html#components">components</a> that have been removed during
the current frame. The data is cleared at the end of every frame update. Note
that this makes this feature tricky to use, and requires you to use multiple
<a href="programming//programming/schedules.html">stages</a>.</p>
<p>When you remove a component (using <a href="programming//programming/commands.html">Commands</a>
(<a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.Commands.html"><code>Commands</code></a>)), the operation is applied at the end of the
<a href="programming//programming/schedules.html">stage</a>. The <a href="programming//programming/systems.html">system</a> that checks for the removal
must run in a later stage during the same frame update. Otherwise, it will
not detect the removal.</p>
<p>Use the <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/system/struct.RemovedComponents.html"><code>RemovedComponents&lt;T&gt;</code></a> special system
parameter type, to get an iterator for the <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/entity/struct.Entity.html"><code>Entity</code></a> IDs of
all the entities that had a component of type <code>T</code> that was removed earlier
this frame.</p>
<pre><code class="language-rust no_run noplayground">/// Some component type for the sake of this example.
#[derive(Component)]
struct Seen;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        // we could add our system to Bevy's `PreUpdate` stage
        // (alternatively, you could create your own stage)
        .add_system_to_stage(CoreStage::PreUpdate, remove_components)
        // our detection system runs in a later stage
        // (in this case: Bevy's default `Update` stage)
        .add_system(detect_removals)
        .run();
}

fn remove_components(
    mut commands: Commands,
    q: Query&lt;(Entity, &amp;Transform), With&lt;Seen&gt;&gt;,
) {
    for (e, transform) in q.iter() {
        if transform.translation.y &lt; -10.0 {
            // remove the `Seen` component from the entity
            commands.entity(e)
                .remove::&lt;Seen&gt;();
        }
    }
}

fn detect_removals(
    removals: RemovedComponents&lt;Seen&gt;,
    // ... (maybe Commands or a Query ?) ...
) {
    for entity in removals.iter() {
        // do something with the entity
    }
}</code></pre>
<p>(To do things with these entities, you can just use the <code>Entity</code> IDs with
<a href="programming//programming/commands.html"><code>Commands::entity()</code></a> or <a href="programming//programming/queries.html"><code>Query::get()</code></a>.)</p>
<h2 id="resources-4"><a class="header" href="#resources-4">Resources</a></h2>
<p>Bevy does not provide any API for detecting when <a href="programming//programming/res.html">resources</a> are removed.</p>
<p>You can work around this using <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html"><code>Option</code></a> and a separate
<a href="programming//programming/local.html"><code>Local</code></a> system parameter, effectively implementing your own
detection.</p>
<pre><code class="language-rust no_run noplayground">fn detect_removed_res(
    my_res: Option&lt;Res&lt;MyResource&gt;&gt;,
    mut my_res_existed: Local&lt;bool&gt;,
) {
    if let Some(my_res) = my_res {
        // the resource exists!

        // remember that!
        *my_res_existed = true;

        // (... you can do something with the resource here if you want ...)
    } else if *my_res_existed {
        // the resource does not exist, but we remember it existed!
        // (it was removed)

        // forget about it!
        *my_res_existed = false;

        // ... do something now that it is gone ...
    }
}</code></pre>
<p>Note that, since this detection is local to your system, it does not have
to happen during the same frame update.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="system-piping"><a class="header" href="#system-piping">System Piping</a></h1>
<p>Relevant official examples:
<a href="https://github.com/bevyengine/bevy/blob/v0.9.1/examples/ecs/system_piping.rs"><code>system_piping</code></a>.</p>
<hr />
<p>You can compose a single Bevy <a href="programming//programming/systems.html">system</a> from multiple Rust functions.</p>
<p>You can make functions that can take an input and produce an output, and be
connected together to run as a single larger system. This is called &quot;system piping&quot;.</p>
<p>You can think of it as creating &quot;modular&quot; systems made up of multiple building
blocks. This way, you can reuse some common code/logic in multiple systems.</p>
<p>Note that system piping is <em>not</em> a way of communicating between systems.
If you want to pass data between systems, you should use <a href="programming//programming/events.html">Events</a>
instead.</p>
<h2 id="example-handling-results"><a class="header" href="#example-handling-results">Example: Handling <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code>Result</code></a>s</a></h2>
<p>One useful application of system piping is to be able to return errors (allowing
the use of Rust's <code>?</code> operator) and then have a separate function for handling
them:</p>
<pre><code class="language-rust no_run noplayground">fn net_receive(mut netcode: ResMut&lt;MyNetProto&gt;) -&gt; std::io::Result&lt;()&gt; {
    netcode.receive_updates()?;

    Ok(())
}

fn handle_io_errors(In(result): In&lt;std::io::Result&lt;()&gt;&gt;) {
    if let Err(e) = result {
        eprintln!(&quot;I/O error occurred: {}&quot;, e);
    }
}</code></pre>
<p>Such functions cannot be <a href="programming//programming/app-builder.html">registered</a> individually as systems (Bevy
doesn't know what to do with the input/output). By &quot;piping&quot; them together, we
create a valid system that we can add:</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    App::new()
        // ...
        .add_system(net_receive.pipe(handle_io_errors))
        // ...
        .run();
}</code></pre>
<h2 id="performance-warning"><a class="header" href="#performance-warning">Performance Warning</a></h2>
<p>Beware that Bevy treats the whole chain as if it was a single big system, with
all the combined system parameters and their respective data access
requirements. This implies that parallelism could be limited, affecting
performance.</p>
<p>If you create multiple &quot;piped systems&quot; that all contain a common function which
contains any mutable access, that prevents all of them from running in parallel!</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="param-sets"><a class="header" href="#param-sets">Param Sets</a></h1>
<p>For safety reasons, a <a href="programming//programming/systems.html">system</a> cannot have multiple parameters
whose data access might have a chance of mutability conflicts over the
same data.</p>
<p>Some examples:</p>
<ul>
<li>Multiple incompatible <a href="programming//programming/queries.html">queries</a>.</li>
<li>Using <a href="https://docs.rs/bevy/0.12.0/bevy/ecs/world/struct.World.html"><code>&amp;World</code></a> while also having other system parameters to access specific data.</li>
<li>‚Ä¶</li>
</ul>
<p>Consider this example <a href="programming//programming/systems.html">system</a>:</p>
<pre><code class="language-rust no_run noplayground">fn reset_health(
    mut q_player: Query&lt;&amp;mut Health, With&lt;Player&gt;&gt;,
    mut q_enemy: Query&lt;&amp;mut Health, With&lt;Enemy&gt;&gt;,
) {
    // ...
}</code></pre>
<p>The two <a href="programming//programming/queries.html">queries</a> are both trying to mutably access <code>Health</code>. They
have different <a href="programming//programming/queries.html#query-filters">filters</a>, but what if there are entities that
have both <code>Player</code> and <code>Enemy</code> components? If we know that shouldn't happen, we
can add <code>Without</code> filters, but what if it is actually valid for our game?</p>
<p>Such code will compile (Rust cannot know about Bevy ECS semantics), but will
result in a runtime panic. When Bevy tries to run the system, it will panic with
a message about conflicting system parameters:</p>
<pre><code>thread 'main' panicked at bevy_ecs/src/system/system_param.rs:225:5:
error[B0001]: Query&lt;&amp;mut game::Health, bevy_ecs::query::filter::With&lt;game::Enemy&gt;&gt; in
system game::reset_health accesses component(s) game::Health in a way that conflicts
with a previous system parameter. Consider using `Without&lt;T&gt;` to create disjoint Queries
or merging conflicting Queries into a `ParamSet`.
</code></pre>
<p>Bevy provides a solution: wrap any incompatible parameters in a <a href="https://docs.rs/bevy/0.12.0/bevy/ecs/system/struct.ParamSet.html"><code>ParamSet</code></a>:</p>
<pre><code class="language-rust no_run noplayground">fn reset_health(
    // access the health of enemies and the health of players
    // (note: some entities could be both!)
    mut set: ParamSet&lt;(
        Query&lt;&amp;mut Health, With&lt;Enemy&gt;&gt;,
        Query&lt;&amp;mut Health, With&lt;Player&gt;&gt;,
        // also access the whole world ... why not
        &amp;World,
    )&gt;,
) {
    // set health of enemies (use the 1st param in the set)
    for mut health in set.p0().iter_mut() {
        health.hp = 50.0;
    }

    // set health of players (use the 2nd param in the set))
    for mut health in set.p1().iter_mut() {
        health.hp = 100.0;
    }

    // read some data from the world (use the 3rd param in the set)
    let my_resource = set.p2().resource::&lt;MyResource&gt;();
}</code></pre>
<p>This ensures only one of the conflicting parameters can be used at the same time.
Bevy will now happily run our system.</p>
<p>The maximum number of parameters in a param set is 8.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="programming//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="non-send-resources"><a class="header" href="#non-send-resources">Non-Send Resources</a></h1>
<p>&quot;Non-send&quot; refers to data types that must only be accessed from the &quot;main
thread&quot; of the application. Such data is marked by Rust as <code>!Send</code> (lacking
the <a href="https://doc.rust-lang.org/stable/std/marker/trait.Send.html"><code>Send</code></a> trait).</p>
<p>Some (often system) libraries have interfaces that cannot be safely used from
other threads. A common example of this are various low-level OS interfaces
for things like windowing, graphics, or audio. If you are doing advanced
things like creating a Bevy plugin for interfacing with such things, you
may encounter the need for this.</p>
<p>Normally, Bevy works by running all your <a href="programming//programming/systems.html">systems</a> on a
thread-pool, making use of many CPU cores. However, you might need to ensure
that some code always runs on the &quot;main thread&quot;, or access data that is not
safe to access in a multithreaded way.</p>
<h2 id="non-send-systems-and-data-access"><a class="header" href="#non-send-systems-and-data-access">Non-Send Systems and Data Access</a></h2>
<p>To do this, you can use a <a href="https://docs.rs/bevy/0.12.0/bevy/ecs/system/struct.NonSend.html"><code>NonSend&lt;T&gt;</code></a> /
<a href="https://docs.rs/bevy/0.12.0/bevy/ecs/system/struct.NonSendMut.html"><code>NonSendMut&lt;T&gt;</code></a> system parameter. This behaves just like
<a href="https://docs.rs/bevy/0.12.0/bevy/ecs/system/struct.Res.html"><code>Res&lt;T&gt;</code></a> / <a href="https://docs.rs/bevy/0.12.0/bevy/ecs/system/struct.ResMut.html"><code>ResMut&lt;T&gt;</code></a>, letting you access an
ECS <a href="programming//programming/res.html">resource</a> (single global instance of some data), except that
the presence of such a parameter forces the Bevy scheduler to always run the
<a href="programming//programming/systems.html">system</a> on the main thread. This ensures that data never has
to be sent between threads or accessed from different threads.</p>
<p>One example of such a resource is <a href="https://docs.rs/bevy/0.12.0/bevy/winit/struct.WinitWindows.html"><code>WinitWindows</code></a> in Bevy.
This is the low-level layer behind the <a href="programming//window/props.html">window entities</a> that you
typically use for window management. It gives you more direct access to OS
window management functionality.</p>
<pre><code class="language-rust no_run noplayground">fn setup_raw_window(
    q_primary: Query&lt;Entity, With&lt;PrimaryWindow&gt;&gt;,
    mut windows: NonSend&lt;WinitWindows&gt;
) {
    let raw_window = windows.get_window(q_primary.single());
    // do some special things using `winit` APIs
}</code></pre>
<pre><code class="language-rust no_run noplayground">// just add it as a normal system;
// Bevy will notice the NonSend parameter
// and ensure it runs on the main thread
app.add_systems(Startup, setup_raw_window);</code></pre>
<h2 id="custom-non-send-resources"><a class="header" href="#custom-non-send-resources">Custom Non-Send Resources</a></h2>
<p>Normally, to insert <a href="programming//programming/res.html">resources</a>, their types must be
<a href="https://doc.rust-lang.org/stable/std/marker/trait.Send.html"><code>Send</code></a>.</p>
<p>Bevy tracks non-Send resources separately, to ensure that they
can only be accessed using <a href="https://docs.rs/bevy/0.12.0/bevy/ecs/system/struct.NonSend.html"><code>NonSend&lt;T&gt;</code></a> /
<a href="https://docs.rs/bevy/0.12.0/bevy/ecs/system/struct.NonSendMut.html"><code>NonSendMut&lt;T&gt;</code></a>.</p>
<p>It is not possible to insert non-send resources using
<a href="programming//programming/commands.html"><code>Commands</code></a>, only using <a href="programming//programming/world.html">direct World access</a>.
This means that you have to initialize them in an <a href="programming//programming/exclusive.html">exclusive
system</a>, <a href="https://docs.rs/bevy/0.12.0/bevy/ecs/world/trait.FromWorld.html"><code>FromWorld</code></a> impl,
or custom stage.</p>
<pre><code class="language-rust no_run noplayground">fn setup_platform_audio(world: &amp;mut World) {
    // assuming `OSAudioMagic` is some primitive that is not thread-safe
    let instance = OSAudioMagic::init();

    world.insert_non_send_resource(instance);
}</code></pre>
<pre><code class="language-rust no_run noplayground">app.add_systems(Startup, setup_platform_audio);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="bevy-render-gpu-framework"><a class="header" href="#bevy-render-gpu-framework">Bevy Render (GPU) Framework</a></h1>
<p><strong>NOTE:</strong> This chapter of the book is an early <em>Work in Progress</em>!
Many links are still broken!</p>
<hr />
<p>This chapter covers Bevy's rendering framework and how to work with the GPU.</p>
<p>Make sure you are well familiar with <a href="/programming.html">Bevy's Core Programming
Framework</a>. Everything here builds on top of it.</p>
<p>Here you will learn how to write custom rendering code. If you are simply
interested in using the existing graphical features provided by Bevy, check
out the chapters about <a href="/graphics.html">General Graphics Features</a>,
<a href="/2d.html">2D</a>, and <a href="/3d.html">3D</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="gpu//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="render-architecture-overview"><a class="header" href="#render-architecture-overview">Render Architecture Overview</a></h1>
<p><strong>NOTE:</strong> This chapter of the book is an early <em>Work in Progress</em>!
Many links are still broken!</p>
<hr />
<p>The current Bevy render architecture premiered in Bevy 0.6. The <a href="https://bevyengine.org/news/bevy-0-6">news blog
post</a> is another place you can learn about it. :)</p>
<p>It was inspired by the Destiny Render Architecture (from the Destiny game).</p>
<h2 id="pipelined-rendering-1"><a class="header" href="#pipelined-rendering-1">Pipelined Rendering</a></h2>
<p>Bevy's renderer is architected in a way that operates independently from all
the normal app logic. It operates in its own separate <a href="gpu//programming/world.html">ECS World</a>
and has its own <a href="gpu//programming/app-builder.html">schedule</a>, with <a href="gpu//gpu/stages.html">stages</a> and
<a href="gpu//programming/systems.html">systems</a>.</p>
<p>The plan is that, in a future Bevy version, the renderer will run in parallel
with all the normal app logic, allowing for greater performance. This is
called &quot;pipelined rendering&quot;: rendering the previous frame at the same time
as the app is processing the next frame update.</p>
<p>Every frame, the two parts are synchronized in a special <a href="gpu//programming/schedules.html">stage</a>
called &quot;Extract&quot;. The Extract stage has access to both <a href="gpu//programming/world.html">ECS Worlds</a>,
allowing it to copy data from the main World into the render World.</p>
<p>From then on, the renderer only has access to the render World, and can only
use data that is stored there.</p>
<p>Every frame, all <a href="gpu//programming/intro-data.html#entities--components">entities</a> in the render World are erased, but
<a href="gpu//programming/res.html">resources</a> are kept. If you need to persist data from frame to
frame, store it in resources. Dynamic data that could change every frame
should be copied into the render world in the Extract stage, and typically
stored using entities and components.</p>
<p><img src="gpu//img/pipelined-rendering.png" alt="Diagram of pipelined rendering timings in app-bound and render-bound cases" /></p>
<h2 id="core-architecture"><a class="header" href="#core-architecture">Core Architecture</a></h2>
<p>The renderer operates in multiple <a href="gpu//gpu/stages.html">render stages</a>. This
is how the work that needs to be performed on the CPU is managed.</p>
<p>The ordering of the workloads to be performed on the GPU is controlled
using the <a href="gpu//TODO.html">render graph</a>. The graph consists of
<a href="gpu//TODO.html">nodes</a>, each representing a workload for the GPU,
typically a <a href="gpu//TODO.html">render pass</a>. The nodes are connected using
<a href="gpu//TODO.html">edges</a>, representing their ordering/dependencies
with regard to one another.</p>
<h2 id="layers-of-abstraction"><a class="header" href="#layers-of-abstraction">Layers of Abstraction</a></h2>
<p>The Bevy rendering framework can accomodate you working at various different
levels of abstraction, depending on how much you want to integrate with the
Bevy ecosystem and built-in features, vs. have more direct control over the GPU.</p>
<p>For most things, you would be best served by the &quot;high-level&quot; or &quot;mid-level&quot; APIs.</p>
<h3 id="low-level"><a class="header" href="#low-level">Low-Level</a></h3>
<p>Bevy works directly with <a href="https://github.com/gfx-rs/wgpu"><code>wgpu</code></a>, a Rust-based cross-platform
graphics API. It is the abstraction layer over the GPU APIs of the underlying
<a href="gpu//platforms.html">platform</a>. This way, the same GPU code can work on all
supported platforms. The API design of <a href="https://github.com/gfx-rs/wgpu"><code>wgpu</code></a> is based on
the WebGPU standard, but with extensions to support native platform features,
going beyond the limitations of the web platform.</p>
<p><a href="https://github.com/gfx-rs/wgpu"><code>wgpu</code></a> (and hence Bevy) supports the following backends:</p>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Backends (in order of priority)</th></tr></thead><tbody>
<tr><td>Linux</td><td>Vulkan, GLES3</td></tr>
<tr><td>Windows</td><td>DirectX 12, Vulkan, GLES3</td></tr>
<tr><td>macOS</td><td>Metal</td></tr>
<tr><td>iOS</td><td>Metal</td></tr>
<tr><td>Android</td><td>Vulkan, GLES3</td></tr>
<tr><td>Web</td><td>WebGPU, WebGL2</td></tr>
</tbody></table>
</div>
<p>On GLES3 and WebGL2, some renderer features are unsupported and performance is worse.</p>
<p>WebGPU is experimental and few browsers support it.</p>
<p><code>wgpu</code> forms the &quot;lowest level&quot; of Bevy rendering. If you really need the
most direct control over the GPU, you can pretty much use <code>wgpu</code> directly,
from within the Bevy render framework.</p>
<h3 id="mid-level"><a class="header" href="#mid-level">Mid-Level</a></h3>
<p>On top of <code>wgpu</code>, Bevy provides some abstractions that can help you, and
integrate better with the rest of Bevy.</p>
<p>The first is <a href="gpu//TODO.html">pipeline caching</a> and
<a href="gpu//TODO.html">specialization</a>. If you create your
<a href="gpu//TODO.html">render pipelines</a> via this interface, Bevy can manage
them efficiently for you, creating them when they are first used, and then
caching and reusing them, for optimal performance.</p>
<p>Caching and specialization are, analogously, also available for <a href="gpu//TODO.html">GPU Compute
pipelines</a>.</p>
<p>Similar to the <a href="gpu//TODO.html">pipeline cache</a>, there is a <a href="gpu//TODO.html">texture
cache</a>. This is what you use for rendering-internal
<a href="gpu//TODO.html">textures</a> (for example: shadow maps, reflection maps,
‚Ä¶), that do not originate from <a href="gpu//assets.html">assets</a>. It will manage and
reuse the GPU memory allocation, and free it when it becomes unused.</p>
<p>For using data from <a href="gpu//assets.html">assets</a>, Bevy provides the <a href="gpu//TODO.html">Render
Asset</a> abstraction to help with extracting the data from
different <a href="gpu//builtins.html#assets">asset types</a>.</p>
<p>Bevy can manage all the &quot;objects to draw&quot; using <a href="gpu//TODO.html">phases</a>,
which sort and draw <a href="gpu//TODO.html">phase items</a>. This way, Bevy
can sort each object to render, relative to everything else in the scene,
for optimal performance and correct transparency (if any).</p>
<p>Phase Items are defined using <a href="gpu//TODO.html">render commands</a>
and/or <a href="gpu//TODO.html">draw functions</a>. These are, conceputally,
the rendering equivalents of ECS <a href="gpu//programming/systems.html">systems</a> and <a href="gpu//programming/exclusive.html">exclusive
systems</a>, fetching data from the ECS World and generating
<a href="gpu//TODO.html">draw calls</a> for the GPU.</p>
<p>All of these things fit into the core architecture of the Bevy <a href="gpu//TODO.html">render
graph</a> and <a href="gpu//gpu/stages.html">render stages</a>. During
the Render stage, <a href="gpu//TODO.html">graph nodes</a> will execute <a href="gpu//TODO.html">render
passes</a> with the <a href="gpu//TODO.html">render phases</a>,
to draw everything as it was set up in the Prepare/Queue/PhaseSort stages.</p>
<p>The <code>bevy_core_pipeline</code> crate defines a set of <a href="gpu//TODO.html">standard
phase/item</a> and main pass types. If you can, you
should work with them, for best compatibility with the Bevy ecosystem.</p>
<h3 id="high-level"><a class="header" href="#high-level">High-Level</a></h3>
<p>On top of all the mid-level APIs, Bevy provides abstractions to make many
common kinds of workloads easier.</p>
<p>The most notable higher-level features are <a href="gpu//TODO.html">meshes</a> and
<a href="gpu//TODO.html">materials</a>.</p>
<p>Meshes are the source of per-vertex data (<a href="gpu//TODO.html">vertex
attributes</a>) to be fed into
your <a href="gpu//TODO.html">shaders</a>. The material specifies what
<a href="gpu//TODO.html">shaders</a> to use and any other data that needs to be
fed into it, like <a href="gpu//TODO.html">textures</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="gpu//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="render-stages"><a class="header" href="#render-stages">Render Stages</a></h1>
<p>Everything on the CPU side (the whole process of driving the GPU workloads)
is structured in a sequence of &quot;render stages&quot;:</p>
<h2 id="timings"><a class="header" href="#timings">Timings</a></h2>
<p>Note: Pipelined rendering is not yet actually enabled in Bevy 0.9. This section
explains the intended behavior, which will land in a future Bevy version. You
have to understand it, because any custom rendering code you write will have to
work with it in mind.</p>
<p><img src="gpu//img/pipelined-rendering.png" alt="Diagram of pipelined rendering timings in app-bound and render-bound cases" /></p>
<p>Every frame, <a href="gpu/stages.html#extract">Extract</a> serves as the synchronization point.</p>
<p>When the Render Schedule completes, it will start again, but Extract will
wait for the App Schedule, if it has not completed yet. The App Schedule
will start again as soon as Extract has completed.</p>
<p>Therefore:</p>
<ul>
<li>in an App-bound scenario (if app takes longer than render):
<ul>
<li>The start of Extract is waiting for App to finish</li>
</ul>
</li>
<li>in a Render-bound scenario (if render takes longer than app):
<ul>
<li>The start of App is waiting for Extract to finish</li>
</ul>
</li>
</ul>
<p>If <a href="gpu//window/props.html#vsync">vsync</a> is enabled, the wait for the next refresh of the
screen will happen in the <a href="gpu/stages.html#prepare">Prepare</a> stage. This has the effect of
prolonging the Prepare stage in the Render schedule. Therefore, in practice,
your game will behave like the &quot;Render-bound&quot; scenario shown above.</p>
<p>The final render (the framebuffer with the pixels to show in the
<a href="gpu//window/props.html">window</a>) is <em>presented</em> to the OS/driver at the end of the
<a href="gpu/stages.html#render">Render</a> stage.</p>
<p>Bevy updates its <a href="gpu//fundamentals/time.html">timing information</a> (in <a href="https://docs.rs/bevy/0.9.1/bevy/time/struct.Time.html"><code>Res&lt;Time&gt;</code></a>)
at the start of the First stage in the main App schedule. The value to
use is measured at &quot;presentation time&quot;, in the render world, and the
<a href="https://doc.rust-lang.org/stable/std/time/struct.Instant.html"><code>Instant</code></a> is sent over a channel, to be applied on the
next frame.</p>
<h2 id="adding-systems-to-render-stages"><a class="header" href="#adding-systems-to-render-stages">Adding Systems to Render Stages</a></h2>
<p>If you are implementing custom rendering functionality in Bevy, you will likely
need to add some of your own systems to at least some of the render stages:</p>
<ul>
<li>
<p>Anything that needs data from your main App World will need a system in
<a href="gpu/stages.html#extract">Extract</a> to copy that data. In practice, this is almost everything,
unless it is fully contained on the GPU, or only uses renderer-internal
generated data.</p>
</li>
<li>
<p>Most use cases will need to do some setup of GPU resources
in <a href="gpu/stages.html#prepare">Prepare</a> and/or <a href="gpu/stages.html#queue">Queue</a>.</p>
</li>
<li>
<p>In <a href="gpu/stages.html#cleanup">Cleanup</a>, all <a href="gpu//programming/intro-data.html#entities--components">entities</a> are cleared automatically.
If you have some custom data stored in <a href="gpu//programming/res.html">resources</a>, you can let it
stay for the next frame, or add a system to clear it, if you want.</p>
</li>
</ul>
<p>The way Bevy is set up, you shouldn't need to do anything in <a href="gpu/stages.html#render">Render</a>
or <a href="gpu/stages.html#phasesort">PhaseSort</a>. If your custom rendering is part of the Bevy
<a href="gpu//TODO.html">render graph</a>, it will just be handled automatically
when Bevy executes the render graph in the <a href="gpu/stages.html#render">Render</a> stage. If you
are implementing custom <a href="gpu//TODO.html">phase items</a>, the Main Pass
render graph node will render them together with everything else.</p>
<p>You can add your rendering systems to the respective stages, using the render
<a href="gpu//programming/app-builder.html#sub-apps">sub-app</a>:</p>
<pre><code>// TODO: code example
</code></pre>
<h2 id="extract"><a class="header" href="#extract">Extract</a></h2>
<p>Extract is a very important and special stage. It is the synchronization
point that links the two ECS Worlds. This is where the data required for
rendering is copied (&quot;extracted&quot;) from the main App World into the Render
World, allowing for pipelined rendering.</p>
<p>During the Extract stage, nothing else can run in parallel, on either the
main App World or the Render World. Hence, Extract should be kept minimal
and complete its work as quickly as possible.</p>
<p>It is recommended that you avoid doing any computations in Extract, if
possible. Just copy data.</p>
<p>It is recommended that you only copy the data you actually need for rendering.
Create new <a href="gpu//programming/ec.html#components">component types</a> and <a href="gpu//programming/res.html">resources</a> just
for use within the render World, with only the data you need.</p>
<p>For example, Bevy's 2D sprites uses a <a href="https://docs.rs/bevy/0.9.1/bevy/sprite/struct.ExtractedSprite.html"><code>struct ExtractedSprite</code></a>, where it copies the relevant data
from the &quot;user-facing&quot; components of sprite and spritesheet entities in the
main World.</p>
<p>Bevy <strong>reserves Entity IDs</strong> in the render World, matching all the Entities
existing in the main World. In most cases, you do not need to <em>spawn</em>
new entities in the render World. You can just <a href="gpu//programming/commands.html">insert components with
Commands</a> on the same Entity IDs as from the main World.</p>
<pre><code>// TODO: code example
</code></pre>
<h2 id="prepare"><a class="header" href="#prepare">Prepare</a></h2>
<p>Prepare is the stage to use if you need to set up any data on the
GPU. This is where you can create GPU <a href="gpu//TODO.html">buffers</a>,
<a href="gpu//TODO.html">textures</a>, and <a href="gpu//TODO.html">bind groups</a>.</p>
<p>// TODO: elaborate on different ways Bevy is using it internally</p>
<pre><code>// TODO: code example
</code></pre>
<h2 id="queue"><a class="header" href="#queue">Queue</a></h2>
<p>Queue is the stage where you can set up the &quot;rendering jobs&quot; you will need to
execute.</p>
<p>Typically, this means creating <a href="gpu//TODO.html">phase items</a>
with the correct <a href="gpu//TODO.html">render pipeline</a> and <a href="gpu//TODO.html">draw
function</a>, for everything that you need to draw.</p>
<p>For other things, analogously, Queue is where you would set up the workloads
(like compute or draw calls) that the GPU would need to perform.</p>
<p>// TODO: elaborate on different ways Bevy is using it internally</p>
<pre><code>// TODO: code example
</code></pre>
<h2 id="phasesort"><a class="header" href="#phasesort">PhaseSort</a></h2>
<p>This stage exists for Bevy to sort all of the <a href="gpu//TODO.html">phase
items</a> that were set up during the <a href="gpu/stages.html#queue">Queue</a>
stage, before rendering in the <a href="gpu/stages.html#render">Render</a> stage.</p>
<p>It is unlikely that you will need to add anything custom here. I'm not aware
of use cases. <a href="gpu//contact.html">Let me know</a> if you know of any.</p>
<h2 id="render"><a class="header" href="#render">Render</a></h2>
<p>Render is the stage where Bevy executes the <a href="gpu//TODO.html">Render Graph</a>.</p>
<p>The built-in behavior is configured using Cameras. For each active Camera,
Bevy will execute its associated render graph, configured to output to its
associated render target.</p>
<p>If you are using any of the <a href="gpu//TODO.html">standard render phases</a>,
you don't need to do anything. Your custom <a href="gpu//TODO.html">phase items</a>
will be rendered automatically as part of the Main Pass built-in render graph
<a href="gpu//TODO.html">nodes</a>, alongside everything else.</p>
<p>If you are implementing a rendering feature that needs a separate step, you
can add it as a <a href="gpu//TODO.html">render graph node</a>, and it will be
rendered automatically.</p>
<p>The only time you might need to do something custom here is if you really
want to sidestep Bevy's frameworks and reach for low-level <code>wgpu</code> access.
You could place it in the Render stage.</p>
<h2 id="cleanup"><a class="header" href="#cleanup">Cleanup</a></h2>
<p>Bevy has a built-in system in Cleanup that clears all <a href="gpu//programming/intro-data.html#entities--components">entities</a> in
the render World. Therefore, all data stored in components will be lost.
It is expected that fresh data will be obtained in the next frame's
<a href="gpu/stages.html#extract">Extract</a> stage.</p>
<p>To persist rendering data over multiple frames, you should store it in
<a href="gpu//programming/res.html">resources</a>. That way you have control over it.</p>
<p>If you need to clear some data from your resources sometimes, you could
add a custom system to the Cleanup stage to do it.</p>
<pre><code>// TODO: code example
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="programming-patterns"><a class="header" href="#programming-patterns">Programming Patterns</a></h1>
<p>This chapter is about any non-obvious tricks, programming techniques,
patterns and idioms, that may be useful when programming with Bevy.</p>
<p>These topics are an extension of the topics covered in the <a href="/programming.html">Bevy Programming
Framework</a> chapter. See that chapter to learn the
foundational concepts.</p>
<p>Some of the things covered in this chapter might be controversial or only useful
to specific use cases. Don't take this chapter as teaching &quot;general best
practice&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="patterns//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="generic-systems"><a class="header" href="#generic-systems">Generic Systems</a></h1>
<p>Bevy <a href="patterns//programming/systems.html">systems</a> are just plain rust functions, which means they
can be generic. You can add the same system multiple times, parametrized to
work on different Rust types or values.</p>
<h2 id="generic-over-component-types"><a class="header" href="#generic-over-component-types">Generic over Component types</a></h2>
<p>You can use the generic type parameter to specify what
<a href="patterns//programming/ec.html#components">component</a> types (and hence what <a href="patterns//programming/ecs-intro.html">entities</a>)
your <a href="patterns//programming/systems.html">system</a> should operate on.</p>
<p>This can be useful when combined with Bevy <a href="patterns//programming/states.html">states</a>.
You can do the same thing to different sets of entities depending on state.</p>
<h3 id="example-cleanup"><a class="header" href="#example-cleanup">Example: Cleanup</a></h3>
<p>One straightforward use-case is for cleanup. We can make a generic cleanup
system that just despawns all entities that have a certain component
type. Then, trivially run it on exiting different states.</p>
<pre><code class="language-rust no_run noplayground">use bevy::ecs::component::Component;

fn cleanup_system&lt;T: Component&gt;(
    mut commands: Commands,
    q: Query&lt;Entity, With&lt;T&gt;&gt;,
) {
    for e in q.iter() {
        commands.entity(e).despawn_recursive();
    }
}</code></pre>
<p>Menu entities can be tagged with <code>cleanup::MenuExit</code>, entities from the game
map can be tagged with <code>cleanup::LevelUnload</code>.</p>
<p>We can add the generic cleanup system to our state transitions, to take care
of the respective entities:</p>
<pre><code class="language-rust no_run noplayground">/// Marker components to group entities for cleanup
mod cleanup {
    use bevy::prelude::*;
    #[derive(Component)]
    pub struct LevelUnload;
    #[derive(Component)]
    pub struct MenuClose;
}

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
enum AppState {
    MainMenu,
    InGame,
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_state(AppState::MainMenu)
        // add the cleanup systems
        .add_system_set(SystemSet::on_exit(AppState::MainMenu)
            .with_system(cleanup_system::&lt;cleanup::MenuClose&gt;))
        .add_system_set(SystemSet::on_exit(AppState::InGame)
            .with_system(cleanup_system::&lt;cleanup::LevelUnload&gt;))
        .run();
}</code></pre>
<h2 id="using-traits"><a class="header" href="#using-traits">Using Traits</a></h2>
<p>You can use this in combination with Traits, for when you need some sort of
varying implementation/functionality for each type.</p>
<h3 id="example-bevys-camera-projections"><a class="header" href="#example-bevys-camera-projections">Example: Bevy's Camera Projections</a></h3>
<p>(this is a use-case within Bevy itself)</p>
<p>Bevy has a <a href="https://docs.rs/bevy/0.9.1/bevy/render/camera/trait.CameraProjection.html"><code>CameraProjection</code></a> trait. Different
projection types like <a href="https://docs.rs/bevy/0.9.1/bevy/render/camera/struct.PerspectiveProjection.html"><code>PerspectiveProjection</code></a>
and <a href="https://docs.rs/bevy/0.9.1/bevy/render/camera/struct.OrthographicProjection.html"><code>OrthographicProjection</code></a> implement that
trait, providing the correct logic for how to respond to resizing the window,
calculating the projection matrix, etc.</p>
<p>There is a generic system <code>fn camera_system::&lt;T: CameraProjection + Component&gt;</code>, which handles all the cameras with a given projection type. It
will call the trait methods when appropriate (like on window resize events).</p>
<p>The <a href="patterns//cookbook/custom-projection.html">Bevy Cookbook Custom Camera Projection
Example</a> shows this API in action.</p>
<h2 id="using-const-generics"><a class="header" href="#using-const-generics">Using Const Generics</a></h2>
<p>Now that Rust has support for Const Generics, functions can also be
parametrized by values, not just types.</p>
<pre><code class="language-rust no_run noplayground">fn process_layer&lt;const LAYER_ID: usize&gt;(
    // system params
) {
    // do something for this `LAYER_ID`
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_system(process_layer::&lt;1&gt;)
        .add_system(process_layer::&lt;2&gt;)
        .add_system(process_layer::&lt;3&gt;)
        .run();
}</code></pre>
<p>Note that these values are static / constant at compile-time. This can be
a severe limitation. In some cases, when you might suspect that you could
use const generics, you might realize that you actually want a runtime value.</p>
<p>If you need to &quot;configure&quot; your system by passing in some data, you could,
instead, use a <a href="patterns//programming/res.html">Resource</a> or <a href="patterns//programming/local.html">Local</a>.</p>
<p>Note: As of Rust 1.65, support for using <code>enum</code> values as const generics is
not yet stable. To use <code>enum</code>s, you need Rust Nightly, and to enable the
experimental/unstable feature (put this at the top of your <code>main.rs</code> or
<code>lib.rs</code>):</p>
<pre><code class="language-rust no_run noplayground">#![feature(adt_const_params)]</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="patterns//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="component-storage-tablesparse-set"><a class="header" href="#component-storage-tablesparse-set">Component Storage (Table/Sparse-Set)</a></h1>
<p>Bevy ECS provides two different ways of storing data: tables and sparse sets.
The two storage kinds offer different performance characteristics.</p>
<p>The kind of storage to be used can be chosen per <a href="patterns//programming/ec.html#components">component</a>
type.  When you derive the <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/component/trait.Component.html"><code>Component</code></a> trait, you can
specify it. The default, if unspecified, is table storage. You can have
components with a mixture of different storage kinds on the same entity.</p>
<p>The rest of this page is dedicated to explaining the performance trade-offs
and why you might want to choose one storage kind vs. the other.</p>
<pre><code class="language-rust no_run noplayground">/// Component for entities that can cast magic spells
#[derive(Component)] // Use the default table storage
struct Mana {
    mana: f32,
}

/// Component for enemies that currently &quot;see&quot; the player
/// Every frame, add/remove to entities based on visibility
/// (use sparse-set storage due to frequent add/remove)
#[derive(Component)]
#[component(storage = &quot;SparseSet&quot;)]
struct CanSeePlayer;

/// Component for entities that are currently taking bleed damage
/// Add to entities to apply bleed effect, remove when done
/// (use sparse-set storage to not fragment tables,
/// as this is a &quot;temporary effect&quot;)
#[derive(Component)]
#[component(storage = &quot;SparseSet&quot;)]
struct Bleeding {
    damage_rate: f32,
}</code></pre>
<h2 id="table-storage"><a class="header" href="#table-storage">Table Storage</a></h2>
<p>Table storage is optimized for fast <a href="patterns//programming/queries.html">query</a> iteration. If the
way you usually use a specific component type is to iterate over its data
across many entities, this will offer the best performance.</p>
<p>However, adding/removing table components to existing entities is a relatively
slow operation. It requires copying the data of all table components for
the entity to a different location in memory.</p>
<p>It's OK if you have to do this sometimes, but if you are likely to add/remove
a component very frequently, you might want to switch that component type
to sparse-set storage.</p>
<p>You can see why table storage was chosen as Bevy's default. Most component
types are rarely added/removed in practice. You typically spawn entities with
all the components they should have, and then access the data via queries,
usually every frame. Sometimes you might add or remove a component to change
an entity's behavior, but probably not nearly as often, or every frame.</p>
<h2 id="sparse-set-storage"><a class="header" href="#sparse-set-storage">Sparse-Set Storage</a></h2>
<p>Sparse-Set storage is optimized for fast adding/removing of a component to
existing entities, at the cost of slower querying. It can be more efficient
for components that you would like to add/remove very frequently.</p>
<p>An example of this might be a <a href="patterns//programming/ec.html#components">marker component</a>
indicating whether an enemy is currently aware of the player. You might
want to have such a component type, so that you can easily use a <a href="patterns//programming/queries.html#query-filters">query
filter</a> to find all the enemies that are currently
tracking the player. However, this is something that can change every frame,
as enemies or the player move around the game level. If you add/remove this
component every time the visibility status changed, that's a lot of additions
and removals.</p>
<p>You can see that situations like these are more niche and do not apply
to most typical component types. Treat sparse-set storage as a potential
optimization you could try in specific circumstances.</p>
<p>Even in situations like the example above, it might not be a performance win.
Everything depends on your application's unique usage patterns. You have to
measure and try.</p>
<h2 id="table-fragmentation"><a class="header" href="#table-fragmentation">Table Fragmentation</a></h2>
<p>Furthermore, the actual memory layout of the &quot;tables&quot; depends on the set of
all table components that each of your entities has.</p>
<p>ECS queries perform best when many of the entities they match have the same
overall set of components.</p>
<p>Having a large number of entities, that all have the same component types, is
very efficient in terms of data access performance. Having diverse entities
with a varied mixture of different component types, means that their data
will be fragmented in memory and be less efficient to access.</p>
<p>Sparse-Set components do not affect the memory layout of tables. Hence,
components that are only used on a few entities or as a &quot;temporary effect&quot;,
might also be good candidates for sparse-set storage. That way they don't
fragment the memory of the other (table) components. Systems that do not
care about these components will be completely unaffected by them existing.</p>
<h2 id="overall-advice"><a class="header" href="#overall-advice">Overall Advice</a></h2>
<p>While this page describes the general performance characteristics and gives
some guidelines, you often cannot know if something improves performance
without benchmarking.</p>
<p>When your game grows complex enough and you have something to benchmark,
you could try to apply sparse-set storage to situations where it might make
sense, as described above, and see how it affects your results.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="patterns//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="manual-event-clearing"><a class="header" href="#manual-event-clearing">Manual Event Clearing</a></h1>
<p>The <a href="patterns//programming/events.html">event</a> queue needs to be cleared periodically,
so that it does not grow indefinitely and waste unbounded memory.</p>
<p>Bevy's default cleanup strategy is to clear events every frame, but with double
buffering, so that events from the previous frame update stay available. This
means that you can handle the events only until the end of the next frame
after the one when they are sent.</p>
<p>This default works well for systems that run every frame and check for events
every time, which is the typical usage pattern.</p>
<p>However, if you have systems that do not read events every frame, they might
miss some events. Some common scenarios where this occurs are:</p>
<ul>
<li>systems with an early-return, that don't read events every time they run</li>
<li>when using <a href="patterns//fundamentals/fixed-timestep.html">fixed timestep</a></li>
<li>systems that only run in specific <a href="patterns//programming/states.html">states</a>,
such as if your game has a pause state</li>
<li>when using custom <a href="patterns//programming/run-criteria.html">run criteria</a> to control
your systems</li>
</ul>
<p>To be able to reliably manage events in such circumstances, you might want
to have manual control over how long the events are held in memory.</p>
<p>You can replace Bevy's default cleanup strategy with your own.</p>
<p>To do this, simply add your event type (wrapped as <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/event/struct.Events.html"><code>Events&lt;T&gt;</code></a>)
to the <a href="patterns//programming/app-builder.html">app builder</a> using <code>.init_resource</code>, instead of <code>.add_event</code>.</p>
<p>(<code>.add_event</code> is actually just a convenience method that initializes the
<a href="patterns//programming/res.html">resource</a> and adds Bevy's built-in system (<a href="patterns//patterns/generic-systems.html">generic</a>
over your event type) for the default cleanup strategy)</p>
<p>You must then clear the events at your discretion. If you don't do this often
enough, your events might pile up and waste memory.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>We can create <a href="patterns//patterns/generic-systems.html">generic systems</a> for this. Implement
the custom cleanup strategy, and then add that <a href="patterns//programming/systems.html">system</a> to your
<a href="https://docs.rs/bevy/0.9.1/bevy/app/struct.App.html"><code>App</code></a> as many times as you need, for each <a href="patterns//programming/events.html">event</a> type
where you want to use your custom behavior.</p>
<pre><code class="language-rust no_run noplayground">use bevy::ecs::event::Events;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)

        // add the `Events&lt;T&gt;` resource manually
        // these events will not have automatic cleanup
        .init_resource::&lt;Events&lt;MySpecialEvent&gt;&gt;()

        // this is a regular event type with automatic cleanup
        .add_event::&lt;MyRegularEvent&gt;()

        // add the cleanup systems
        .add_system(my_event_manager::&lt;MySpecialEvent&gt;)
        .run();
}

/// Custom cleanup strategy for events
///
/// Generic to allow using for any custom event type
fn my_event_manager&lt;T: 'static + Send + Sync&gt;(
    mut events: ResMut&lt;Events&lt;T&gt;&gt;,
) {
    // TODO: implement your custom logic
    // for deciding when to clear the events

    // clear all events like this:
    events.clear();

    // or with double-buffering
    // (this is what Bevy's default strategy does)
    events.update();

    // or drain them, if you want to iterate,
    // to access the values:
    for event in events.drain() {
        // TODO: do something with each event
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="patterns//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-9">0.9</a></th><th>(outdated!)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="writing-tests-for-systems"><a class="header" href="#writing-tests-for-systems">Writing Tests for Systems</a></h1>
<p>You might want to write and run automated tests for your <a href="patterns//programming/systems.html">systems</a>.</p>
<p>You can use the regular Rust testing features (<code>cargo test</code>) with Bevy.</p>
<p>To do this, you can create an empty ECS <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/world/struct.World.html"><code>World</code></a> in your
tests, and then, using <a href="patterns//programming/world.html">direct World access</a>, insert whatever
<a href="patterns//programming/ec.html#entities">entities</a> and <a href="patterns//programming/res.html">resources</a> you need for testing. Create
a standalone <a href="patterns//programming/schedules.html">stage</a> with the <a href="patterns//programming/systems.html">systems</a> you want to
run, and manually run it on the <a href="https://docs.rs/bevy/0.9.1/bevy/ecs/world/struct.World.html"><code>World</code></a>.</p>
<p>Bevy's official repository has a fantastic <a href="https://github.com/bevyengine/bevy/blob/main/tests/how_to_test_systems.rs">example of how to do
this</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="bevy-on-different-platforms"><a class="header" href="#bevy-on-different-platforms">Bevy on Different Platforms</a></h1>
<p>This chapter is a collection of platform-specific information, about using
Bevy with different operating systems or environments.</p>
<p>Feel free to suggest things to add.</p>
<h2 id="platform-support"><a class="header" href="#platform-support">Platform Support</a></h2>
<p>Bevy aims to also make it easy to target different platforms, such as the
various desktop operating systems, web browsers (via WebAssembly), mobile
(Android and iOS), and game consoles. Your Bevy code can be the same for all
platforms, with differences only in the build process and environment setup.</p>
<p>However, that vision is not fully met yet. Currently, support for non-desktop
platforms is limited, and requires more complex configuration.</p>
<h3 id="desktop"><a class="header" href="#desktop">Desktop</a></h3>
<p>Bevy trivially works out-of-the-box on the three major desktop operating
systems: Linux, macOS, Windows. No special configuration is required.</p>
<p>See the following pages for specific tips/advice when developing for the
desktop platforms:</p>
<ul>
<li><a href="/platforms/linux.html">Linux</a></li>
<li><a href="/platforms/macos.html">macOS</a></li>
<li><a href="/platforms/windows.html">Windows</a></li>
</ul>
<p>All Bevy features are fully supported on each of the above.</p>
<p>You can also build Windows EXEs for your Windows users, if you are working
in <a href="/setup/cross/linux-windows.html">Linux</a> or <a href="/setup/cross/macos-windows.html">macOS</a>.</p>
<h3 id="web"><a class="header" href="#web">Web</a></h3>
<p>Bevy works quite well on the <a href="/platforms/wasm.html">web (using WebAssembly)</a>,
but with some limitations.</p>
<p>Multithreading is not supported, so you will have limited performance and
possible audio glitches. Rendering is limited to the features of the WebGL2
API, meaning worse performance and limitations like only supporting a maximum
of 256 lights in 3D scenes. These limitations can be lifted by enabling the
new WebGPU support, but then you will have limited browser compatibility.</p>
<p>For inspiration, check out the entries in the Bevy Game Jams
(<a href="https://itch.io/jam/bevy-jam-3/entries">third</a>, <a href="https://itch.io/jam/bevy-jam-2/entries">second</a>, <a href="https://itch.io/jam/bevy-jam-1/entries">first</a>). Many
of them have web builds you can play in your browser.</p>
<h3 id="mobile"><a class="header" href="#mobile">Mobile</a></h3>
<p>Apple iOS is well-supported and most features work well. There are developers
in the Bevy community that have successfully shipped Bevy-based apps to the
App Store.</p>
<p>Android support is not as good as iOS, but very usable (as of Bevy 0.12). If
you find bugs, broken features, or other issues, please report them.</p>
<p>Bevy has been known to have issues with emulator devices. It is recommended
you test your app on real hardware.</p>
<h3 id="game-consoles"><a class="header" href="#game-consoles">Game Consoles</a></h3>
<p>Unfortunately, due to NDA requirements, developing for consoles is inaccessible
to most community developers who work in the open, and Bevy support is still
mostly nonexistent.</p>
<p>At some point, there was someone in the community working on PlayStation
support. I do not know if they are still around, or anything about the
status of that work. If you are interested, join <a href="https://discord.gg/bevy">Discord</a>
and ask around. Maybe you can find each other and work together.</p>
<p>The Rust Programming Language aims to make Nintendo Switch a supported target,
but that work is in its early days and has not progressed enough to be useful
for Bevy yet. It should be possible to work on Nintendo Switch support in
the open, without NDAs, using emulators.</p>
<p>The Steam Deck, and other such &quot;handheld PCs&quot;, are well supported. Such
devices run special versions of standard Desktop OSs (Linux, Windows) and are
designed to support PC games out of the box. To develop for these devices,
just make regular Linux/Windows builds of your game and ideally try them on
an actual device, so you can see how the handheld experience is like and make
sure your game feels good on such a device.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="linux-desktop"><a class="header" href="#linux-desktop">Linux Desktop</a></h1>
<p>If you have any additional Linux-specific knowledge,
please help improve this page!</p>
<p>Create Issues or PRs on <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<hr />
<p>Desktop Linux is one of the best-supported platforms by Bevy.</p>
<p>There are some development dependencies you may need to setup, depending on your
distribution. <a href="https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md">See instructions in official Bevy repo.</a></p>
<p><a href="platforms//setup/cross/linux-windows.html">See here if you also want to build Windows EXEs from Linux</a>.</p>
<h2 id="gpu-drivers-1"><a class="header" href="#gpu-drivers-1">GPU Drivers</a></h2>
<p>Bevy apps need support for the Vulkan graphics API to run best. There is a
fallback on OpenGL ES 3 for systems where Vulkan is unsupported, but it might not
work and will have limited features and performance.</p>
<p>You (and your users) must ensure that you have compatible hardware and drivers
installed. On most modern distributions and computers, this should be no problem.</p>
<p>If Bevy apps refuse to run and print an error to the console about not being
able to find a compatible GPU, the problem is most likely with the Vulkan
components of your graphics driver not being installed correctly. You may
need to install some extra packages or reinstall your graphics drivers. Check
with your Linux distribution for what to do.</p>
<p>To confirm that Vulkan is working, you can try to run this command (found in
a package called <code>vulkan-tools</code> on most distributions):</p>
<pre><code class="language-sh">vulkaninfo
</code></pre>
<h2 id="x11-and-wayland"><a class="header" href="#x11-and-wayland">X11 and Wayland</a></h2>
<p>As of the year 2023, the Linux desktop ecosystem is fragmented between
the legacy X11 stack and the modern Wayland stack. Many distributions are
switching to Wayland-based desktop environments by default.</p>
<p>Bevy supports both, but only X11 support is enabled by default. If you are
running a Wayland-based desktop, this means your Bevy app will run in the
XWayland compatibility layer.</p>
<p>To enable native Wayland support for Bevy, enable the <code>wayland</code> cargo feature:</p>
<pre><code class="language-toml">[dependencies]
bevy = { version = &quot;0.12&quot;, features = [&quot;wayland&quot;] }
</code></pre>
<p>Now your app will be built with support for both X11 and Wayland.</p>
<p>If you want to remove X11 support for whatever reason, you will have to disable
the default features and re-enable everything you need, without the <code>x11</code>
feature. <a href="platforms//setup/bevy-config.html">See here to learn how to configure Bevy features.</a></p>
<p>If both are enabled, you can override which display protocol to use at runtime,
using an environment variable:</p>
<pre><code class="language-shell">export WINIT_UNIX_BACKEND=x11
</code></pre>
<p>(to run using X11/XWayland on a Wayland desktop)</p>
<p>or</p>
<pre><code class="language-shell">export WINIT_UNIX_BACKEND=wayland
</code></pre>
<p>(to require the use of Wayland)</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="macos-desktop"><a class="header" href="#macos-desktop">macOS Desktop</a></h1>
<p>If you have any additional macOS-specific knowledge,
please help improve this page!</p>
<p>Create Issues or PRs on <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<hr />
<p><a href="platforms//setup/cross/macos-windows.html">See here if you also want to build Windows EXEs from macOS</a>.</p>
<h2 id="known-pitfalls-2"><a class="header" href="#known-pitfalls-2">Known Pitfalls</a></h2>
<h3 id="input-peculiarities"><a class="header" href="#input-peculiarities">Input Peculiarities</a></h3>
<p><a href="platforms//input/mouse.html#mouse-scrolling--wheel">Mouse wheel scrolling</a> behaves in a peculiar manner,
because macOS does &quot;scroll acceleration&quot; at the OS level. Other OSs, with
regular PC mice, provide <code>Line</code> scroll events with whole number values, where
1.0 corresponds to one step on the scroll wheel. macOS scales the value
depending on how fast the user is spinning the wheel. You do not get whole
numbers. They can range anywhere from tiny values &lt;0.1 (for the starting event,
before the scroll speed ramps up), up to values as big as &gt;10.0 (say, for a fast
flick of the wheel), per event.</p>
<p>macOS provides <a href="platforms//input/mouse.html#touchpad-gestures">special events for touchpad gestures</a>
for zooming and rotation, which you can handle in Bevy.</p>
<p>Some keyboard keys have a somewhat-unintuitive mapping:</p>
<ul>
<li>The Command (‚åò) key is <code>KeyCode::{SuperLeft, SuperRight}</code>.</li>
<li>The Option (‚å•) key is <code>KeyCode::{AltLeft, AltRight}</code>.</li>
</ul>
<p>Other key codes have their intuitive names.</p>
<h3 id="window-management-apps-compatability"><a class="header" href="#window-management-apps-compatability">Window Management Apps Compatability</a></h3>
<p>Bevy apps can encounter performance issues (such as lag when dragging the window
around the screen) when window management apps like &quot;Magnet&quot; are used. This is a
bug in <code>winit</code> (the OS window management library that Bevy uses). This issue can
be tracked <a href="https://github.com/rust-windowing/winit/issues/1737">here</a>.</p>
<p>Until that bug is fixed, advise closing the window management apps, if
encountering performance issues.</p>
<h2 id="creating-an-application-bundle"><a class="header" href="#creating-an-application-bundle">Creating an Application Bundle</a></h2>
<p>When you build your Bevy project normally, cargo/Rust will produce a bare
executable file, similar to other operating systems. However, this is not how
&quot;normal&quot; macOS apps look and behave. You probably want to create a proper
native-feeling Mac app for distribution to your users.</p>
<p>You need to do this, to have your app play nicely with the Mac desktop GUI, such
as to have a nice icon appear in the dock.</p>
<p>macOS applications are typically stored on the filesystem as &quot;bundles&quot; ‚Äì special
directories/folders that end in <code>.app</code>, that the OS displays to the user as one
item. macOS expects to find a special hieararchy of subfolders and files inside.</p>
<p>A minimal app bundle might have the following files:</p>
<ul>
<li><code>MyGame.app/Contents/MacOS/MyGame</code>: the actual executable file</li>
<li><code>MyGame.app/Contents/MacOS/assets/</code>: your Bevy assets folder</li>
<li><code>MyGame.app/Contents/Info.plist</code>: metadata (see below)</li>
<li><code>MyGame.app/Contents/Resources/AppIcon.icns</code>: the app's icon</li>
</ul>
<p>Only the executable file is technically mandatory. If you have nothing else, the
app will run, as long as the executable file name matches the app bundle file
name. You should, however, follow the below instructions, if you want to make a
proper nice Mac app. :)</p>
<h3 id="executable-file"><a class="header" href="#executable-file">Executable File</a></h3>
<p>The executable file produced by the Rust compiler (in the <code>target</code> directory) is
a single-architecture binary for your current development machine. You could
just copy this file into the app bundle, but then you will not support all Mac
hardware natively.</p>
<p>If you want to support both machines with Intel CPUs and with Apple Silicon
(Arm) CPUs, you need to compile for both of them, and then combine them into a
single executable using Apple's <code>lipo</code> tool.</p>
<p>First, make sure you have Rust toolchain support for both architectures installed:</p>
<pre><code class="language-sh">rustup target add x86_64-apple-darwin
rustup target add aarch64-apple-darwin
</code></pre>
<p>Now, you can compile for both architectures:</p>
<pre><code class="language-sh">cargo build --release --target x86_64-apple-darwin
cargo build --release --target aarch64-apple-darwin
</code></pre>
<p>Now, you can combine the two executables into one, for your app bundle.</p>
<pre><code class="language-sh">lipo &quot;target/x86_64-apple-darwin/release/my_game&quot; \
     &quot;target/aarch64-apple-darwin/release/my_game&quot; \
     -create -output &quot;MyGame.app/Contents/MacOS/MyGame&quot;
</code></pre>
<p>Note: please ensure the Bevy <code>dynamic_linking</code> cargo feature is <em><strong>not</strong></em> enabled.</p>
<h3 id="game-assets"><a class="header" href="#game-assets">Game Assets</a></h3>
<p>Your Bevy <code>assets</code> folder needs to be placed alongside the executable file,
for Bevy to find it and be able to load your assets. Just copy it into
<code>Contents/MacOS</code> in your app bundle.</p>
<p>Note: This is not the standard conventional location as prescribed by Apple.
Typically, macOS apps store their data files in <code>Contents/Resources</code>. However,
Bevy will not find them there. Thankfully, Apple does not enforce this, so we
are free to do something unusual when we have to.</p>
<h3 id="infoplist"><a class="header" href="#infoplist"><code>Info.plist</code></a></h3>
<p>This file contains all the metadata that macOS wants.</p>
<p>If you do not create this file, or if it is missing some of the fields, macOS
will try to guess them, so your app can still run. Ideally, you want to create a
proper <code>Info.plist</code> file, to prevent issues.</p>
<p><a href="platforms//dl/Info.plist">Download an example file as a starting point.</a></p>
<p>You can edit this file using Apple XCode or a text editor. Check that all the
values make sense for your app. Pay special attention to these values:</p>
<ul>
<li><code>CFBundleName</code> (Bundle name)
<ul>
<li>Short user-visible name of your app</li>
</ul>
</li>
<li><code>CFBundleDisplayName</code> (Bundle display name)
<ul>
<li>Optional: You can set a longer user-visible name here, if you want</li>
</ul>
</li>
<li><code>CFBundleExecutable</code> (Executable file)
<ul>
<li>The name of the executable file</li>
</ul>
</li>
<li><code>CFIconFile</code> (Icon file)
<ul>
<li>The name of the icon file</li>
</ul>
</li>
<li><code>CFBundleIdentifier</code> (Bundle identifier)
<ul>
<li>Apple wants an ID for your app, in domain format, like: <code>com.mycompany.mygame</code></li>
</ul>
</li>
<li><code>CFBundleShortVersionString</code> (Bundle version string (short))
<ul>
<li>The version of your app, like <code>0.1.0</code>.</li>
</ul>
</li>
</ul>
<h3 id="app-icon"><a class="header" href="#app-icon">App Icon</a></h3>
<p>The icon file needs to be in a special Apple format.</p>
<p>Such a file can be created from a collection of PNGs of different standard sizes
(powers of two). If you want your app to look nice at all sizes, you can
hand-craft an image for each size, following <a href="https://developer.apple.com/design/human-interface-guidelines/app-icons">Apple Design
Guidelines</a>. If you don't care, you can just take one image
(ideally 1024x1024, the biggest size used by macOS) and scale it to different sizes.</p>
<p>Here is a script that does that:</p>
<pre><code class="language-sh">SOURCE_IMAGE=&quot;myicon1024.png&quot;
mkdir -p AppIcon.iconset
sips -z 16 16     &quot;${SOURCE_IMAGE}&quot; --out AppIcon.iconset/icon_16x16.png
sips -z 32 32     &quot;${SOURCE_IMAGE}&quot; --out AppIcon.iconset/icon_16x16@2x.png
sips -z 32 32     &quot;${SOURCE_IMAGE}&quot; --out AppIcon.iconset/icon_32x32.png
sips -z 64 64     &quot;${SOURCE_IMAGE}&quot; --out AppIcon.iconset/icon_32x32@2x.png
sips -z 128 128   &quot;${SOURCE_IMAGE}&quot; --out AppIcon.iconset/icon_128x128.png
sips -z 256 256   &quot;${SOURCE_IMAGE}&quot; --out AppIcon.iconset/icon_128x128@2x.png
sips -z 256 256   &quot;${SOURCE_IMAGE}&quot; --out AppIcon.iconset/icon_256x256.png
sips -z 512 512   &quot;${SOURCE_IMAGE}&quot; --out AppIcon.iconset/icon_256x256@2x.png
sips -z 512 512   &quot;${SOURCE_IMAGE}&quot; --out AppIcon.iconset/icon_512x512.png
cp &quot;${SOURCE_IMAGE}&quot; AppIcon.iconset/icon_512x512@2x.png
iconutil -c icns AppIcon.iconset
## move it into the app bundle
mv AppIcon.icns MyGame.app/Contents/Resources
</code></pre>
<p>It works by creating a special <code>iconset</code> folder, with all the PNG files at different
sizes, created by resizing your source image. Then, it uses <code>iconutil</code> to produce
the final Apple ICNS file for your app bundle.</p>
<p>If you want hand-crafted icons for each size, you could use a similar process.
Create an <code>iconset</code> folder with your PNGs, and run <code>iconutil -c icns</code> on it.</p>
<p>Alternatively, Apple XCode has GUI tools for creating and editing app icons.</p>
<h3 id="putting-everything-together"><a class="header" href="#putting-everything-together">Putting Everything Together</a></h3>
<p>Here is a simple shell script to build a Mac app. It follows the recommendations
on this page. Adjust everything as necessary for your project.</p>
<pre><code class="language-sh"># set the name of the Mac App
APP_NAME=&quot;MyGame&quot;
# set the name of your rust crate
RUST_CRATE_NAME=&quot;my_game&quot;
# create the folder structure
mkdir -p &quot;${APP_NAME}.app/Contents/MacOS&quot;
mkdir -p &quot;${APP_NAME}.app/Contents/Resources&quot;
# copy Info.plist
cp Info.plist &quot;${APP_NAME}.app/Contents/Info.plist&quot;
# copy the icon (assuming you already have it in Apple ICNS format)
cp AppIcon.icns &quot;${APP_NAME}.app/Contents/Resources/AppIcon.icns&quot;
# copy your Bevy game assets
cp -a assets &quot;${APP_NAME}.app/Contents/MacOS/&quot;
# compile the executables for each architecture
cargo build --release --target x86_64-apple-darwin # build for Intel
cargo build --release --target aarch64-apple-darwin # build for Apple Silicon
# combine the executables into a single file and put it in the bundle
lipo &quot;target/x86_64-apple-darwin/release/${RUST_CRATE_NAME}&quot; \
     &quot;target/aarch64-apple-darwin/release/${RUST_CRATE_NAME}&quot; \
     -create -output &quot;${APP_NAME}.app/Contents/MacOS/${APP_NAME}&quot;
</code></pre>
<p>Note: please ensure the Bevy <code>dynamic_linking</code> cargo feature is <em><strong>not</strong></em> enabled.</p>
<h2 id="creating-a-dmg-file"><a class="header" href="#creating-a-dmg-file">Creating a DMG file</a></h2>
<p>It is common for Mac apps downloadable from the internet to be distributed as
DMG files ‚Äì Apple's &quot;disk image&quot; format. Users can drag-and-drop the app bundle
inside into their <code>Applications</code> folder on their system.</p>
<h3 id="create-dmg"><a class="header" href="#create-dmg"><code>create-dmg</code></a></h3>
<p>If you want to create a fancy DMG file, you can install and use the
<a href="https://github.com/create-dmg/create-dmg"><code>create-dmg</code> tool</a>.</p>
<p>If you are using Homebrew, you can install it easily from there:</p>
<pre><code class="language-sh">brew install create-dmg
</code></pre>
<p>Then, you can use it as follows:</p>
<pre><code class="language-sh">create-dmg \
  --volname &quot;My Bevy Game&quot; \
  --volicon &quot;AppIcon.icns&quot; \
  --background &quot;DMG-background.png&quot; \
  --window-size 800 400 \
  --icon-size 128 \
  --icon &quot;MyGame.app&quot; 200 200 \
  --hide-extension &quot;MyGame.app&quot; \
  --app-drop-link 600 200 \
  &quot;mybevygame_release_mac.dmg&quot; \
  &quot;build/mac/&quot;
</code></pre>
<p>The options are:</p>
<ul>
<li><code>--volname</code>: the name of the device when the user opens the DMG file</li>
<li><code>--volicon</code>: the icon of the device when the user opens the DMG file</li>
<li><code>--background</code>: the background image for the Finder window</li>
<li><code>--window-size</code>: the size of the Finder window</li>
<li><code>--icon-size</code>: the default zoom level (how big the icons should look)</li>
<li><code>--icon</code>: specify the X/Y coordinates where to display a specific file</li>
<li><code>--hide-extension</code>: do not display the file extension for this file</li>
<li><code>--app-drop-link</code>: create a shortcut to Applications for easy drag-and-drop; place at given X/Y coordinates</li>
<li>the name of the DMG file to create</li>
<li>the name of the folder where you have the files to be added to the DMG (your app + anything else you want to add)</li>
</ul>
<h3 id="hdiutil"><a class="header" href="#hdiutil"><code>hdiutil</code></a></h3>
<p>If you don't want to install any special tools, you can create a very simple
DMG file using <code>hdiutil</code>, which comes with macOS:</p>
<pre><code class="language-sh">hdiutil create -fs HFS+ \
  -volname &quot;My Bevy Game&quot; \
  -srcfolder &quot;MyGame.app&quot; \
  &quot;mybevygame_release_mac.dmg&quot;
</code></pre>
<p>Specify the Volume Name (how it appears when opened), the name of your app
bundle, and the name of the output DMG file, respectively. You can use
<code>-srcfolder</code> multiple times, if you want to add more files and folders to the
DMG image.</p>
<h3 id="gui"><a class="header" href="#gui">GUI</a></h3>
<p>If you want to create a DMG file using a GUI, you can use Apple's &quot;Disk
Utility&quot; app that comes preinstalled with macOS. Then, just use Finder to
set up everything inside how you like it.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="windows-desktop"><a class="header" href="#windows-desktop">Windows Desktop</a></h1>
<p>If you have any additional Windows-specific knowledge,
please help improve this page!</p>
<p>Create Issues or PRs on <a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub</a>.</p>
<hr />
<p>Windows is one of the best-supported platforms by Bevy.</p>
<p>Both the MSVC and the GNU compiler toolchains should work.</p>
<p>You can also build Windows EXEs while working in <a href="platforms//setup/cross/linux-windows.html">Linux</a>
or <a href="platforms//setup/cross/macos-windows.html">macOS</a>.</p>
<p>If you want to work inside WSL2, see <a href="platforms//platforms/windows/wsl2.html">this guide</a>.</p>
<h2 id="distributing-your-app"><a class="header" href="#distributing-your-app">Distributing Your App</a></h2>
<p>The EXE built with <code>cargo build</code> can work standalone without any extra files or DLLs.</p>
<p>Your <code>assets</code> folder needs be distributed alongside it. Bevy will search for it in
the same directory as the EXE on the user's computer.</p>
<p>The easiest way to give your game to other people to play is to put them
together in a ZIP file. If you use some other method of installation,
install the <code>assets</code> folder and the EXE to the same path.</p>
<p>If built with the MSVC toolchain, your users may need the Microsoft C/C++
Runtime Redistributables installed.</p>
<h3 id="dxc-compiler-support"><a class="header" href="#dxc-compiler-support">DXC Compiler Support</a></h3>
<p>Bevy (technically <code>wgpu</code>) supports using the Microsoft DXC compiler for
improved shader compilation when using DirectX 12.</p>
<p>To do this, you need to <a href="https://github.com/microsoft/DirectXShaderCompiler/releases/latest">download it from Microsoft's
repo</a> and put <code>dxcompiler.dll</code> and <code>dxil.dll</code>
alongside your game's EXE.</p>
<p>Bevy should detect these DLL files automatically and use them.</p>
<h2 id="disabling-the-windows-console"><a class="header" href="#disabling-the-windows-console">Disabling the Windows Console</a></h2>
<p>By default, when you run a Bevy app (or any Rust program for that matter)
on Windows, a Console window also shows up. To disable this,
place this Rust attribute at the top of your <code>main.rs</code>:</p>
<pre><code class="language-rust no_run noplayground">#![windows_subsystem = &quot;windows&quot;]</code></pre>
<p>This tells Windows that your executable is a graphical application, not a
command-line program. Windows will know not display a console.</p>
<p>However, the console can be useful for development, to see log messages.
You can disable it only for release builds, and leave it enabled in debug
builds, like this:</p>
<pre><code class="language-rust no_run noplayground">#![cfg_attr(not(debug_assertions), windows_subsystem = &quot;windows&quot;)]</code></pre>
<h2 id="creating-an-icon-for-your-app"><a class="header" href="#creating-an-icon-for-your-app">Creating an icon for your app</a></h2>
<p>There are two places where you might want to put your application icon:</p>
<ul>
<li>The EXE file (how it looks in the file explorer)</li>
<li>The window at runtime (how it looks in the taskbar and the window title bar)</li>
</ul>
<h3 id="setting-the-exe-icon"><a class="header" href="#setting-the-exe-icon">Setting the EXE icon</a></h3>
<p>(adapted from <a href="https://github.com/NiklasEi/bevy_game_template">here</a>)</p>
<p>The EXE icon can be set using a cargo build script.</p>
<p>Add a build dependency of <code>embed_resources</code> to your <code>Cargo.toml</code> allow embedding assets into your compiled executables</p>
<pre><code class="language-toml">[build-dependencies]
embed-resource = &quot;1.6.3&quot;
</code></pre>
<p>Create a <code>build.rs</code> file in your project folder:</p>
<pre><code class="language-rust no_run noplayground">extern crate embed_resource;

fn main() {
    let target = std::env::var(&quot;TARGET&quot;).unwrap();
    if target.contains(&quot;windows&quot;) {
        embed_resource::compile(&quot;icon.rc&quot;);
    }
}</code></pre>
<p>Create a <code>icon.rc</code> file in your project folder:</p>
<pre><code>app_icon ICON &quot;icon.ico&quot;
</code></pre>
<p>Create your icon as <code>icon.ico</code> in your project folder.</p>
<h3 id="setting-the-window-icon-1"><a class="header" href="#setting-the-window-icon-1">Setting the Window Icon</a></h3>
<p>See: <a href="platforms//window/icon.html">Setting the Window Icon</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms/windows//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h2 id="working-in-wsl2"><a class="header" href="#working-in-wsl2">Working in WSL2</a></h2>
<p>If you prefer to have a more Linux-centric development workflow, you might want
to work inside of WSL2 and build your project there. Another reason to do it is
compile times; they are often much faster in WSL2 than on the Windows host
system. Linux has faster I/O and filesystem than Windows, and that makes a big
difference to compile times.</p>
<h3 id="cross-compiling-to-run-windows-native"><a class="header" href="#cross-compiling-to-run-windows-native">Cross-compiling to run Windows Native</a></h3>
<p>The recommended way to run your Bevy app from WSL is to <a href="platforms/windows//setup/cross/linux-windows.html">cross-compile for
Windows</a>. The Windows EXE you build inside of WSL2 can
be run just fine from the Linux commandline, and it will seamlessly run on the
host system! This way, you don't need any GPU drivers or GUI support inside
your WSL2 Linux environment. Also, you will be running and testing the Windows
build of your game, so you can see how it will really perform on Windows.</p>
<p>Note that when you run Windows binaries from WSL2, they don't get the Linux
environment variables. <code>cargo run</code> does not just work, because your Bevy game
will look for its <code>assets</code> folder in the path where the EXE is (which would be
in the <code>target</code> build output folder). My simple solution is to just copy the
EXE into the project folder after building, and run it directly from there.
For non-Bevy Rust projects, this would be unnecessary.</p>
<p>The process can be automated with a little script, to use instead of <code>cargo run</code>:</p>
<pre><code class="language-sh">#!/bin/sh
cargo build --target x86_64-pc-windows-msvc &amp;&amp;
cp target/x86_64-pc-windows-msvc/debug/mygame.exe . &amp;&amp;
exec ./mygame.exe &quot;$@&quot;
</code></pre>
<p>This way you also don't have to type the cross-compilation target every time
(and you can also add any other options you want there).</p>
<p>Just save the script (you can call it something like <code>win.sh</code>) and run your
game as:</p>
<pre><code class="language-sh">./win.sh
</code></pre>
<h3 id="running-linux-builds-using-wslg"><a class="header" href="#running-linux-builds-using-wslg">Running Linux builds using WSLg</a></h3>
<p>This is an alternative way of running your Bevy game from WSL. It does not
require cross-compilation, but is likely to have other issues and limitations.</p>
<p>Newer installs of WSL2 should have support for WSLg: Microsoft's Linux GUI
support. It should allow you to simply compile your Bevy game in Linux and
run it. WSLg will do the dark magic needed to forward graphics and audio to
the Windows host.</p>
<p>Your game will only run with 60 FPS, and there will be other performance
overheads. WSLg is effectively RDP (Remote Desktop) under the hood. It's
like streaming video from the VM to the host. Some things might be
broken/unsupported.</p>
<p>Both Wayland and X11 should work. Wayland is recommended, so be sure to
enable the <code>&quot;wayland&quot;</code> <a href="platforms/windows//setup/bevy-config.html">cargo feature in Bevy</a>.</p>
<p>There are many dependencies (such as graphics drivers) needed for GUI support
in Linux, which are likely missing if you have never used any other GUI app
from your WSL environment. The easiest way to make sure you have everything installed,
is to just install some random Linux GUI app. For example:</p>
<pre><code class="language-sh">sudo apt install gucharmap # the GNOME Character Map app
</code></pre>
<p>It will pull in everything needed for a Linux GUI environment. Bevy should then
also be able to work.</p>
<p>This will be sufficient for OpenGL support. However, to use all features of
Bevy, you need Vulkan. For Vulkan in WSL, it is recommended that you use
a PPA (unofficial repository) to get an updated version of Mesa (graphics
drivers). Here is how to install everything:</p>
<pre><code class="language-sh">sudo add-apt-repository ppa:kisak/kisak-mesa
sudo apt update
sudo apt upgrade
sudo apt install vulkan-tools
</code></pre>
<p>(<code>dzn</code>, Microsoft's Vulkan driver for WSL2, is technically non-conformant,
so there may be bugs and other issues, but it seems to work fine)</p>
<p>Now, you can simply run your Bevy project in Linux:</p>
<pre><code class="language-sh">cargo run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="browser-webassembly"><a class="header" href="#browser-webassembly">Browser (WebAssembly)</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>You can make web browser games using Bevy. This chapter will help you with
the things you need to know to do it. This page gives an overview of Bevy's
Web support.</p>
<p>Your Bevy app will be compiled for WebAssembly (WASM), which allows it to
be embedded in a web page and run inside the browser.</p>
<p>Performance will be limited, as WebAssembly is slower than native code and
does not currently support multithreading.</p>
<p>Not all 3rd-party plugins are compatible. If you need extra unofficial plugins,
you will have to check if they are compatible with WASM.</p>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<p>The same Bevy project, without any special code modifications, can be built
for either web or desktop/native.</p>
<p>However, you will need a &quot;website&quot; with some HTML and JavaScript to contain the
game, so that the browser can load, run, and display it.</p>
<p>For development and testing, this can just be a minimal shim.
It can be easily autogenerated.</p>
<p>To deploy, you will need a server to host your website for other people to
access. You could use GitHub's hosting service: <a href="platforms//platforms/wasm/gh-pages.html">GitHub Pages</a>.
You can also host your game on <a href="platforms//platforms/wasm/itch.html">itch.io</a>.</p>
<h2 id="additional-caveats"><a class="header" href="#additional-caveats">Additional Caveats</a></h2>
<p>When users want to play your game, their browser will need to download the
files. <a href="platforms//platforms/wasm/size-opt.html">Optimizing for size</a> is important, so that your game can
start faster and not waste data bandwidth.</p>
<p>Note: the <code>dynamic_linking</code> <a href="platforms//setup/bevy-config.html">feature flag</a> is not supported for
WASM builds. You cannot use it.</p>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<p>First, add WASM support to your Rust installation. Using Rustup:</p>
<pre><code class="language-sh">rustup target install wasm32-unknown-unknown
</code></pre>
<h3 id="wasm-server-runner"><a class="header" href="#wasm-server-runner"><code>wasm-server-runner</code></a></h3>
<p>The easiest and most automatic way to get started is the
<a href="https://github.com/jakobhellermann/wasm-server-runner"><code>wasm-server-runner</code></a> tool.
It is great for testing during development.</p>
<p>Install it:</p>
<pre><code class="language-sh">cargo install wasm-server-runner
</code></pre>
<p>Set up <code>cargo</code> to use it, in <code>.cargo/config.toml</code> (in your project folder,
or globally in your user home folder):</p>
<pre><code class="language-toml">[target.wasm32-unknown-unknown]
runner = &quot;wasm-server-runner&quot;
</code></pre>
<p>Alternatively, you can also set the runner using an environment variable:</p>
<pre><code>export CARGO_TARGET_WASM32_UNKNOWN_UNKNOWN_RUNNER=wasm-server-runner
</code></pre>
<p>Now you can just run your game with:</p>
<pre><code class="language-sh">cargo run --target wasm32-unknown-unknown
</code></pre>
<p>It will automatically run a minimal local webserver and open your game in your browser.</p>
<h3 id="higher-level-tools"><a class="header" href="#higher-level-tools">Higher-level Tools</a></h3>
<p>Here are some higher-level alternatives. These are feature-rich tools that can
do more for you and automate much of your workflow, but are opinionated in how
they work.</p>
<ul>
<li><a href="https://trunkrs.dev">Trunk</a></li>
<li><a href="https://github.com/rustwasm/wasm-pack"><code>wasm-pack</code></a></li>
</ul>
<h3 id="custom-web-page"><a class="header" href="#custom-web-page">Custom Web Page</a></h3>
<p>If you are a web developer and you want to make your own website where you embed
your Bevy game, <a href="platforms//platforms/wasm/webpage.html">see here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms/wasm//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="optimize-for-size"><a class="header" href="#optimize-for-size">Optimize for Size</a></h1>
<p>When serving a WASM binary, the smaller it is, the faster the browser can
download it. Faster downloads means faster page load times and less data
bandwidth use, and that means happier users and happier server hosts. ;)</p>
<p>This page gives some suggestions for how to make your WASM files smaller for
deployment / release builds. You probably don't need small WASM files during
development, and many of these techniques can get in the way of your workflow!
They come at the cost of longer compile times and less debuggability.</p>
<p>Depending on the nature of your application, your mileage may vary, and
performing measurements of binary size and execution speed is recommended.</p>
<p><a href="https://github.com/rustwasm/twiggy">Twiggy</a> is a code size profiler for WASM binaries, which
you can use to make measurements.</p>
<p>For additional information and more techniques, refer to the Code Size
chapter in the <a href="https://rustwasm.github.io/docs/book/reference/code-size.html">Rust WASM book</a>.</p>
<p>Do you know of more WASM size-optimization techniques? Post about them in the
<a href="https://github.com/bevy-cheatbook/bevy-cheatbook">GitHub Issue Tracker</a> so that they can be added to this page!</p>
<h2 id="compiling-for-size-instead-of-speed"><a class="header" href="#compiling-for-size-instead-of-speed">Compiling for size instead of speed</a></h2>
<p>You can change the optimization profile of the compiler, to tell it to
prioritize small output size, rather than performance.</p>
<p>(although in some rare cases, optimizing for size can actually improve speed)</p>
<p>In <code>Cargo.toml</code>, add one of the following:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 'z'
</code></pre>
<pre><code class="language-toml">[profile.release]
opt-level = 's'
</code></pre>
<p>These are two different profiles for size optimization. Usually, <code>z</code> produces
smaller files than <code>s</code>, but sometimes it can be the opposite. Measure to
confirm which one works better for you.</p>
<h2 id="link-time-optimization-lto"><a class="header" href="#link-time-optimization-lto">Link-Time Optimization (LTO)</a></h2>
<p>In <code>Cargo.toml</code>, add one of the following:</p>
<p>For some big improvements with moderate slowdown to compile times:</p>
<pre><code class="language-toml">[profile.release]
lto = &quot;thin&quot;
</code></pre>
<p>For the biggest improvements at the cost of the slowest compile times:</p>
<pre><code class="language-toml">[profile.release]
lto = true
codegen-units = 1
</code></pre>
<p>LTO tells the compiler to optimize all code together, considering all crates as
if they were one. It may be able to inline and prune functions much more
aggressively. This typically results in smaller size <em>and</em> better performance,
but do measure to confirm. Sometimes, the size can actually be larger.</p>
<h2 id="use-the-wasm-opt-tool"><a class="header" href="#use-the-wasm-opt-tool">Use the <code>wasm-opt</code> tool</a></h2>
<p>The <a href="https://github.com/WebAssembly/binaryen">binaryen</a> toolkit is a set of extra tools for working
with WASM. One of them is <code>wasm-opt</code>. It goes much further than what the
compiler can do, and can be used to further optimize for either speed or size:</p>
<pre><code class="language-shell"># Optimize for size (z profile).
wasm-opt -Oz -o output.wasm input.wasm

# Optimize for size (s profile).
wasm-opt -Os -o output.wasm input.wasm

# Optimize for speed.
wasm-opt -O3 -o output.wasm input.wasm

# Optimize for both size and speed.
wasm-opt -O -ol 100 -s 100 -o output.wasm input.wasm
</code></pre>
<p>You should run this command on the final WASM file you deploy to your website,
after <code>wasm-bindgen</code> or other tools. If you run it before, <code>wasm-bindgen</code> can
get confused and panic.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms/wasm//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="create-a-custom-web-page"><a class="header" href="#create-a-custom-web-page">Create a Custom Web Page</a></h1>
<p>If you want full control over your website, such as if you are a web developer
and you want to embed your Bevy game into a nice website you made, this page
will offer some tips.</p>
<h2 id="wasm-bindgen"><a class="header" href="#wasm-bindgen"><code>wasm-bindgen</code></a></h2>
<p>This is the &quot;low level&quot; tool for exporting/preparing a Rust WASM binary, so
it can be integrated into HTML/JS. It generates the bridge to JavaScript,
so that Rust/Bevy can work with the browser.</p>
<p>You will need to run it whenever you rebuild your game, to process the WASM
binaries generated by <code>cargo</code>.</p>
<p>You can install it using <code>cargo</code>:</p>
<pre><code class="language-sh">cargo install wasm-bindgen-cli
</code></pre>
<p>Now, to build your game, run:</p>
<pre><code class="language-sh">cargo build --release --target wasm32-unknown-unknown
wasm-bindgen --no-typescript --target web \
    --out-dir ./out/ \
    --out-name &quot;mygame&quot; \
    ./target/wasm32-unknown-unknown/release/mygame.wasm
</code></pre>
<p>You need to provide the path to the compiled WASM binary in cargo's target directory.
It will be renamed according to the <code>--out-name</code> parameter.</p>
<p><code>./out/</code> is the directory where it will place the processed files. You will be
uploading these files to your server. You need to also put the <code>assets</code> folder
there. Bevy will expect to find it alongside the WASM file.</p>
<p>The final list of files for a minimal website will look something like this:</p>
<pre><code>assets/ index.html mygame.js mygame_bg.wasm
</code></pre>
<p>In a more compex website, you might want to have the game files be in a
subdirectory somewhere, and load them from a HTML file elsewhere.</p>
<p>For the HTML file, you can use this as a starting point:</p>
<details>
  <summary>
  <code>index.html</code>
  </summary>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;body style=&quot;margin: 0px;&quot;&gt;
  &lt;script type=&quot;module&quot;&gt;
    import init from './mygame.js'

    init().catch((error) =&gt; {
      if (!error.message.startsWith(&quot;Using exceptions for control flow, don't mind me. This isn't actually an error!&quot;)) {
        throw error;
      }
    });
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>Note: change <code>mygame.js</code> above to the actual name of the file outputted by <code>wasm-bindgen</code>.
It will match the <code>--out-name</code> parameter you provided on the commandline.</p>
<p>This minimal <code>index.html</code> will just display the Bevy game, without giving you
much control over the presentation. By default, Bevy will create its own HTML
canvas element to render in.</p>
</details>
<p>You can optionally run tools like <code>wasm-opt</code> on the final WASM file, to
<a href="platforms/wasm//platforms/wasm/size-opt.html">optimize the WASM further for size</a>. Run such tools <em>after</em>
<code>wasm-bindgen</code>, not on the original WASM file. Otherwise, <code>wasm-bindgen</code> will
panic with an error if you give it a file processed with <code>wasm-opt</code>.</p>
<h2 id="embedding-into-a-complex-web-page"><a class="header" href="#embedding-into-a-complex-web-page">Embedding into a complex web page</a></h2>
<p>You probably want control over how/where the game is displayed, so you can place
it on a fancier web page, alongside other content.</p>
<h3 id="iframe"><a class="header" href="#iframe">IFrame</a></h3>
<p>A simple/hacky way is using an IFrame. The advantage is that you don't need any
modifications to the Rust code.</p>
<p>You can create a minimal <code>index.html</code> as was shown previously.</p>
<p>You can then embed that into your larger webpage using a HTML IFrame element:</p>
<pre><code class="language-html">&lt;iframe id=&quot;mygame-iframe&quot; src=&quot;wasm/index.html&quot; width=&quot;1280&quot; height=&quot;720&quot;&gt;&lt;/iframe&gt;
</code></pre>
<p>You can place it wherever you like on your web page and style it however you
like using CSS. It is recommended to explicitly specify its dimensions.</p>
<p>Make sure to use the correct path to the HTML file in <code>src</code>. You might want to
rename/move it according to your website's needs.</p>
<h3 id="custom-canvas"><a class="header" href="#custom-canvas">Custom Canvas</a></h3>
<p>A more elegant way to accomplish this is by using your own canvas element. You
don't need a separate HTML file.</p>
<p>Create a HTML canvas and give it an ID string of your choice.</p>
<pre><code class="language-html">&lt;canvas id=&quot;mygame-canvas&quot; width=&quot;1280&quot; height=&quot;720&quot;&gt;&lt;/canvas&gt;
</code></pre>
<p>You can place it wherever you like on your web page and style it however you
like using CSS. It is recommended to explicitly specify its dimensions.</p>
<p>On the Rust side, we need to tell Bevy the ID of the canvas element, so it can
use our canvas instead of trying to create its own.</p>
<pre><code class="language-rust no_run noplayground">fn main() {
    let mut app = App::new();
    app.add_plugins(DefaultPlugins.set(WindowPlugin {
        primary_window: Some(Window {
            // provide the ID selector string here
            canvas: Some(&quot;#mygame-canvas&quot;.into()),
            // ... any other window properties ...
            ..default()
        }),
        ..default()
    }));
    // ...
    app.run();
}</code></pre>
<p>Unfortunately, this means if you want to rename the ID of the canvas, you will
have to make sure to update the Rust code and rebuild/redeploy the game.</p>
<h2 id="general-advice"><a class="header" href="#general-advice">General Advice</a></h2>
<p>Bevy WASM binaries are big. Even when [optimized for size][wasm::opt-size], they can be
upwards of 30MB (reduced down to 15MB with <code>wasm-opt</code>).</p>
<p>To make your page fast to load, you might want to delay the loading of the WASM.
Let the user see and interact with the page before you trigger it.</p>
<p>You could use some JavaScript to detect when the user clicks on the canvas, or
have a special button or link to trigger it.</p>
<p>Further, after the WASM loads and your Bevy game is running, your game will
probably want to load assets at runtime. Make sure your assets are
well-compressed/optimized, so they can load quickly. Try to design your game so
that it isn't unresponsive or making the user suffer annoying waits.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="platforms/wasm//introduction.html#maintenance-policy">Bevy Version:</a></th><th><a href="https://bevyengine.org/news/bevy-0-12">0.12</a></th><th>(current)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="hosting-on-github-pages"><a class="header" href="#hosting-on-github-pages">Hosting on GitHub Pages</a></h1>
<p>GitHub Pages is a hosting service that allows you to publish your website
on GitHub's servers.</p>
<p>For more details, visit the official <a href="https://docs.github.com/en/pages">GitHub Pages
documentation</a>.</p>
<p>Deploying a website (like your WASM game) to GitHub pages is done by
putting the files in a special branch in a GitHub repository. You could
create a separate repository for this, but you could also do it from the
same repository as your source code.</p>
<p>You will need the final website files for deployment.</p>
<hr />
<p>Create an empty branch in your git repository:</p>
<pre><code class="language-shell">git checkout --orphan web
git reset --hard
</code></pre>
<p>You should now be in an empty working directory.</p>
<p>Put all files necessary for hosting, including your HTML, WASM, JavaScript,
and <code>assets</code> files, and commit them into git:</p>
<pre><code class="language-shell">git add *
git commit
</code></pre>
<p>(or better, manually list your files in the above command, in place of the <code>*</code> wildcard)</p>
<p>Push your new branch to GitHub:</p>
<pre><code class="language-shell">git push -u origin web --force
</code></pre>
<p>In the GitHub Web UI, go to the repository settings, go to the &quot;GitHub Pages&quot;
section, then under &quot;Source&quot; pick the branch &quot;web&quot; and the <code>/</code> (root) folder.
Then click &quot;Save&quot;.</p>
<p>Wait a little bit, and your site should become available at
<code>https://your-name.github.io/your-repo</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup//introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="cross-compilation"><a class="header" href="#cross-compilation">Cross-Compilation</a></h1>
<p>This sub-chapter covers how to make builds of your Bevy apps to run on a
different Operating System than the one you are working on.</p>
<ul>
<li><a href="setup//setup/cross/linux-windows.html">Create Windows EXEs from Linux</a></li>
<li><a href="setup//setup/cross/macos-windows.html">Create Windows EXEs from macOS</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/cross//introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="build-windows-exes-from-linux"><a class="header" href="#build-windows-exes-from-linux">Build Windows EXEs from Linux</a></h1>
<p>(also check out the <a href="setup/cross//platforms/windows.html">Windows Platform page</a> for info
about developing for Windows generally)</p>
<hr />
<p>Rust offers two different toolchains for building for Windows:</p>
<ul>
<li><a href="setup/cross/linux-windows.html#first-time-setup-msvc">MSVC</a>: the default when working in Windows, requires downloading Microsoft SDKs</li>
<li><a href="setup/cross/linux-windows.html#first-time-setup-gnu">GNU</a>: alternative MINGW-based build</li>
</ul>
<p>The instructions on this page use the <code>x86_64</code> architecture, but you could also
set up a toolchain to target <code>i686</code> (32-bit) or <code>aarch64</code> (Windows-on-Arm) the
same way.</p>
<h2 id="first-time-setup-msvc"><a class="header" href="#first-time-setup-msvc">First-Time Setup (MSVC)</a></h2>
<p>The MSVC toolchain is what the Rust community usually recommends for targetting
the Windows platform. You can actually set it up and use it on Linux (and other
UNIX-like systems), using some special tooling, which will be explained below.</p>
<h3 id="rust-toolchain-msvc"><a class="header" href="#rust-toolchain-msvc">Rust Toolchain (MSVC)</a></h3>
<p>Add the target to your Rust installation (assuming you use <a href="https://rustup.rs"><code>rustup</code></a>):</p>
<pre><code class="language-sh">rustup target add x86_64-pc-windows-msvc
</code></pre>
<p>This installs the files Rust needs to compile for Windows, including the
Rust standard library.</p>
<h3 id="microsoft-windows-sdks"><a class="header" href="#microsoft-windows-sdks">Microsoft Windows SDKs</a></h3>
<p>You need to install the Microsoft Windows SDKs, just like when working on
Windows. On Linux, this can be done with an easy script called <code>xwin</code>. You
need to accept Microsoft's proprietary license.</p>
<p>Install <code>xwin</code>:</p>
<pre><code class="language-sh">cargo install xwin
</code></pre>
<p>Now, use <code>xwin</code> to accept the Microsoft license, download all the files
from Microsoft servers, and install them to a directory of your choosing.</p>
<p>(The <code>--accept-license</code> option is to not prompt you, assuming you have already
seen the license. To read the license and be prompted to accept it, omit that
option.)</p>
<p>To install to <code>.xwin/</code> in your home folder:</p>
<pre><code class="language-sh">xwin --accept-license splat --output /home/me/.xwin
</code></pre>
<h3 id="linking-msvc"><a class="header" href="#linking-msvc">Linking (MSVC)</a></h3>
<p>Rust needs to know how to link the final EXE file.</p>
<p>The default Microsoft linker (<code>link.exe</code>) is only available on Windows. Instead,
we need to use the LLD linker (this is also recommended when working on Windows
anyway). Just install the <code>lld</code> package from your Linux distro.</p>
<p>We also need to tell Rust the location of the Microsoft Windows SDK libraries
(that were installed with <code>xwin</code> in <a href="setup/cross/linux-windows.html#microsoft-windows-sdks">the previous step</a>).</p>
<p>Add this to <code>.cargo/config.toml</code> (in your home folder or in your bevy project):</p>
<pre><code class="language-toml">[target.x86_64-pc-windows-msvc]
linker = &quot;lld&quot;
rustflags = [
  &quot;-Lnative=/home/me/.xwin/crt/lib/x86_64&quot;,
  &quot;-Lnative=/home/me/.xwin/sdk/lib/um/x86_64&quot;,
  &quot;-Lnative=/home/me/.xwin/sdk/lib/ucrt/x86_64&quot;
]
</code></pre>
<p>Note: you need to specify the correct full absolute paths to the SDK files,
wherever you installed them.</p>
<h2 id="first-time-setup-gnu"><a class="header" href="#first-time-setup-gnu">First-Time Setup (GNU)</a></h2>
<p>On many Linux distros, the alternative GNU/MINGW toolchain might be an easier
option. Your distro might provide packages that you can easily install. Also,
you do not need to accept any Microsoft licenses.</p>
<h3 id="rust-toolchain-gnu"><a class="header" href="#rust-toolchain-gnu">Rust Toolchain (GNU)</a></h3>
<p>Add the target to your Rust installation (assuming you use <a href="https://rustup.rs"><code>rustup</code></a>):</p>
<pre><code class="language-sh">rustup target add x86_64-pc-windows-gnu
</code></pre>
<p>This installs the files Rust needs to compile for Windows, including the
Rust standard library.</p>
<h3 id="mingw"><a class="header" href="#mingw">MINGW</a></h3>
<p>The GNU toolchain requires the MINGW environment to be installed. Your distro likely
provides a package for it. Search your distro for a cross-compilation mingw package.</p>
<p>It might be called something like: <code>cross-x86_64-w64-mingw32</code>, but that varies in different distros.</p>
<p>You don't need any files from Microsoft.</p>
<h2 id="building-your-project"><a class="header" href="#building-your-project">Building Your Project</a></h2>
<p>Finally, with all the setup done, you can just build your Rust/Bevy projects
for Windows:</p>
<p>MSVC:</p>
<pre><code class="language-sh">cargo build --target=x86_64-pc-windows-msvc --release
</code></pre>
<p>MinGW:</p>
<pre><code class="language-sh">cargo build --target=x86_64-pc-windows-gnu --release
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="setup/cross//introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="build-windows-exes-from-macos"><a class="header" href="#build-windows-exes-from-macos">Build Windows EXEs from macOS</a></h1>
<p>(also check out the <a href="setup/cross//platforms/windows.html">Windows Platform page</a> for info
about developing for Windows generally)</p>
<hr />
<p>Rust offers two different toolchains for building for Windows:</p>
<ul>
<li><a href="setup/cross/macos-windows.html#first-time-setup-msvc">MSVC</a>: the default when working in Windows, requires downloading Microsoft SDKs</li>
<li><a href="setup/cross/macos-windows.html#first-time-setup-gnu">GNU</a>: alternative MINGW-based build</li>
</ul>
<p>On macOS, the GNU software is not readily-available. I don't know how it could
be installed. Even if possible, it might be difficult to set up.</p>
<p>This page will teach you how to setup a MSVC-based toolchain, which works on
macOS and <a href="setup/cross//setup/cross/linux-windows.html">can be set up similarly to how it can be done on
Linux.</a>. You will need to accept Microsoft licenses.</p>
<p>The instructions on this page use the <code>x86_64</code> architecture, but you could also
set up a toolchain to target <code>i686</code> (32-bit) or <code>aarch64</code> (Windows-on-Arm) the
same way.</p>
<h2 id="first-time-setup"><a class="header" href="#first-time-setup">First-Time Setup</a></h2>
<h3 id="rust-toolchain"><a class="header" href="#rust-toolchain">Rust Toolchain</a></h3>
<p>Add the target to your Rust installation (assuming you use <a href="https://rustup.rs"><code>rustup</code></a>):</p>
<pre><code class="language-sh">rustup target add x86_64-pc-windows-msvc
</code></pre>
<p>This installs the files Rust needs to compile for Windows, including the
Rust standard library.</p>
<h3 id="microsoft-windows-sdks-1"><a class="header" href="#microsoft-windows-sdks-1">Microsoft Windows SDKs</a></h3>
<p>You need to install the Microsoft Windows SDKs, just like when working on
Windows. This can be done with an easy script called <code>xwin</code>. You need to accept
Microsoft's proprietary license.</p>
<p>Install <code>xwin</code>:</p>
<pre><code class="language-sh">cargo install xwin
</code></pre>
<p>Now, use <code>xwin</code> to accept the Microsoft license, download all the files
from Microsoft servers, and install them to a directory of your choosing.</p>
<p>(The <code>--accept-license</code> option is to not prompt you, assuming you have already
seen the license. To read the license and be prompted to accept it, omit that
option.)</p>
<p>To install to <code>.xwin/</code> in your home folder:</p>
<pre><code class="language-sh">xwin --accept-license splat --disable-symlinks --output /Users/me/.xwin
</code></pre>
<p>On Windows and macOS, the filesystem is case-insensitive. On Linux and BSD, the
filesystem is case-sensitive. <code>xwin</code> was made for Linux, so it tries to work
around this by default, by creating symlinks. On macOS, we need to tell <code>xwin</code>
not to do this, using the <code>--disable-symlinks</code> option.</p>
<h3 id="linking"><a class="header" href="#linking">Linking</a></h3>
<p>Rust needs to know how to link the final EXE file.</p>
<p>The default Microsoft linker (<code>link.exe</code>) is only available on Windows. Instead,
we need to use the LLD linker (this is also recommended when working on Windows
anyway).</p>
<h4 id="installing-lld"><a class="header" href="#installing-lld">Installing LLD</a></h4>
<p>Unfortunately, last I checked, neither <code>brew</code> nor <code>macports</code> offer packages (LLD
is not commonly used when developing for macOS).</p>
<p>We can, however, build it ourselves from source. You need a C++ compiler and
CMake. You probably already have the C++ toolchain installed, if you have
installed Apple XCode development tools.</p>
<p>CMake can be installed from <code>brew</code> (<a href="https://brew.sh">Homebrew</a>):</p>
<pre><code class="language-sh">brew install cmake
</code></pre>
<p>Now, we are ready to compile LLD from the LLVM project:</p>
<p>Note: the <code>--depth=1</code> option to <code>git clone</code> allows us to save a lot of disk
space and download bandwidth, because the LLVM respository is <em>huge</em>.</p>
<pre><code class="language-sh">git clone --depth=1 https://github.com/llvm/llvm-project
cd llvm-project
mkdir build
cd build
cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=lld -DCMAKE_INSTALL_PREFIX=/usr/local ../llvm
sudo make -j10 install # adjust `-j10` based on your number of CPU cores
cd ../../; rm -rf llvm-project # delete the git repo and build files to free disk space
</code></pre>
<p>This will install it to <code>/usr/local</code>. Change the path above if you would rather
have it somewhere else, to not pollute your macOS or need <code>sudo</code> / root privileges.</p>
<h4 id="using-lld"><a class="header" href="#using-lld">Using LLD</a></h4>
<p>We also need to tell Rust to use our linker, and the location of the Microsoft
Windows SDK libraries (that were installed with <code>xwin</code> in <a href="setup/cross/macos-windows.html#microsoft-windows-sdks">the previous
step</a>).</p>
<p>Add this to <code>.cargo/config.toml</code> (in your home folder or in your bevy project):</p>
<pre><code class="language-toml">[target.x86_64-pc-windows-msvc]
linker = &quot;/usr/local/bin/lld&quot;
rustflags = [
  &quot;-Lnative=/Users/me/.xwin/crt/lib/x86_64&quot;,
  &quot;-Lnative=/Users/me/.xwin/sdk/lib/um/x86_64&quot;,
  &quot;-Lnative=/Users/me/.xwin/sdk/lib/ucrt/x86_64&quot;
]
</code></pre>
<p>Note: you need to specify the correct full absolute paths to the SDK files,
wherever you installed them.</p>
<h2 id="building-your-project-1"><a class="header" href="#building-your-project-1">Building Your Project</a></h2>
<p>Finally, with all the setup done, you can just build your Rust/Bevy projects
for Windows:</p>
<pre><code class="language-sh">cargo build --target=x86_64-pc-windows-msvc --release
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="credits"><a class="header" href="#credits">Credits</a></h1>
<p>While the majority of this book was authored by me, Ida Iyes (<code>@inodentry</code>), a
number of folks have made large contributions to help! Thank you all so much! ‚ù§Ô∏è</p>
<hr />
<ul>
<li>Alice I. Cecile <code>@alice-i-cecile</code>: review, advice, reporting lots of good suggestions</li>
<li>nile <code>@TheRawMeatball</code>: review, useful issue reports</li>
<li><code>@Zaszi</code>: writing the initial draft of the WASM chapter</li>
<li><code>@skairunner</code> and <code>@mirenbharta</code>: developing the Pan+Orbit camera example</li>
</ul>
<p>Thanks to everyone who has submitted <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub issues</a>!</p>
<hr />
<p>Big thanks to all <a href="https://github.com/sponsors/inodentry">sponsors</a>! ‚ù§Ô∏è </p>
<p>Thanks to you, I can actually keep working on this book, improving and maintaining it!</p>
<hr />
<p>And of course, the biggest thanks goes to the <a href="https://github.com/bevyengine/bevy">Bevy project</a>
itself and its founder, <code>@cart</code>, for creating this awesome community and
game engine in the first place! It makes all of this possible. You literally
changed my life! ‚ù§Ô∏è</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="contact-me"><a class="header" href="#contact-me">Contact Me</a></h1>
<p>You can find me in the following places:</p>
<ul>
<li>Discord: <code>@iyesgames</code>, old: <code>Ida Iyes#0981</code></li>
<li>Mastodon: <a href="https://mastodon.gamedev.place/@iyes"><code>@iyes@mastodon.gamedev.place</code></a></li>
<li>GitHub: <a href="https://github.com/inodentry"><code>@inodentry</code></a></li>
<li>Reddit: <a href="https://reddit.com/u/iyesgames"><code>iyesgames</code></a></li>
<li>E-mail: iyesgames dot social at gmail (sorry, i'm writing it out like this to avoid spam bots)</li>
</ul>
<p>For improvements or fixes to this book, please file an issue
on <a href="https://github.com/bevy-cheatbook/bevy-cheatbook/issues">GitHub</a>.</p>
<hr />
<p>If you need help with Bevy or Rust, I offer private tutoring.
Reach out if you are interested, to discuss rates and how I
could best help you. :)</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="contributing-to-bevy"><a class="header" href="#contributing-to-bevy">Contributing to Bevy</a></h1>
<p>If you want to help out the Bevy Game Engine project, check out Bevy's
<a href="https://github.com/bevyengine/bevy/blob/main/CONTRIBUTING.md">official contributing guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><div class="table-wrapper"><table><thead><tr><th><a href="/introduction.html#maintenance-policy">Bevy Version:</a></th><th>(any)</th></tr></thead><tbody>
</tbody></table>
</div>
<h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>Be civil. If you need a code of conduct, have a look at Bevy's.</p>
<p>If you have any suggestions for the book, such as ideas for new content, or
if you notice anything that is incorrect or misleading, please file issues in
<a href="https://github.com/bevy-cheatbook/bevy-cheatbook">the GitHub repository</a>!</p>
<h2 id="github-issues"><a class="header" href="#github-issues">GitHub Issues</a></h2>
<p>If you want something to be added or changed in the book, <em>file an issue!</em> Tell
me what you want, and I will figure out how to present it in the book. If you
have some code snippet or other thing you want to include, you can
put it in the issue.</p>
<p>That sort of workflow works much better for me, compared to Pull Requests. I am
quite opinionated and meticulous about how everything is presented in the book,
so I often can't just merge/accept things as written by someone else.</p>
<h2 id="github-pull-requests"><a class="header" href="#github-pull-requests">GitHub Pull Requests</a></h2>
<p><strong>PLEASE DO NOT CREATE PULL REQUESTS FOR BOOK CONTENT.</strong></p>
<p>The only exception to this might be trivial fixes. If you are just fixing
a typo or small mistake, or a bug in some code example, that's fine.</p>
<p>If you are adding or changing any of the book content, your PR will probably be
ignored or closed. I will probably treat it like I do issues: go do the thing
myself eventually, and then close your PR.</p>
<p>PRs create more work for me. They make life harder, not easier. Every time
someone has made a PR before, I've had to basically rewrite it / redo
the work myself. And also figure out how to respond to the author. And
also wrangle merge conflicts and git branches. Please don't. I'm tired.</p>
<h2 id="licensing"><a class="header" href="#licensing">Licensing</a></h2>
<p>To avoid complications with copyright and licensing, you agree to provide
any contributions you make to the project under the <a href="https://github.com/bevy-cheatbook/mit-0">MIT-0 No Attribution
License</a>.</p>
<p>Note that this allows your work to be relicensed without preserving your
copyright.</p>
<p>As described previously, the actual published content in the book will be my
own derivative work based on your contributions. I will license it consistently
with the rest of the book; see: <a href="./introduction.html#license">License</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="nagbar.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
